use.miden::kernels::tx::account
use.miden::kernels::tx::asset
use.miden::kernels::tx::constants
use.miden::kernels::tx::memory
use.miden::kernels::tx::note

# CONSTANTS
# =================================================================================================

# Constants for different note types
const.PUBLIC_NOTE=1     # 0b01
const.OFFCHAIN_NOTE=2   # 0b10
const.ENCRYPTED_NOTE=3  # 0b11

# ERRORS
# =================================================================================================

# Output notes exceeded the maximum limit of 4096
const.ERR_TX_OUTPUT_NOTES_OVERFLOW=0x00020020

# Invalid note type
const.ERR_INVALID_NOTE_TYPE=0x00020044

# The 2 highest bits in the u32 tag has the following meaning:
#
# | bits | Execution | Target    | Note type |
# | ---- | --------- | --------- | --------- |
# | 00   | Network   | Specific  | Public    |
# | 01   | Network   | Use case  | Public    |
# | 10   | Local     | Any       | Public    |
# | 11   | Local     | Any       | Any       |
#
# Execution: Is a hint for the network, to check if the note can be consumed by a network controlled
#   account
# Target: Is a hint for the type of target. Use case means the note may be consumed by anyone,
#   specific means there is an specific target for the note (the target may be a public key, a user
#   that knows some secret, or a specific account id)
#
# Only the note type from the above list is enforced. The other values are only hints intended as a
# best effort optimization strategy. A badly formatted note may 1. not be consumed because honest
# users won't see the note 2. generate slightly more load as extra validation is performed for the
# invalid tags. None of these scenarios have any significant impact.
#
const.ERR_NOTE_INVALID_TYPE_FOR_TAG=0x00020045

# The note type must be PUBLIC, unless the high bits are `0b11`. (See the table above)
const.ALL_NOTE_TYPES_ALLOWED=3 # 0b11

# The note's tag must be an u32 so the the high 32bits must be zero.
const.ERR_NOTE_TAG_MUST_BE_U32=0x00020046

# Adding a fungible asset to a note cannot exceed the max_amount of 9223372036854775807
const.ERR_NOTE_FUNGIBLE_MAX_AMOUNT_EXCEEDED=0x00020050

# Non-fungible asset that already exists in the note cannot be added again
const.ERR_NON_FUNGIBLE_ASSET_ALREADY_EXISTS=0x00020051

# EVENTS
# =================================================================================================

# Event emitted when a new note is created.
const.NEW_NOTE_EVENT=131077

# Event emitted when an ASSET is added to a note
const.NEW_ASSET_TO_NOTE_EVENT=131079

#! Returns the block hash of the last known block at the time of transaction execution.
#!
#! Inputs: []
#! Outputs: [H]
#!
#! H is the last known block hash.
export.memory::get_blk_hash->get_block_hash

#! Returns the block number of the last known block at the time of transaction execution.
#!
#! Inputs: []
#! Outputs: [num]
#!
#! num is the last known block number.
export.memory::get_blk_num->get_block_number

#! Returns the input notes hash. This is computed as a sequential hash of (nullifier, script_root)
#! tuples over all input notes.
#!
#! Inputs: []
#! Outputs: [COM]
#!
#! COM is the input notes hash.
export.memory::get_nullifier_com->get_input_notes_hash

#! Returns the output notes hash. This is computed as a sequential hash of (note_hash, note_metadata)
#! tuples over all output notes.
#!
#! Inputs: []
#! Outputs: [COM]
#!
#! COM is the output notes hash.
export.note::compute_output_notes_commitment->get_output_notes_hash

#! Increments the number of created notes by one. Returns the index of the next note to be created.
#!
#! Inputs: []
#! Outputs: [note_idx]
proc.increment_num_created_notes
    # get the current number of created notes
    exec.memory::get_num_created_notes
    # => [note_idx]

    # assert that there is space for a new note
    dup exec.constants::get_max_num_created_notes lt assert.err=ERR_TX_OUTPUT_NOTES_OVERFLOW
    # => [note_idx]

    # increment the number of created notes
    dup add.1 exec.memory::set_num_created_notes
    # => [note_idx]
end

#! Inputs: [ASSET, note_ptr, num_of_assets]
#! Outputs: [note_ptr]
proc.add_non_fungible_asset_to_note
    dup.4 exec.memory::get_created_note_asset_data_ptr
    # => [asset_ptr, ASSET, note_ptr, num_of_assets]

    # compute the pointer at which we should stop iterating
    dup dup.7 add
    # => [end_asset_ptr, asset_ptr, ASSET, note_ptr, num_of_assets]

    # pad the stack and move the pointer to the top
    padw movup.5
    # => [asset_ptr, 0, 0, 0, 0, end_asset_ptr, ASSET, note_ptr, num_of_assets]

    # compute the loop latch ToDo: check if we can use push.1 instead
    dup dup.6 neq
    # => [latch, asset_ptr, 0, 0, 0, 0, end_asset_ptr, asset_ptr, ASSET, note_ptr, num_of_assets]

    while.true
        dup movdn.6
        # => [asset_ptr, 0, 0, 0, 0, end_asset_ptr, asset_ptr, ASSET, note_ptr, num_of_assets]
        # load the asset and compare
        mem_loadw push.0 movdn.4 push.0 movdn.4 dupw.2
        # => [ASSET, ASSET', 0, 0, end_asset_ptr, asset_ptr, ASSET, note_ptr, num_of_assets]

        # compare the ASSETs
        eqw assertz.err=ERR_NON_FUNGIBLE_ASSET_ALREADY_EXISTS
        # => [ASSET, ASSET', 0, 0, end_asset_ptr, asset_ptr, ASSET, note_ptr, num_of_assets]

        # drop ASSETs and increment the asset pointer
        dropw dropw push.0.0 movup.5 add.1
        # => [asset_ptr, 0, 0, 0, 0, end_asset_ptr, ASSET, note_ptr, num_of_assets]

        # check if we reached the end of the loop
        dup dup.6 neq
    end
    # => [asset_ptr, 0, 0, 0, 0, end_asset_ptr, ASSET, note_ptr, num_of_assets]

    # prepare stack for storing the ASSET
    drop dropw
    # => [end_asset_ptr, ASSET, note_ptr, num_of_assets]

    # end of the loop reached, no error so we can store the non-fungible asset
    mem_storew dropw
    # => [note_ptr, num_of_assets]

    # increase the number of assets in the note
    swap add.1 dup.1 exec.memory::set_created_note_num_assets
    # => [note_ptr]
end

#! Inputs: [ASSET, note_ptr, num_of_assets]
#! Outputs: [note_ptr]
proc.add_fungible_asset_to_note
    dup.4 exec.memory::get_created_note_asset_data_ptr
    # => [asset_ptr, ASSET, note_ptr, num_of_assets]

    # compute the pointer at which we should stop iterating
    dup dup.7 add
    # => [end_asset_ptr, asset_ptr, ASSET, note_ptr, num_of_assets]

    # pad the stack and move the pointer to the top
    padw movup.5
    # => [asset_ptr, 0, 0, 0, 0, end_asset_ptr, ASSET, note_ptr, num_of_assets]

    # compute the loop latch ToDo: check if we can use push.1 instead
    dup dup.6 neq
    # => [latch, asset_ptr, 0, 0, 0, 0, end_asset_ptr, asset_ptr, ASSET, note_ptr, num_of_assets]

    while.true
        dup movdn.6
        # => [asset_ptr, 0, 0, 0, 0, end_asset_ptr, asset_ptr, ASSET, note_ptr, num_of_assets]

        # load the asset and compare
        mem_loadw push.0 movdn.4 push.0 movdn.4 dupw.2
        # => [ASSET, ASSET', 0, 0, end_asset_ptr, asset_ptr, ASSET, note_ptr, num_of_assets]

        # compare the faucet IDs
        dup dup.5 eq

        if.true
            # add the asset quantity
            drop drop drop dup.4 add
            # => [new_added_quantity, ASSET', 0, 0, end_asset_ptr, asset_ptr, ASSET, note_ptr, num_of_assets]

            # check that we don't overflow
            dup exec.asset::get_fungible_asset_max_amount lte assert.err=ERR_NOTE_FUNGIBLE_MAX_AMOUNT_EXCEEDED
            # => [new_added_quantity, ASSET', 0, 0, end_asset_ptr, asset_ptr, ASSET, note_ptr, num_of_assets]

            # prepare stack to store the "updated" ASSET'' with the new quantity
            # we don't care about the first 5 elements anymore, but we need the correct padding
            swap.4 drop swapw.2 drop drop
            # => [ASSET[0], ASSET[1], 0, 0, end_asset_ptr, asset_ptr, ASSET'', note_ptr, num_of_assets]

            # decrease num_of_assets by 1 to avoid incrementing it later
            movup.11 sub.1 movdn.11

            # end the loop
            push.0

        else
            # drop ASSETs and increment the asset pointer
            dropw dropw push.0.0 movup.5 add.1
            # => [asset_ptr + 1, 0, 0, 0, 0, end_asset_ptr, ASSET, note_ptr, num_of_assets]

            # check if we reached the end of the loop
            dup dup.6 neq
        end
    end
    # => [asset_ptr + 1, 0, 0, 0, 0, end_asset_ptr, ASSET, note_ptr, num_of_assets]

    # prepare stack for storing the ASSET
    drop dropw
    # => [asset_ptr, ASSET, note_ptr, num_of_assets]

    # end of the loop reached, no error so we can store the fungible asset
    mem_storew dropw
    # => [note_ptr, num_of_assets]

    # increase the number of assets in the note
    swap add.1 dup.1 exec.memory::set_created_note_num_assets
    # => [note_ptr]
end

#! Creates a new note and returns a pointer to the memory address at which the note is stored.
#!
#! Inputs: [ASSET, tag, note_type, RECIPIENT]
#! Outputs: [note_ptr, 0, 0, 0, 0, 0, 0, 0, 0]
#!
#! ASSET is the asset to be included in the note.
#! tag is the tag to be included in the note.
#! RECIPIENT is the recipient of the note.
#! ptr is the pointer to the memory address at which the note is stored.
export.create_note
    # validate the asset
    exec.asset::validate_asset
    # => [ASSET, tag, note_type, RECIPIENT]

    # validate the note type
    # NOTE: encrypted notes are currently unsupported `dup.6 push.ENCRYPTED_NOTE eq or`
    dup.5 push.OFFCHAIN_NOTE eq dup.6 push.PUBLIC_NOTE eq or assert.err=ERR_INVALID_NOTE_TYPE
    # => [ASSET, tag, note_type, RECIPIENT]

    # copy data to validate the tag
    dup.5 push.PUBLIC_NOTE dup.1 dup.7
    # => [tag, note_type, public_note, note_type, ASSET, tag, note_type, RECIPIENT]

    u32assert.err=ERR_NOTE_TAG_MUST_BE_U32
    # => [tag, note_type, public_note, note_type, ASSET, tag, note_type, RECIPIENT]

    # enforce the note type depending on the tag's bits
    u32shr.30 push.ALL_NOTE_TYPES_ALLOWED eq cdrop assert_eq.err=ERR_NOTE_INVALID_TYPE_FOR_TAG
    # => [ASSET, tag, note_type, RECIPIENT]

    # get the index for the next note to be created and increment counter
    exec.increment_num_created_notes
    # => [note_idx, ASSET, tag, note_type, RECIPIENT]

    # get a pointer to the memory address at which the note will be stored
    exec.memory::get_created_note_ptr
    # => [note_ptr, ASSET, tag, note_type, RECIPIENT]

    # populate the metadata
    movup.5 exec.account::get_id movup.7
    # => [note_type, sender_acct_id, tag, note_ptr, ASSET, RECIPIENT]

    push.0 # TODO: allow the user to push the aux data
    # => [aux, note_type, sender_acct_id, tag, note_ptr, ASSET, RECIPIENT]

    emit.NEW_NOTE_EVENT

    # set the metadata for the new created note
    dup.4 exec.memory::set_created_note_metadata
    # => [note_ptr, ASSET, RECIPIENT]

    # set the number of assets for the note to 1
    push.1 dup.1 exec.memory::set_created_note_num_assets
    # => [note_ptr, ASSET, RECIPIENT]

    movdn.4 padw swapw movup.8
    # => [note_ptr, ASSET, 0, 0, 0, 0, RECIPIENT]

    # add the asset to the note
    dup movdn.5 exec.memory::get_created_note_asset_data_ptr mem_storew dropw
    # => [note_ptr, 0, 0, 0, 0, RECIPIENT]

    movdn.8 swapw padw swapw movup.12
    # => [note_ptr, RECIPIENT, 0, 0, 0, 0, 0, 0, 0, 0]

    # set the recipient
    dup movdn.5 exec.memory::set_created_note_recipient
    # => [note_ptr, 0, 0, 0, 0, 0, 0, 0, 0]
end

#! Adds an ASSET to the specified note and returns a pointer to the memory address
#! at which the note is stored.
#!
#! Inputs: [note_ptr, ASSET]
#! Outputs: [note_ptr]
#!
#! ptr is the pointer to the memory address at which the note is stored.
#! ASSET can be a fungible or non-fungible asset.
export.move_asset_to_note
    # validate the ASSET
    movdn.4 exec.asset::validate_asset
    # => [ASSET, note_ptr]

    # emit the event
    emit.NEW_ASSET_TO_NOTE_EVENT
    # => [asset_ptr, ASSET, note_ptr, num_of_assets]

    # check if the note has at least one ASSET already
    dup.4 exec.memory::get_created_note_num_assets dup movdn.6 neq.0
    # => [num_of_assets>0?, ASSET, note_ptr, num_of_assets]

    if.true
        # The note already has at least one ASSET, so check if ASSET to add is fungible
        exec.asset::is_fungible_asset
        # => [is_fungible_asset?, ASSET, note_ptr, num_of_assets]

        if.true
        # ASSET to add is fungible
            exec.add_fungible_asset_to_note
            # => [note_ptr]
        else
        # ASSET to add is non-fungible
            exec.add_non_fungible_asset_to_note
            # => [note_ptr]
        end
        # => [note_ptr]
    else
        # There is no asset in the note yet, so we add the asset at the first position
        dup.4 exec.memory::get_created_note_asset_data_ptr
        # => [asset_ptr, ASSET, note_ptr, num_of_assets]

        # store the asset
        mem_storew dropw
        # => [note_ptr, num_of_assets]

        # increment the number of assets in the note
        swap add.1 swap dup movdn.2 exec.memory::set_created_note_num_assets
        # => [note_ptr]
    end
    # => [note_ptr]
end