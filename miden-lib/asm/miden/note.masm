use.miden::kernels::tx::constants
use.std::crypto::hashes::native
use.std::mem

#Â ERRORS
# =================================================================================================

# Provided note data does not match the commitment
const.ERR_NOTE_DATA_MISMATCH=0x00020040

# Number of note inputs exceeded the maximum limit of 128
const.ERR_NOTE_TOO_MANY_INPUTS=0x0002001B

#! Writes the data currently on the advice stack into the memory at the specified location and
#! verifies that the hash of the written data is equal to the provided hash.
#!
#! Inputs:  [start_ptr, end_ptr, HASH]
#! Outputs: []
proc.write_advice_data_to_memory
    # prepare the stack for reading from the advice stack
    padw padw padw
    # => [PAD, PAD, PAD, start_ptr, end_ptr, HASH]

    # read the data from advice stack to memory
    exec.mem::pipe_double_words_to_memory
    # => [PERM, PERM, PERM, end_ptr, HASH]

    # extract the digest
    exec.native::state_to_digest
    # => [DIGEST, end_ptr, HASH]

    # drop pointer for reading from memory
    movup.4 drop
    # => [DIGEST, HASH]

    # assert the computed hash is equal to the expected hash
    assert_eqw.err=ERR_NOTE_DATA_MISMATCH
    # => []
end

#! Writes the assets of the currently executing note into memory starting at the specified address.
#!
#! Inputs: [dest_ptr]
#! Outputs: [num_assets, dest_ptr]
#!
#! - dest_ptr is the memory address to write the assets.
#! - num_assets is the number of assets in the currently executing note.
export.get_assets
    padw push.0
    # => [0, 0, 0, 0, 0, dest_ptr]

    # get the current consumed note vault hash
    syscall.get_note_vault_info
    # => [VAULT_HASH, num_assets, dest_ptr]

    # load the vault data from the advice map to the advice stack
    adv.push_mapval
    # => [VAULT_HASH, num_assets, dest_ptr]

    # calculate number of assets rounded up to an even number
    dup.4 dup is_odd add
    # => [even_num_assets, VAULT_HASH, num_assets, dest_ptr]

    # calculate the start and end pointer for reading to memory
    dup.6 add dup.6
    # => [start_ptr, end_ptr, VAULT_HASH, num_assets, dest_ptr]

    # write the data from the advice stack into memory
    exec.write_advice_data_to_memory
    # => [num_assets, dest_ptr]
end

#! Loads the note's inputs to `dest_ptr`.
#!
#! Inputs:
#!   Stack: [dest_ptr]
#!   Advice Map: { INPUTS_HASH: [inputs_len, INPUTS] }
#! Outputs:
#!   Stack: [num_inputs, dest_ptr]
#!
#! Where:
#! - dest_ptr is the memory address to write the inputs.
#! - INPUTS_HASH, sequential hash of the padded note's inputs.
#! - inputs_len, the note's input count.
#! - INPUTS, the data corresponding to the note's inputs.
export.get_inputs
    padw syscall.get_note_inputs_hash
    # => [INPUTS_HASH, dest_ptr]

    # load the inputs from the advice map to the advice stack
    adv.push_mapval
    # => [INPUTS_HASH, dest_ptr]

    adv_push.1
    # => [num_inputs, INPUTS_HASH, dest_ptr]

    # validate the input length
    dup exec.constants::get_max_inputs_per_note lte assert.err=ERR_NOTE_TOO_MANY_INPUTS
    # => [num_inputs, INPUTS_HASH, dest_ptr]

    # calculate the number of words required to store the inputs
    dup movdn.5 u32divmod.4 neq.0 add
    # => [num_words, INPUTS_HASH, num_inputs, dest_ptr]

    # round up the number of words the next multiple of 2
    dup is_odd add
    # => [even_num_words, INPUTS_HASH, num_inputs, dest_ptr]

    # calculate the start and end pointer for reading to memory
    dup.6 add dup.6
    # => [start_ptr, end_ptr, INPUTS_HASH, num_inputs, dest_ptr]

    # check the input data matches the commitment, and write it to memory.
    exec.write_advice_data_to_memory
    # => [num_inputs, dest_ptr]
end

#! Returns the sender of the note currently being processed. Panics if a note is not being
#! processed.
#!
#! Inputs: []
#! Outputs: [sender]
#!
#! - sender is the sender of the note currently being processed.
export.get_sender
    push.0
    # => [0]

    syscall.get_note_sender
    # => [sender]
end

#! Returns the serial number of the note currently being processed.
#! Panics if no note is not being processed.
#!
#! Inputs: []
#! Outputs: [SERIAL_NUMBER]
#!
#! - SERIAL_NUMBER is the serial number of the note currently being processed.
export.get_serial_number
    padw
    # => [0, 0, 0, 0]

    syscall.get_note_serial_number
    # => [SERIAL_NUMBER]
end

#! Computes hash of note inputs starting at the specified memory address.
#!
#! Inputs:  [inputs_ptr, num_inputs]
#! Outputs: [HASH]
#!
#! Panics if num_inputs is greater than 128.
export.compute_inputs_hash
    swap
    # => [num_inputs, inputs_ptr]

    # check that number of inputs is less than 128
    dup push.128 u32lte assert
    # => [num_inputs, inputs_ptr]

    # get the number of word pairs to be hashed
    u32divmod.8 swap
    # => [num_inputs/8, num_inputs%8, inputs_ptr]

    # get the end_addr for hash_memory_even proc
    u32wrapping_mul.2 dup.2 u32wrapping_add movup.2
    # => [inputs_ptr, end_addr, num_inputs%8]

    # get the padding flag to add it to the capacity part
    dup.2 push.0 neq 
    # => [pad_flag, inputs_ptr, end_addr, num_inputs%8]
    
    # prepare hasher state for RPO permutation 
    push.0.0.0 padw padw 
    # => [C, B, A, inputs_ptr, end_addr, num_inputs%8]

    exec.native::hash_memory_even
    # => [C', B', A', inputs_ptr', end_addr, num_inputs%8] where inputs_ptr' = end_addr

    # if num_inputs%8 is not ZERO
    dup.14 push.0 neq
    if.true
        mem_stream
        # => [E, D, A', inputs_ptr'+2, end_addr, num_inputs%8]

        # clean the stack
        movup.12 drop movup.12 drop
        # => [E, D, A', num_inputs%8]

        # get the number of elements we need to drop
        push.8 movup.13 u32wrapping_sub movdn.12
        # => [E, D, A', drop_counter]

        # get the number of zeros we will need to dap
        dup.12 u32wrapping_sub.1 movdn.13
        # => [E, D, A', drop_counter, zero_counter]

        # check the drop_counter
        dup.12 neq.0
        while.true
            # decrease the counter
            movup.12 u32wrapping_sub.1 movdn.12

            # drop the top element, push 0 to the stack and move it down to maintain the overall number
            # of elements on stack to be able to access the drop_counter at position 12
            drop push.0 movdn.11

            # check the drop_counter
            dup.12 neq.0
        end
        # => [a, ..., x, A', 0, ..., 0, 0, zero_counter]
        #                               ^-- 12th position

        # push the dividing 1 (move the previously added zero and incr it)
        movup.12 add.1
        # => [1, a, ..., x, A', 0, ..., 0, 0, zero_counter]
        #                                  ^-- 12th position

        # check the zero_counter
        dup.13 neq.0
        while.true
            # decrease the counter
            movup.13 u32wrapping_sub.1 movdn.13

            # move the previously added zero
            movup.12

            # check the zero_counter
            dup.13 neq.0
        end
        # => [C, B, A', 0, 0, ... ]
        
        hperm
        # => [F, E, D]

        exec.native::state_to_digest
        # => [E]
    else
        dropw movdnw.2 dropw dropw
        # => [B']
    end
end
