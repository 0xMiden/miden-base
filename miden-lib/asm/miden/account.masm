use.miden::kernel_proc_offsets

# NATIVE ACCOUNT PROCEDURES
# =================================================================================================

#! Returns the account id.
#!
#! Inputs:  []
#! Outputs: [acct_id_hi, acct_id_lo]
#!
#! Where:
#! - acct_id is the account id.
#!
#! Invocation: exec
export.get_id
    # start padding the stack
    push.0.0.0

    exec.kernel_proc_offsets::get_account_id_offset
    # => [offset, 0, 0, 0]

    # pad the stack
    padw swapw padw padw swapdw
    # => [offset, pad(15)]

    syscall.exec_kernel_proc
    # => [acct_id_hi, acct_id_lo, pad(14)]

    # clean the stack
    swapdw dropw dropw swapw dropw movdn.3 movdn.3 drop drop
    # => [acct_id_hi, acct_id_lo]
end

#! Returns the account nonce.
#!
#! Inputs:  []
#! Outputs: [nonce]
#!
#! Where:
#! - nonce is the account nonce.
#!
#! Invocation: exec
export.get_nonce
    # start padding the stack
    push.0.0.0

    exec.kernel_proc_offsets::get_account_nonce_offset
    # => [offset, 0, 0, 0]

    # pad the stack
    padw swapw padw padw swapdw
    # => [offset, pad(15)]

    syscall.exec_kernel_proc
    # => [nonce, pad(15)]
    
    # clean the stack
    swapdw dropw dropw swapw dropw movdn.3 drop drop drop
    # => [nonce]
end

#! Returns the initial account hash.
#!
#! Inputs:  []
#! Outputs: [INIT_HASH]
#!
#! Where:
#! - INIT_HASH is the initial account hash.
#!
#! Invocation: exec
export.get_initial_hash
    # pad the stack
    padw padw padw push.0.0.0
    # => [pad(15)]

    exec.kernel_proc_offsets::get_initial_account_hash_offset
    # => [offset, pad(15)]

    syscall.exec_kernel_proc
    # => [INIT_HASH, pad(12)]

    # clean the stack
    swapdw dropw dropw swapw dropw
    # => [INIT_HASH]
end

#! Computes and returns the account hash from account data stored in memory.
#!
#! Inputs:  []
#! Outputs: [ACCT_HASH]
#!
#! Where:
#! - ACCT_HASH is the hash of the account data.
#!
#! Invocation: exec
export.get_current_hash
    # pad the stack
    padw padw padw push.0.0.0
    # => [pad(15)]

    exec.kernel_proc_offsets::get_current_account_hash_offset
    # => [offset, pad(15)]

    syscall.exec_kernel_proc
    # => [ACCT_HASH, pad(12)]

    # clean the stack
    swapdw dropw dropw swapw dropw
    # => [ACCT_HASH]
end

#! Increments the account nonce by the provided value.
#!
#! Inputs:  [value]
#! Outputs: []
#!
#! Where:
#! - value is the value to increment the nonce by. value can be at most 2^32 - 1 otherwise this
#!   procedure panics.
#!
#! Invocation: exec
export.incr_nonce
    # start padding the stack
    push.0.0 movup.2
    # => [value, 0, 0]

    exec.kernel_proc_offsets::incr_account_nonce_offset
    # => [offset, value, 0, 0]

    # pad the stack
    padw swapw padw padw swapdw
    # => [offset, value, pad(14)]

    syscall.exec_kernel_proc
    # => [pad(16)]

    dropw dropw dropw dropw
end

#! Gets an item from the account storage. Panics if the index is out of bounds.
#!
#! Inputs:  [index]
#! Outputs: [VALUE]
#!
#! Where:
#! - index is the index of the item to get.
#! - VALUE is the value of the item.
#!
#! Panics if:
#! - the index of the requested item is out of bounds.
#!
#! Invocation: exec
export.get_item
    push.0.0 movup.2
    # => [index, 0, 0]

    exec.kernel_proc_offsets::get_account_item_offset
    # => [offset, index, 0, 0]

    # pad the stack
    padw swapw padw padw swapdw
    # => [offset, index, pad(14)]

    syscall.exec_kernel_proc
    # => [VALUE, pad(12)]

    # clean the stack
    swapdw dropw dropw swapw dropw
    # => [VALUE]
end

#! Sets an item in the account storage. Panics if the index is out of bounds.
#!
#! Inputs:  [index, V']
#! Outputs: [R', V]
#!
#! Where:
#! - index is the index of the item to set.
#! - V' is the value to set.
#! - V is the previous value of the item.
#! - R' is the new storage commitment.
#!
#! Panics if: 
#! - the index of the item is out of bounds.
#!
#! Invocation: exec
export.set_item
    exec.kernel_proc_offsets::set_account_item_offset
    # => [offset, index, V']

    # pad the stack
    push.0.0 movdn.7 movdn.7 padw padw swapdw 
    # => [offset, index, V', pad(10)]

    syscall.exec_kernel_proc
    # => [R', V, pad(8)]

    # clean the stack
    swapdw dropw dropw
    # => [R', V]
end

#! Gets a map item from the account storage. 
#!
#! Inputs:  [index, KEY]
#! Outputs: [VALUE]
#!
#! Where:
#! - index is the index of the map where the KEY VALUE should be read.
#! - KEY is the key of the item to get.
#! - VALUE is the value of the item.
#!
#! Panics if:
#! - the index for the map is out of bounds, meaning > 255.
#! - the slot item at index is not a map.
#!
#! Invocation: exec
export.get_map_item
    exec.kernel_proc_offsets::get_account_map_item_offset
    # => [offset, index, KEY]

    # pad the stack
    push.0.0 movdn.7 movdn.7 padw padw swapdw 
    # => [offset, index, KEY, pad(10)]

    syscall.exec_kernel_proc
    # => [VALUE, pad(12)]

    # clean the stack
    swapdw dropw dropw swapw dropw
    # => [VALUE]
end

#! Sets a map item in the account storage. 
#!
#! Inputs:  [index, KEY, VALUE]
#! Outputs: [OLD_MAP_ROOT, OLD_MAP_VALUE]
#!
#! Where:
#! - index is the index of the map where the KEY VALUE should be set.
#! - KEY is the key to set at VALUE.
#! - VALUE is the value to set at KEY.
#! - OLD_MAP_ROOT is the old map root.
#! - OLD_MAP_VALUE is the old value at KEY.
#!
#! Panics if:
#! - the index for the map is out of bounds, meaning > 255.
#! - the slot item at index is not a map.
#!
#! Invocation: exec
export.set_map_item
    exec.kernel_proc_offsets::set_account_map_item_offset
    # => [offset, index, KEY, VALUE]

    # pad the stack
    push.0.0 movdn.11 movdn.11 padw movdnw.3
    # => [offset, index, KEY, VALUE, pad(6)]

    syscall.exec_kernel_proc
    # => [OLD_MAP_ROOT, OLD_MAP_VALUE, pad(8)]

    # clean the stack
    swapdw dropw dropw
    # => [OLD_MAP_ROOT, OLD_MAP_VALUE]
end

#! Sets the code of the account the transaction is being executed against.
#!
#! Inputs:  [CODE_COMMITMENT]
#! Outputs: []
#!
#! Where:
#! - CODE_COMMITMENT is the hash of the code to set.
#!
#! Panics if:
#! - this procedure is executed on an account whose type differs from `regular mutable`.
#!
#! Invocation: exec
export.set_code
    exec.kernel_proc_offsets::set_account_code_offset
    # => [offset, CODE_COMMITMENT]

    # pad the stack
    push.0.0.0 movdn.7 movdn.7 movdn.7 padw padw swapdw
    # => [offset, CODE_COMMITMENT, pad(11)]

    syscall.exec_kernel_proc
    # => [pad(16)]

    # clean the stack
    dropw dropw dropw dropw 
    # => []
end

#! Returns the balance of a fungible asset associated with a faucet_id.
#!
#! Inputs:  [faucet_id_hi, faucet_id_lo]
#! Outputs: [balance]
#!
#! Where:
#! - faucet_id is the faucet id of the fungible asset of interest.
#! - balance is the vault balance of the fungible asset.
#! 
#! Panics if:
#! - the asset is not a fungible asset.
#!
#! Invocation: exec
export.get_balance
    exec.kernel_proc_offsets::account_vault_get_balance_offset
    # => [offset, faucet_id_hi, faucet_id_lo]

    # pad the stack
    push.0 movdn.3 padw swapw padw padw swapdw
    # => [offset, faucet_id_hi, faucet_id_lo, pad(13)]

    syscall.exec_kernel_proc
    # => [balance, pad(15)]

    # clean the stack
    swapdw dropw dropw swapw dropw movdn.3 drop drop drop
    # => [balance]
end

#! Returns a boolean indicating whether the non-fungible asset is present in the vault.
#!
#! Inputs:  [ASSET]
#! Outputs: [has_asset]
#!
#! Where:
#! - ASSET is the non-fungible asset of interest
#! - has_asset is a boolean indicating whether the account vault has the asset of interest
#!
#! Panics if:
#! - the ASSET is a fungible asset.
#!
#! Invocation: exec
export.has_non_fungible_asset
    exec.kernel_proc_offsets::account_vault_has_non_fungible_asset_offset
    # => [offset, ASSET]

    # pad the stack
    push.0.0.0 movdn.7 movdn.7 movdn.7 padw padw swapdw 
    # => [offset, ASSET, pad(11)]

    syscall.exec_kernel_proc
    # => [has_asset, pad(15)]

    # clean the stack
    swapdw dropw dropw swapw dropw movdn.3 drop drop drop
    # => [has_asset]
end

#! Add the specified asset to the vault.
#!
#! Inputs:  [ASSET]
#! Outputs: [ASSET']
#!
#! Where:
#! - ASSET' is a final asset in the account vault defined as follows:
#!   - If ASSET is a non-fungible asset, then ASSET' is the same as ASSET.
#!   - If ASSET is a fungible asset, then ASSET' is the total fungible asset in the account vault
#!     after ASSET was added to it.
#!
#! Panics if:
#! - the asset is not valid.
#! - the total value of two fungible assets is greater than or equal to 2^63.
#! - the vault already contains the same non-fungible asset.
#!
#! Invocation: exec
export.add_asset
    exec.kernel_proc_offsets::account_vault_add_asset_offset
    # => [offset, ASSET]

    # pad the stack
    push.0.0.0 movdn.7 movdn.7 movdn.7 padw padw swapdw
    # => [offset, ASSET, pad(11)]

    syscall.exec_kernel_proc
    # => [ASSET', pad(12)]

    # clean the stack
    swapdw dropw dropw swapw dropw
    # => [ASSET']
end

#! Remove the specified asset from the vault.
#!
#! Inputs:  [ASSET]
#! Outputs: [ASSET]
#!
#! Where:
#! - ASSET is the asset to remove from the vault.
#!
#! Panics if:
#! - the fungible asset is not found in the vault.
#! - the amount of the fungible asset in the vault is less than the amount to be removed.
#! - the non-fungible asset is not found in the vault.
#!
#! Invocation: exec
export.remove_asset
    exec.kernel_proc_offsets::account_vault_remove_asset_offset
    # => [offset, ASSET]

    # pad the stack
    push.0.0.0 movdn.7 movdn.7 movdn.7 padw padw swapdw
    # => [offset, ASSET, pad(11)]

    syscall.exec_kernel_proc
    # => [ASSET, pad(12)]

    # clean the stack
    swapdw dropw dropw swapw dropw
    # => [ASSET]
end

#! Returns a commitment to the account vault.
#!
#! Inputs:  []
#! Outputs: [COM]
#!
#! Where:
#! - COM is a commitment to the account vault.
#!
#! Invocation: exec
export.get_vault_commitment
    # pad the stack for syscall invocation
    padw padw padw push.0.0.0
    # => [pad(15)]

    exec.kernel_proc_offsets::get_account_vault_commitment_offset
    # => [offset, pad(15)]

    syscall.exec_kernel_proc
    # => [COM, pad(12)]

    # clean the stack
    swapdw dropw dropw swapw dropw
    # => [COM]
end

# PROCEDURES COPIED FROM KERNEL (TODO: get rid of this duplication)
# =================================================================================================

# Given the least significant 32 bits of an account id's first felt, this mask defines the bits used
# to determine the account type.
const.ACCOUNT_ID_TYPE_MASK_U32=0x30 # 0b11_0000

# Bit pattern for a fungible faucet w/ immutable code, after the account type mask has been applied.
const.FUNGIBLE_FAUCET_ACCOUNT=0x20 # 0b10_0000

# Bit pattern for a non-fungible faucet w/ immutable code, after the account type mask has been
# applied.
const.NON_FUNGIBLE_FAUCET_ACCOUNT=0x30 # 0b11_0000

#! Returns the most significant half with the account type bits masked out.
#!
#! The account type can be defined by comparing this value with the following constants:
#!
#! - REGULAR_ACCOUNT_UPDATABLE_CODE
#! - REGULAR_ACCOUNT_IMMUTABLE_CODE
#! - FUNGIBLE_FAUCET_ACCOUNT
#! - NON_FUNGIBLE_FAUCET_ACCOUNT
#!
#! Stack: [acct_id_hi]
#! Output: [acct_type]
#!
#! - acct_id_hi is the first felt of the account id.
#! - acct_type is the account type.
proc.type
    u32split drop push.ACCOUNT_ID_TYPE_MASK_U32 u32and
    # => [acct_type]
end

#! Returns a boolean indicating whether the account is a fungible faucet.
#!
#! Stack: [acct_id]
#! Output: [is_fungible_faucet]
#!
#! - acct_id is the account id.
#! - is_fungible_faucet is a boolean indicating whether the account is a fungible faucet.
export.is_fungible_faucet
    exec.type push.FUNGIBLE_FAUCET_ACCOUNT eq
    # => [is_fungible_faucet]
end

#! Returns a boolean indicating whether the account is a non-fungible faucet.
#!
#! Stack: [acct_id]
#! Output: [is_non_fungible_faucet]
#!
#! - acct_id is the account id.
#! - is_non_fungible_faucet is a boolean indicating whether the account is a non-fungible faucet.
export.is_non_fungible_faucet
    exec.type push.NON_FUNGIBLE_FAUCET_ACCOUNT eq
    # => [is_non_fungible_faucet]
end

#! COPY; MOVE TO UTILS.
#!
#! Returns a boolean indicating whether the given account_ids are equal.
#!
#! Inputs:  [acct_id_hi, acct_id_lo, other_acct_id_hi, other_acct_id_lo]
#! Outputs: [is_id_equal]
#!
#! Where:
#! - acct_id is an account id.
#! - other_acct_id is the other account id to compare against.
#! - is_id_equal is a boolean indicating whether the account ids are equal.
export.is_id_eq
    movup.2 eq
    # => [is_hi_equal, acct_id_lo, other_acct_id_lo]
    swap movup.2 eq
    # => [is_lo_equal, is_hi_equal]
    and
    # => [is_id_equal]
end
