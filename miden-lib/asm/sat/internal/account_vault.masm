use.std::collections::smt

use.miden::sat::internal::account
use.miden::sat::internal::asset
use.miden::sat::internal::layout

#! Returns the balance of a fungible asset associated with a faucet_id.
#! Panics if the asset is not a fungible asset.
#!
#! Stack: [faucet_id]
#! Output: [balance]
#!
#! - faucet_id is the faucet id of the fungible asset of interest.
#! - balance is the vault balance of the fungible asset.
export.get_balance
    # assert that the faucet id is a fungible faucet
    dup exec.account::is_fungible_faucet assert
    # => [faucet_id]

    # get the asset vault root
    exec.layout::get_acct_vault_root
    # => [ASSET_VAULT_ROOT, faucet_id]

    # prepare the key for fungible asset lookup (pad least significant elements with ZERO)
    push.0 push.0 push.0 movup.7
    # => [faucet_id, PAD, PAD, PAD, ASSET_VAULT_ROOT]

    # lookup asset
    exec.smt::get swapw dropw
    # => [ASSET]

    # extract asset balance (ASSET[0])
    drop drop drop
    # => [balance]
end

#! Returns a boolean indicating whether the non-fungible asset is present in the vault.
#! Panics if the ASSET is a fungible asset.
#!
#! Stack: [ASSET]
#! Output: [has_asset]
#!
#! - ASSET is the non-fungible asset of interest
#! - has_asset is a boolean indicating whether the account vault has the asset of interest
export.has_non_fungible_asset
    # check if the asset is a non-fungible asset
    exec.asset::is_non_fungible_asset assert
    # => [ASSET]

    # prepare the stack to read non-fungible asset from vault
    exec.layout::get_acct_vault_root swapw
    # => [ASSET, ACCT_VAULT_ROOT]

    # lookup asset
    exec.smt::get swapw dropw
    # => [ASSET]

    # compare with EMTPY_WORD to asses if the asset exists in the vault
    padw eqw not
    # => [has_asset, PAD, ASSET]

    # organize the stack for return
    movdn.4 dropw movdn.4 dropw
    # => [has_asset]
end
