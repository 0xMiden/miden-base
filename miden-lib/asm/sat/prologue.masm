use.miden::sat::constants
use.miden::sat::layout

# PUBLIC INPUTS
# =================================================================================================

#! Processes the global inputs provided via the stack. This involves storing the global inputs at
#! the appropriate memory addresses.
#!
#! Stack: [BH, acct_id, IAH, NC]
#! Output: []
#!
#! - BH is the latest known block hash at the time of transaction execution.
#! - acct_id is the account id of the account that the transaction is being executed against.
#! - IAH is the initial account hash of the account that the transaction is being executed against.
#! - NC is the nullifier commitment of the transaction. This is a sequential hash of all
#!   (nullifier, script_root) pairs for the notes consumed in the transaction.
proc.process_global_inputs
    # store the block hash
    exec.layout::set_blk_hash

    # store the account id
    exec.layout::set_global_acct_id

    # store the initial account hash
    exec.layout::set_init_acct_hash

    # store the nullifier commitment
    exec.layout::set_nullifier_com
end

# ACCOUNT DATA
# =================================================================================================

#! Process the account data provided via the advice provider. This involves reading the data from
#! the advice provider and storing it at the appropriate memory addresses. As the account data is
#! read from the advice provider, the account hash is computed. It is asserted that the computed
#! account hash matches the account hash stored in the global inputs. It is also asserted that the
#! account id matches the account id provided via the stack public inputs.
#!
#! Stack: []
#! Advice stack: [acct_id, ZERO, ZERO, nonce, AVR, ASR, ACR]
#! Output: []
#!
#! - acct_id is the account id.
#! - nonce is the account nonce.
#! - AVR is the account vault root.
#! - ASR is the account storage root.
#! - ACR is the account code root.
proc.process_acct_data
    # address to store the account data
    exec.layout::get_acct_data_ptr

    # prepare the stack for reading account data
    padw padw padw

    # read the account data
    adv_pipe adv_pipe

    # extract digest from hasher rate elements (h_0, ..., h_3)
    dropw swapw dropw

    # assert that the account hash matches the hash in global inputs
    exec.layout::get_init_acct_hash assert_eqw

    # assert the account id matches the account id in global inputs
    exec.layout::get_global_acct_id
    exec.layout::get_acct_id
    assert_eq

    # clear the stack
    drop

    # store a copy of the initial nonce in global inputs
    exec.layout::get_acct_nonce
    exec.layout::set_init_nonce
end

# CONSUMED NOTES DATA
# =================================================================================================

#! Reads data for consumed note i from the advice provider and stores it in memory at the
#! appropriate memory address. This includes computing and storing the nullifier and the
#! note hash.
#!
#! Stack: [i]
#! Advice stack: [CN1_SN, CN1_SR, CN1_IR, CN1_VR,
#!               CN1_NA,
#!               CN1_A1, CN1_A2, ...]
#!
#! Output: []
#!
#! - i is the index of the consumed note.
#! - CN1_SN is the serial number of consumed note 1.
#! - CN1_SR is the script root of consumed note 1.
#! - CN1_IR is the inputs root of consumed note 1.
#! - CN1_VR is the vault root of consumed note 1.
#! - CN1_NA is the number of assets in consumed note 1.
#! - CN1_A1 is the first asset of consumed note 1.
#! - CN1_A2 is the second asset of consumed note 1.
proc.process_consumed_note
    # read core note data
    # ---------------------------------------------------------------------------------------------

    # compute address to store note hash
    exec.layout::get_consumed_note_ptr

    # compute address to store raw note data
    dup add.1

    # read note data from the advice provider
    padw padw padw
    adv_pipe adv_pipe

    # extract nullifier
    dropw swapw dropw

    # compute address for nullifier
    # dup.6 = counter / note index
    dup.6 exec.layout::get_consumed_note_nullifier_ptr

    # store nullifier in memory and drop from stack
    mem_storew dropw

    # ingest note assets
    # ---------------------------------------------------------------------------------------------

    # read the number of assets from the advice provider and store in memory
    adv_push.1 dup dup.2 mem_store

    # assert the number of assets is within limits
    dup exec.constants::get_max_assets_per_note lte assert

    # round up the number of assets to the next multiple of 2 (simplifies reading of assets)
    dup push.1 u32checked_and

    # pad to multiple of two if odd
    if.true
        add.1
    end

    # initiate counter for assets
    push.0

    # prepare address and stack for reading assets
    movup.2 add.1 padw padw padw

    # check if the number of assets is greater then 0
    dup.14 dup.14 neq

    # loop and read assets from the advice provider
    while.true
        # read assets from advice provider
        adv_pipe

        # check if we should loop again
        movup.13 push.2 add dup movdn.14 dup.15 neq
    end

    # extract digest from hasher rate elements (h_0, ..., h_3)
    dropw swapw dropw

    # load expected hash from memory
    swapw drop drop drop dup movdn.5 push.4 add padw movup.4 mem_loadw

    # assert that the computed hash matches the expected hash
    assert_eqw

    # compute note hash
    # ---------------------------------------------------------------------------------------------

    # TODO: This should be optimized using the `hperm` operation

    # serial number hash - serial_hash = hmerge(serial_number, 0)
    dup add.1 padw movup.4 mem_loadw padw hmerge

    # hash serial_hash with script hash - merge_script = hmerge(serial_hash, script_hash)
    dup.4 push.2 add padw movup.4 mem_loadw hmerge

    # hash merge_script with inputs hash - recipient = hmerge(merge_script, inputs_hash)
    dup.4 push.3 add padw movup.4 mem_loadw hmerge

    # hash recipient with vault hash - note_hash = hmerge(recipient, vault_hash)
    dup.4 push.4 add padw movup.4 mem_loadw hmerge

    # store note hash in memory and clear stack
    dup.4 mem_storew dropw drop

    # TODO: assert note hash exists in note db
end

#! Process the consumed notes data provided via the advice provider. This involves reading the data
#! from the advice provider and storing it at the appropriate memory addresses. As each note is
#! consumed its hash and nullifier is computed. The transaction nullifier commitment is computed
#! via a sequential hash of all (nullifier, script_root) pairs for all consumed notes.
#!
#! Stack: []
#! Advice stack: [num_cn,
#!               CN1_SN, CN1_SR, CN1_IR, CN1_VR,
#!               cn1_na,
#!               CN1_A1, CN1_A2, ...
#!
#!               CN2_SN,CN2_SR, CN2_IR, CN2_VR,
#!               cn2_na,
#!               CN2_A1, CN2_A2, ...
#!               ...]
#! Output: []
#!
#! - num_cn is the number of consumed notes.
#! - CN1_SN is the serial number of consumed note 1.
#! - CN1_SR is the script root of consumed note 1.
#! - CN1_IR is the inputs root of consumed note 1.
#! - CN1_VR is the vault root of consumed note 1.
#! - cn1_na is the number of assets in consumed note 1.
#! - CN1_A1 is the first asset of consumed note 1.
#! - CN1_A2 is the second asset of consumed note 1.
proc.process_consumed_notes_data
    # read the number of consumed notes from the advice provider
    adv_push.1

    # store the number of consumed notes
    dup exec.layout::set_total_num_consumed_notes

    # assert the number of consumed notes is within limits
    dup exec.constants::get_max_num_consumed_notes lte assert

    # loop over consumed notes and read data
    # ---------------------------------------------------------------------------------------------

    # initialize counter for consumed notes
    push.0

    # check if the number of consumed notes is greater then 0. Conditional for the while loop.
    dup.1 dup.1 neq

    # loop and read note data from the advice provider
    while.true
        dup exec.process_consumed_note

        # increment consumed note counter and check if we should loop again
        add.1 dup.1 dup.1 neq
    end

    # drop counter
    drop

    # compute nullifier commitment
    # ---------------------------------------------------------------------------------------------

    # initiate counter for nullifiers
    push.0

    # initiate stack for sequential hash to compute nullifier commitment
    padw padw padw

    # check if the number of consumed notes is greater then 0. Conditional for the while loop.
    dup.13 dup.13 neq

    # loop and sequentially hash hperm(nullifier, script_root) over all consumed notes
    while.true
        # clear hasher rate
        dropw dropw

        # get consumed note nullifier
        dup.4 exec.layout::get_consumed_note_nullifier

        # get consumed note script root
        dup.8 exec.layout::get_consumed_note_ptr exec.layout::get_consumed_note_script_root

        # compute hperm(nullifier, script_root)
        hperm

        # increment nullifier counter and check if we should loop again
        movup.12 add.1 dup movdn.13 dup.14 neq
    end

    # extract nullifier hash
    dropw swapw dropw

    # assert nullifier hash is what we would expect
    exec.layout::get_nullifier_com assert_eqw

    # clear stack
    drop drop
end

# TRANSACTION PROLOGUE
# =================================================================================================

#! The transaction prologue is executed at the beginning of a transaction. Its responsibility is:
#! 1. "Unhash" inputs, authenticate the data and store it in the root contexts memory.
#! 2. Build a single vault containing assets of all inputs (input notes combined with current
#!    account vault).
#! 3. Verify that all consumed notes are present in the note db.
#!
#! Errors:
#!  - If data provided by the advice provider does not match global inputs.
#!  - The account data is invalid.
#!  - Any of the consumed notes do note exist in the note db.
#!
#! Stack:        [BH, acct_id, IAH, NC]
#! Advice stack: [acct_id, ZERO, ZERO, nonce, AVR, ASR, ACR,
#!                num_cn,
#!                CN1_SN, CN1_SR, CN1_IR, CN1_VR,
#!                cn1_na,
#!                CN1_A1, CN1_A2, ...
#!                CN2_SN,CN2_SR, CN2_IR, CN2_VR,
#!                cn2_na,
#!                CN2_A1, CN2_A2, ...
#!                ...]
#! Output:       []
#!
#!
#! - BH is the latest known block hash at the time of transaction execution.
#! - acct_id is the account id of the account that the transaction is being executed against.
#! - IAH is the initial account hash of the account that the transaction is being executed against.
#! - NC is the nullifier commitment of the transaction. This is a sequential hash of all
#!   (nullifier, script_root) pairs for the notes consumed in the transaction.
#! - nonce is the account nonce.
#! - AVR is the account vault root.
#! - ASR is the account storage root.
#! - ACR is the account code root.
#! - num_cn is the number of consumed notes.
#! - CN1_SN is the serial number of consumed note 1.
#! - CN1_SR is the script root of consumed note 1.
#! - CN1_IR is the inputs root of consumed note 1.
#! - CN1_VR is the vault root of consumed note 1.
#! - cn1_na is the number of assets in consumed note 1.
#! - CN1_A1 is the first asset of consumed note 1.
#! - CN1_A2 is the second asset of consumed note 1.
export.prepare_transaction
    # process global inputs
    exec.process_global_inputs

    # process account data
    exec.process_acct_data

    # process consumed notes data
    exec.process_consumed_notes_data
end
