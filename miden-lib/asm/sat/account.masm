use.miden::sat::layout

# CONSTANTS
# =================================================================================================

# An enum that represents a regular account with updatable code.
const.REGULAR_ACCOUNT_UPDATABLE_CODE=0

# An enum that represents a regular account with immutable code.
const.REGULAR_ACCOUNT_IMMUTABLE_CODE=1

# An enum that represents a fungible faucet with immutable code.
const.FUNGIBLE_FAUCET_ACCOUNT=2

# An enum that represents a non-fungible faucet with immutable code.
const.NON_FUNGIBLE_FAUCET_ACCOUNT=3

# PROCEDURES
# =================================================================================================

#! Computes and returns the account hash from account data stored in memory.
#!
#! Stack: []
#! Output: [ACCT_HASH]
#!
#! - ACCT_HASH is the hash of the account data.
export.get_current_hash
    # prepare the stack for computing the account hash
    exec.layout::get_acct_data_ptr padw padw padw

    # stream account data and compute sequential hash. We perform two `mem_stream` operations
    # because account data consists of exactly 4 words.
    mem_stream mem_stream

    # extract account hash
    dropw swapw dropw

    # drop memory pointer
    movup.4 drop
end

#! Increments the account nonce by the provided value.
#!
#! Stack: [value]
#! Output: []
#!
#! - value is the value to increment the nonce by. value can be at most 2^32 - 1 otherwise this
#!   procedure panics.
export.incr_nonce
    u32assert.1
    exec.layout::get_acct_nonce add
    exec.layout::set_acct_nonce
end

# TODO: change to re-export once supported.
#! Returns the account id.
#!
#! Stack: []
#! Output: [acct_id]
#!
#! - acct_id is the account id.
export.get_id
    exec.layout::get_acct_id
end

# TODO: change to re-export once supported.
#! Returns the account nonce.
#!
#! Stack: []
#! Output: [nonce]
#!
#! - nonce is the account nonce.
export.get_nonce
    exec.layout::get_acct_nonce
end

# TODO: change to re-export once supported.
#! Returns the initial account hash.
#!
#! Stack: []
#! Output: [H]
#!
#! - H is the initial account hash.
export.get_initial_hash
    exec.layout::get_init_acct_hash
end

#! Returns the account type of the account id provided via the stack.
#!
#! The account type can be of the following forms:
#! - regular account with updatable code
#! - regular account with immutable code
#! - fungible asset faucet account with immutable code
#! - non-fungible asset faucet account with immutable code
#!
#! Stack: [acct_id]
#! Output: [acct_type]
#!
#! - acct_id is the account id.
#! - acct_type is the account type.
proc.type
    # compute the account type
    u32split swap drop u32checked_shr.30
    # => [acct_type]
end

#! Returns a boolean indicating whether the account is a fungible faucet.
#!
#! Stack: [acct_id]
#! Output: [is_fungible_faucet]
#!
#! - acct_id is the account id.
#! - is_fungible_faucet is a boolean indicating whether the account is a fungible faucet.
export.is_fungible_faucet
    # get the account type
    exec.type
    # => [acct_type]

    # check if the account type is a fungible faucet
    push.FUNGIBLE_FAUCET_ACCOUNT eq
    # => [is_fungible_faucet]
end

#! Returns a boolean indicating whether the account is a non-fungible faucet.
#!
#! Stack: [acct_id]
#! Output: [is_non_fungible_faucet]
#!
#! - acct_id is the account id.
#! - is_non_fungible_faucet is a boolean indicating whether the account is a non-fungible faucet.
export.is_non_fungible_faucet
    # get the account type
    exec.type
    # => [acct_type]

    # check if the account type is a non-fungible faucet
    push.NON_FUNGIBLE_FAUCET_ACCOUNT eq
    # => [is_non_fungible_faucet]
end

#! Returns a boolean indicating whether the account is a regular updatable account.
#!
#! Stack: [acct_id]
#! Output: [is_updatable_account]
#!
#! - acct_id is the account id.
#! - is_updatable_account is a boolean indicating whether the account is a regular updatable
#!   account.
export.is_updatable_account
    # get the account type
    exec.type
    # => [acct_type]

    # check if the account type is a regular account
    push.REGULAR_ACCOUNT_UPDATABLE_CODE eq
    # => [is_updatable_account]
end

#! Returns a boolean indicating whether the account is a regular immutable account.
#!
#! Stack: [acct_id]
#! Output: [is_immutable_account]
#!
#! - acct_id is the account id.
#! - is_immutable_account is a boolean indicating whether the account is a regular immutable
#!   account.
export.is_immutable_account
    # get the account type
    exec.type
    # => [acct_type]

    # check if the account type is a regular account
    push.REGULAR_ACCOUNT_IMMUTABLE_CODE eq
    # => [is_immutable_account]
end

#! Sets the code of the account the transaction is being executed against. This procedure can only
#! executed on regular accounts with updatable code. Otherwise, this procedure fails.
#!
#! Stack: [CODE_ROOT]
#! Output: []
#!
#! - CODE_ROOT is the hash of the code to set.
export.set_code
    # get the account id
    exec.layout::get_acct_id
    # => [acct_id, CODE_ROOT]

    # assert the account is an updatable regular account
    exec.is_updatable_account assert
    # => [CODE_ROOT]

    # set the code root
    exec.layout::set_new_acct_code_root
    # => []
end