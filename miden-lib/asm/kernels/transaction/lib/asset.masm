use.kernel::account

#Â ERRORS
# =================================================================================================

# Malformed fungible asset: ASSET[1] must be 0
const.ERR_FUNGIBLE_ASSET_FORMAT_ELEMENT_ONE_MUST_BE_ZERO=0x00020020

# Malformed fungible asset: ASSET[2] and ASSET[3] must be a valid fungible faucet id
const.ERR_FUNGIBLE_ASSET_FORMAT_ELEMENT_TWO_AND_THREE_MUST_BE_FUNGIBLE_FAUCET_ID=0x00020022

# Malformed fungible asset: ASSET[0] exceeds the maximum allowed amount
const.ERR_FUNGIBLE_ASSET_FORMAT_ELEMENT_ZERO_MUST_BE_WITHIN_LIMITS=0x00020023

# Malformed non-fungible asset: ASSET[3] is not a valid non-fungible faucet id
const.ERR_NON_FUNGIBLE_ASSET_FORMAT_ELEMENT_THREE_MUST_BE_FUNGIBLE_FAUCET_ID=0x00020024

# Malformed non-fungible asset: the most significant bit must be 0
const.ERR_NON_FUNGIBLE_ASSET_FORMAT_MOST_SIGNIFICANT_BIT_MUST_BE_ZERO=0x00020025

# The origin of the fungible asset is not this faucet
const.ERR_FUNGIBLE_ASSET_FAUCET_IS_NOT_ORIGIN=0x00020026

# The origin of the non-fungible asset is not this faucet
const.ERR_NON_FUNGIBLE_ASSET_FAUCET_IS_NOT_ORIGIN=0x00020027

# CONSTANTS
# =================================================================================================

const.FUNGIBLE_ASSET_MAX_AMOUNT=9223372036854775807

#! Returns the maximum amount of a fungible asset.
#!
#! Inputs:  []
#! Outputs: [fungible_asset_max_amount]
#!
#! Where:
#! - fungible_asset_max_amount is the maximum amount of a fungible asset.
export.get_fungible_asset_max_amount
    push.FUNGIBLE_ASSET_MAX_AMOUNT
    # => [fungible_asset_max_amount]
end

# PROCEDURES
# =================================================================================================

#! Validates that a fungible asset is well formed.
#!
#! Inputs:  [ASSET]
#! Outputs: [ASSET]
#!
#! Where:
#! - ASSET is the asset to validate.
#!
#! Panics if:
#! - the asset is not well formed.
export.validate_fungible_asset
    # assert that ASSET[1] == ZERO
    dup.2 not assert.err=ERR_FUNGIBLE_ASSET_FORMAT_ELEMENT_ONE_MUST_BE_ZERO
    # => [ASSET]

    # assert that the tuple (ASSET[3], ASSET[2]) forms a valid account ID
    dup.1 dup.1 exec.account::validate_id
    # => [ASSET]

    # assert that the first felt (ASSET[3]) of the account ID is of type fungible faucet
    dup exec.account::is_fungible_faucet
    assert.err=ERR_FUNGIBLE_ASSET_FORMAT_ELEMENT_TWO_AND_THREE_MUST_BE_FUNGIBLE_FAUCET_ID
    # => [ASSET]

    # assert that the max amount (ASSET[0]) of a fungible asset is not exceeded
    dup.3 push.FUNGIBLE_ASSET_MAX_AMOUNT lte 
    assert.err=ERR_FUNGIBLE_ASSET_FORMAT_ELEMENT_ZERO_MUST_BE_WITHIN_LIMITS
    # => [ASSET]
end

#! Returns a boolean indicating whether the asset is fungible.
#!
#! Inputs:  [ASSET]
#! Outputs: [is_fungible_asset, ASSET]
#!
#! Where:
#! - ASSET is the asset to check.
#! - is_fungible_asset is a boolean indicating whether the asset is fungible.
export.is_fungible_asset
    # check the first element, it will be:
    # - zero for a fungible asset
    # - non zero for a non-fungible asset
    dup.2 eq.0
    # => [is_fungible_asset, ASSET]
end

#! Validates that a non fungible asset is well formed.
#!
#! Inputs:  [ASSET]
#! Outputs: [ASSET]
#!
#! Where:
#! - ASSET is the asset to validate.
#!
#! Panics if:
#! - the asset is not well formed.
export.validate_non_fungible_asset
    # assert that ASSET[3] is a valid account ID prefix
    # hack: because we only have the first felt we add a 0 as the second felt which is always valid
    push.0 dup.1 exec.account::validate_id
    # => [ASSET]

    # assert that the account ID prefix ASSET[3] is of type non fungible faucet
    dup exec.account::is_non_fungible_faucet
    assert.err=ERR_NON_FUNGIBLE_ASSET_FORMAT_ELEMENT_THREE_MUST_BE_FUNGIBLE_FAUCET_ID
    # => [ASSET]
end

#! Returns a boolean indicating whether the asset is non-fungible.
#!
#! Inputs:  [ASSET]
#! Outputs: [is_non_fungible_asset, ASSET]
#!
#! Where:
#! - ASSET is the asset to check.
#! - is_non_fungible_asset is a boolean indicating whether the asset is non-fungible.
export.is_non_fungible_asset
    # check the first element, it will be:
    # - zero for a fungible asset
    # - non zero for a non-fungible asset
    exec.is_fungible_asset not
    # => [is_non_fungible_asset, ASSET]
end

#! Validates that an asset is well formed.
#!
#! Inputs:  [ASSET]
#! Outputs: [ASSET]
#!
#! Where:
#! - ASSET is the asset to validate.
#!
#! Panics if:
#! - the asset is not well formed.
export.validate_asset
    # check if the asset is fungible
    exec.is_fungible_asset
    # => [is_fungible_asset, ASSET]

    # if the asset is fungible, validate the fungible asset
    if.true
        exec.validate_fungible_asset
    else
    # if the asset is non fungible, validate the non fungible asset
        exec.validate_non_fungible_asset
    end
    # => [ASSET]
end

#! Validates that a fungible asset is associated with the provided faucet_id.
#!
#! Inputs:  [faucet_id_hi, faucet_id_lo, ASSET]
#! Outputs: [ASSET]
#!
#! Where:
#! - faucet_id_hi is the first felt of the faucet's account ID.
#! - ASSET is the asset to validate.
export.validate_fungible_asset_origin
    # assert the origin of the asset is the faucet_id provided via the stack
    dup.3 dup.3
    # => [asset_id_hi, asset_id_lo, faucet_id_hi, faucet_id_lo, ASSET]

    exec.account::is_id_eq assert.err=ERR_FUNGIBLE_ASSET_FAUCET_IS_NOT_ORIGIN
    # => [ASSET]

    # assert the fungible asset is valid
    exec.validate_fungible_asset
    # => [ASSET]
end

#! Validates that a non-fungible asset is associated with the provided faucet_id.
#!
#! Inputs:  [faucet_id_hi, ASSET]
#! Outputs: [ASSET]
#!
#! Where:
#! - faucet_id_hi is the first felt of the faucet's account ID.
#! - ASSET is the asset to validate.
export.validate_non_fungible_asset_origin
    # assert the origin of the asset is the faucet_id prefix provided via the stack
    dup.1 assert_eq.err=ERR_NON_FUNGIBLE_ASSET_FAUCET_IS_NOT_ORIGIN
    # => [ASSET]

    # assert the non-fungible asset is valid
    exec.validate_non_fungible_asset
    # => [ASSET]
end
