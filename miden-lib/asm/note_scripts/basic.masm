use.miden::sat::account
use.miden::sat::note
use.miden::sat::tx
use.miden::wallets::basic->wallet

#! Helper procedure to add all assets of a note to an account.
#!
#! Inputs: []
#! Outputs: []
#!
proc.add_note_assets_to_account
    push.0 exec.note::get_assets                               
    # => [num_of_assets, 0 = ptr, ...]

    # compute the pointer at which we should stop iterating
    dup.1 add
    # => [end_ptr, ptr, ...]

    # pad the stack and move the pointer to the top
    padw movup.5
    # => [ptr, 0, 0, 0, 0, end_ptr, ...]

    # compute the loop latch
    dup dup.6 neq
    # => [latch, ptr, 0, 0, 0, 0, end_ptr, ...]

    while.true
        # => [ptr, 0, 0, 0, 0, end_ptr, ...]

        # save the pointer so that we can use it later
        dup movdn.5
        # => [ptr, 0, 0, 0, 0, ptr, end_ptr, ...]

        # load the asset and add it to the account
        mem_loadw call.wallet::receive_asset
        # => [ASSET, ptr, end_ptr, ...]

        # increment the pointer and compare it to the end_ptr
        movup.4 add.1 dup dup.6 neq
        # => [latch, ptr+1, ASSET, end_ptr, ...]
    end

    # clear the stack
    drop dropw drop
end


#! Pay-to-ID script: adds all assets from the note to the account, assuming
#! ID of the account matches target account ID specified by note inputs.
#! 
#! Requires that the account exposes: miden::wallets::basic::receive_asset procedure.
#!
#! Stack Inputs: []
#! Outputs: []
#!
#! FAILS if: 
#! - Account does not expose miden::wallets::basic::receive_asset procedure.
#! - Account ID of executing account is not equal to specified Account ID.
#! - The same non-fungible asset already exists in the account.
#! - Adding a fungible asset would result in amount overflow, i.e.,
#!   the total amount would be greater than 2^63.
export.p2id                                             
    # load the note inputs to memory starting at address 0
    push.0 exec.note::get_inputs
    # => [inputs_ptr]

    # read the target account id from the note inputs
    mem_load
    # => [target_account_id]
    
    exec.account::get_id                                
    # => [account_id, target_account_id, ...]
    
    # ensure account_id = target_account_id, fails otherwise
    assert_eq                                           
    # => [...]
    
    exec.add_note_assets_to_account
    # => [...]
end

#! Pay to ID reclaimable: ensures that note can be consumed only by an account with the provided ID
#! or after provided block number also by the sender account
#! 
#! Note Inputs: [reclaim_block_height, target_account_id, ...]
#! Stack Inputs: []
#! Outputs: []
#!
#! - reclaim_block_height is the block height at which the note can be reclaimed by the sender
#! - target_account_id is the account ID to which the assets should be added
#! - ASSET is the asset to be received, can be fungible or non-fungible
#!
#! FAILS if: 
#! - Account does not expose miden::wallets::basic::receive_asset procedure.
#! - Before reclaim block height: Account ID of executing account is not equal to specified Account ID. 
#! - At and after reclaim block height: Account ID of executing account is not equal to specified Account ID or Sender Account ID.
#! - The same non-fungible asset already exists in the account.
#! - Adding a fungible asset would result in amount overflow, i.e.,
#!   the total amount would be greater than 2^63.
export.p2idr
    # load the note inputs to memory starting at address 0
    push.0 exec.note::get_inputs
    # => [inputs_ptr]

    # read the reclaim block height and target account id from the note inputs
    padw movup.4 mem_loadw movup.2 drop movup.2 drop
    # => [reclaim_block_height, target_account_id]

    exec.account::get_id dup
    # => [account_id, account_id, reclaim_block_height, target_account_id, ...]

    # determine if the current account is the target account
    movup.3 eq
    # => [is_target, account_id, reclaim_block_height, ...]

    if.true
        # if current account is the target, we don't need to check anything else
        # and so we just clear the stack
        drop drop

    else
        # if current account is not the target, we need to ensure it is the sender
        exec.note::get_sender
        # => [sender_account_id, account_id, reclaim_block_height, ...]
    
        assert_eq
        # => [reclaim_block_height, ...]

        # now check that sender is allowed to reclaim, current block >= reclaim block height
        exec.tx::get_block_number                           
        # => [current_block_height, reclaim_block_height, ...]    
    
        u32checked_lte assert                                                 
    end 

    exec.add_note_assets_to_account
    # => [...]

end
