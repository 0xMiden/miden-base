# miden::standards::access::pausable
#
# Provides pausable functionality for account components.
# This module can be imported and used by any component that needs pause controls.
#
# Usage:
#   use miden::standards::access::pausable
#   
#   # In account procedures (not from note scripts):
#   exec.pausable::is_not_paused
#   exec.pausable::pause
#   exec.pausable::unpause
#
# IMPORTANT CONTEXT REQUIREMENTS:
# - is_not_paused, pause, and unpause MUST be called from Account context (i.e., from account procedures)
# - They CANNOT be called directly from note scripts using exec
# - Note scripts should call account procedures, which then call these pausable procedures
#
# NOTE: The pause and unpause procedures do NOT check ownership. The caller must ensure
# that only_owner is called before calling these procedures.

use miden::protocol::active_account
use miden::protocol::native_account

# CONSTANTS
# ================================================================================================

# The slot in this component's storage layout where the paused state is stored.
# This must match the slot name used in the Rust code.
const PAUSABLE_SLOT=word("miden::standards::access::pausable::paused")

# ERRORS
# ================================================================================================

const ERR_IS_PAUSED="contract is paused"

# INTERNAL PROCEDURES
# ================================================================================================

#! Checks if the component is not paused.
#!
#! Inputs:  []
#! Outputs: []
#!
#! Panics if:
#! - the component is paused (storage slot value is not zero).
#!
#! CONTEXT REQUIREMENT:
#! - MUST be called from Account context (from an account procedure)
#! - CANNOT be called directly from note scripts using exec
#! - Note scripts should call account procedures that internally call this procedure
#!
#! NOTE: Uses active_account::get_item which authenticates account origin via
#! authenticate_account_origin. This means it can only be called from account procedures,
#! not directly from note scripts. This is by design - pause checks should be integrated
#! into account procedures (e.g., distribute, burn) rather than called directly from notes.
pub proc is_not_paused
    push.PAUSABLE_SLOT[0..2] exec.active_account::get_item
    # => [paused_flag, 0, 0, 0]
    # Paused state is stored as [1, 0, 0, 0] when paused, [0, 0, 0, 0] when unpaused
    # get_item returns the Word with the first element at the top of the stack
    # Drop the last 3 elements to isolate the paused_flag
    drop drop drop
    # => [paused_flag]
    assertz.err=ERR_IS_PAUSED
    # => [] (if paused_flag was 0, otherwise it panics)
end

# PUBLIC INTERFACE
# ================================================================================================

#! Pauses the component, preventing certain operations.
#!
#! Can only be called by the owner (requires owner check before calling this).
#!
#! Inputs:  [pad(16)]
#! Outputs: [pad(16)]
#!
#! NOTE: This procedure does NOT check ownership. The caller must ensure
#! that only_owner is called before this procedure.
#!
#! Invocation: call
pub proc pause
    # Write [1, 0, 0, 0] to storage to indicate paused state
    # Using [1, 0, 0, 0] follows Miden convention where the flag is in the first position
    # This makes boolean isolation more efficient (flag is at top of stack after get_item)
    push.1.0.0.0
    # => [1, 0, 0, 0, pad(16)]

    push.PAUSABLE_SLOT[0..2]
    # => [slot_prefix, slot_suffix, 1, 0, 0, 0, pad(16)]

    exec.native_account::set_item
    # => [OLD_PAUSED_WORD, pad(16)]

    dropw
    # => [pad(16)]
end

#! Unpauses the component, allowing operations to resume.
#!
#! Can only be called by the owner (requires owner check before calling this).
#!
#! Inputs:  [pad(16)]
#! Outputs: [pad(16)]
#!
#! NOTE: This procedure does NOT check ownership. The caller must ensure
#! that only_owner is called before this procedure.
#!
#! Invocation: call
pub proc unpause
    # Write [0, 0, 0, 0] to storage to indicate unpaused state
    # Using [0, 0, 0, 0] for consistency with [1, 0, 0, 0] paused state
    push.0.0.0.0
    # => [0, 0, 0, 0, pad(16)]

    push.PAUSABLE_SLOT[0..2]
    # => [slot_prefix, slot_suffix, 0, 0, 0, 0, pad(16)]

    exec.native_account::set_item
    # => [OLD_PAUSED_WORD, pad(16)]

    dropw
    # => [pad(16)]
end
