use miden::protocol::active_account
use miden::protocol::account_id
use miden::protocol::active_note
use miden::protocol::note
use miden::protocol::output_note
use miden::standards::wallets::basic->basic_wallet

# ERRORS
# =================================================================================================

const ERR_P2ID_UNEXPECTED_NUMBER_OF_STORAGE_ITEMS="P2ID note expects exactly 2 note storage items"

const ERR_P2ID_TARGET_ACCT_MISMATCH="P2ID's target account address and transaction address do not match"

#! Pay-to-ID script: adds all assets from the note to the account, assuming ID of the account
#! matches target account ID specified by the note storage.
#!
#! Requires that the account exposes:
#! - miden::standards::wallets::basic::receive_asset procedure.
#!
#! Inputs:  []
#! Outputs: []
#!
#! Note storage is assumed to be as follows:
#! - target_account_id is the ID of the account for which the note is intended.
#!
#! Panics if:
#! - Account does not expose miden::standards::wallets::basic::receive_asset procedure.
#! - Account ID of executing account is not equal to the Account ID specified via note storage.
#! - The same non-fungible asset already exists in the account.
#! - Adding a fungible asset would result in amount overflow, i.e., the total amount would be
#!   greater than 2^63.
@note_script
pub proc main
    # store the note storage to memory starting at address 0
    padw push.0 exec.active_note::get_storage
    # => [num_storage_items, storage_ptr, EMPTY_WORD]

    # make sure the number of storage items is 2
    eq.2 assert.err=ERR_P2ID_UNEXPECTED_NUMBER_OF_STORAGE_ITEMS
    # => [storage_ptr, EMPTY_WORD]

    # read the target account ID from the note storage
    mem_loadw_be drop drop
    # => [target_account_id_prefix, target_account_id_suffix]

    exec.active_account::get_id
    # => [account_id_prefix, account_id_suffix, target_account_id_prefix, target_account_id_suffix, ...]

    # ensure account_id = target_account_id, fails otherwise
    exec.account_id::is_equal assert.err=ERR_P2ID_TARGET_ACCT_MISMATCH
    # => []

    exec.basic_wallet::add_assets_to_account
    # => []
end

#! Creates a new P2ID output note from the given inputs.
#!
#! This procedure handles:
#! - Writing note storage to memory in the expected layout
#! - Obtaining the note script root via procref
#! - Building the recipient and creating the note
#!
#! Inputs:  [target_id_prefix, target_id_suffix, tag, note_type, SERIAL_NUM]
#! Outputs: [note_idx]
#!
#! Where:
#! - target_id_prefix is the prefix felt of the target account ID.
#! - target_id_suffix is the suffix felt of the target account ID.
#! - tag is the note tag to be included in the note.
#! - note_type is the storage type of the note (1 = public, 2 = private).
#! - SERIAL_NUM is the serial number of the note (4 elements).
#! - note_idx is the index of the created note.
#!
#! Invocation: exec
pub proc new
    # Store note storage items in memory at address 0
    # Storage layout: [suffix, prefix] (to match existing P2ID storage format)
    #
    # Stack: [target_id_prefix, target_id_suffix, tag, note_type, SERIAL_NUM]

    # Store target_id_suffix at memory[0]
    dup.1 push.0 mem_store
    # => [target_id_prefix, target_id_suffix, tag, note_type, SERIAL_NUM]

    # Store target_id_prefix at memory[1]
    dup push.1 mem_store
    # => [target_id_prefix, target_id_suffix, tag, note_type, SERIAL_NUM]

    # Drop the account ID elements, keep tag, note_type, SERIAL_NUM
    drop drop
    # => [tag, note_type, SERIAL_NUM]

    # Move tag and note_type out of the way for build_recipient
    movdn.5 movdn.5
    # => [SERIAL_NUM, tag, note_type]

    # Get the script root using procref
    procref.main
    # => [SCRIPT_ROOT, SERIAL_NUM, tag, note_type]

    # Reorder for build_recipient: [storage_ptr, num_storage_items, SERIAL_NUM, SCRIPT_ROOT]
    swapw
    # => [SERIAL_NUM, SCRIPT_ROOT, tag, note_type]

    push.2 push.0
    # => [storage_ptr=0, num_storage_items=2, SERIAL_NUM, SCRIPT_ROOT, tag, note_type]

    # Build the recipient
    exec.note::build_recipient
    # => [RECIPIENT, tag, note_type]

    # Reorder for output_note::create: [tag, note_type, RECIPIENT]
    movup.5 movup.5
    # => [tag, note_type, RECIPIENT]

    # Create the output note
    exec.output_note::create
    # => [note_idx]
end
