use miden::protocol::active_account
use miden::protocol::active_note
use miden::protocol::faucet
use miden::protocol::native_account
use miden::protocol::output_note
use ::miden::protocol::asset::FUNGIBLE_ASSET_MAX_AMOUNT

# CONSTANTS
# =================================================================================================

const PRIVATE_NOTE=2

# ERRORS
# =================================================================================================

const ERR_FUNGIBLE_ASSET_TOKEN_SUPPLY_EXCEEDS_MAX_SUPPLY="token supply exceeds max supply"

const ERR_FUNGIBLE_ASSET_MAX_SUPPLY_EXCEEDS_MAX_ALLOWED_SUPPLY="max supply exceeds maximum representable supply"

const ERR_FUNGIBLE_ASSET_DISTRIBUTE_AMOUNT_EXCEEDS_MAX_SUPPLY="amount passed to distribute exceeds the maximum supply"

const ERR_BASIC_FUNGIBLE_BURN_WRONG_NUMBER_OF_ASSETS="burn requires exactly 1 note asset"

# CONSTANTS
# =================================================================================================

# The local memory address at which the metadata slot content is stored.
const METADATA_SLOT_LOCAL=0

# The standard slot where fungible faucet metadata like token symbol or decimals are stored.
const METADATA_SLOT=word("miden::standards::fungible_faucets::metadata")

#! Distributes freshly minted fungible assets to the provided recipient by creating a note.
#!
#! Inputs:  [amount, tag, note_type, RECIPIENT]
#! Outputs: [note_idx]
#!
#! Where:
#! - amount is the amount to be minted and sent.
#! - tag is the tag to be included in the note.
#! - note_type is the type of the note that holds the asset.
#! - RECIPIENT is the recipient of the asset, i.e.,
#!   hash(hash(hash(serial_num, [0; 4]), script_root), storage_commitment).
#! - note_idx is the index of the created note.
#!
#! Panics if:
#! - TODO: Double check.
#! - the transaction is being executed against an account that is not a fungible asset faucet.
#! - the token supply after minting is greater than the maximum allowed supply.
#!
#! Invocation: exec
@locals(4)
pub proc distribute
    # Get the configured max supply and the token supply (= current supply).
    # ---------------------------------------------------------------------------------------------

    push.METADATA_SLOT[0..2] exec.active_account::get_item
    # => [token_symbol, decimals, max_supply, token_supply, amount, tag, note_type, RECIPIENT]

    # store a copy of the current slot content for the token_supply update later
    loc_storew_be.METADATA_SLOT_LOCAL
    drop drop
    # => [max_supply, token_supply, amount, tag, note_type, RECIPIENT]

    # Assert that minting does not violate any supply constraints.
    # ---------------------------------------------------------------------------------------------

    dup.1 dup.1
    # => [max_supply, token_supply, max_supply, token_supply, amount, tag, note_type, RECIPIENT]

    # assert that token_supply <= max_supply
    # if token_supply > max_supply, then computing max_supply - token_supply would wrap around,
    # because `sub` has wrapping semantics, and this would allow minting larger amounts than
    # intended
    # this primarily protects against misconfigurations, since token_supply cannot exceed
    # max_supply by the remaining logic here
    lte assert.err=ERR_FUNGIBLE_ASSET_TOKEN_SUPPLY_EXCEEDS_MAX_SUPPLY
    # => [max_supply, token_supply, amount, tag, note_type, RECIPIENT]

    # assert max_supply <= max_allowed_supply
    # ensures the max supply never exceeds what can be represented and because of the previous
    # assertion, this also implies token_supply <= max_supply <= max_allowed_supply
    # this means adding the amount to the token_supply will not exceed the max representable
    # amount either
    dup lte.FUNGIBLE_ASSET_MAX_AMOUNT
    assert.err=ERR_FUNGIBLE_ASSET_MAX_SUPPLY_EXCEEDS_MAX_ALLOWED_SUPPLY
    # => [max_supply, token_supply, amount, tag, note_type, RECIPIENT]

    dup.2 swap dup.2
    # => [token_supply, max_supply, amount, token_supply, amount, tag, note_type, RECIPIENT]

    # compute maximum amount that can be minted, max_mint_amount = max_supply - token_supply
    sub
    # => [max_mint_amount, amount, token_supply, amount, tag, note_type, RECIPIENT]

    # assert that amount <= max_mint_amount
    # this ensures that max_supply is not exceeded and that token_supply at most ends up equal
    # to max_supply
    lte assert.err=ERR_FUNGIBLE_ASSET_DISTRIBUTE_AMOUNT_EXCEEDS_MAX_SUPPLY
    # => [token_supply, amount, tag, note_type, RECIPIENT]

    # Compute the new token_supply and update in storage.
    # ---------------------------------------------------------------------------------------------

    dup.1 add
    # => [new_token_supply, amount, tag, note_type, RECIPIENT]

    padw loc_loadw_be.METADATA_SLOT_LOCAL
    # => [[token_symbol, decimals, max_supply, token_supply], new_token_supply, amount, tag, note_type, RECIPIENT]

    movup.4 swap.4 drop
    # => [[token_symbol, decimals, max_supply, new_token_supply], amount, tag, note_type, RECIPIENT]

    # update the metadata slot with the new supply
    push.METADATA_SLOT[0..2] exec.native_account::set_item dropw
    # => [amount, tag, note_type, RECIPIENT]

    # Mint the asset.
    # ---------------------------------------------------------------------------------------------

    # creating the asset
    exec.faucet::create_fungible_asset
    # => [ASSET, tag, note_type, RECIPIENT]

    # mint the asset; this is needed to satisfy asset preservation logic.
    exec.faucet::mint
    # => [ASSET, tag, note_type, RECIPIENT]

    movdn.9 movdn.9 movdn.9 movdn.9
    # => [tag, note_type, RECIPIENT, ASSET]

    # Create a new note with the asset.
    # ---------------------------------------------------------------------------------------------

    # create a note
    exec.output_note::create
    # => [note_idx, ASSET]

    # load the ASSET and add it to the note
    dup movdn.5 movdn.5
    # => [ASSET, note_idx, note_idx]

    exec.output_note::add_asset
    # => [note_idx]
end

#! Burns the fungible asset from the active note.
#!
#! This procedure retrieves the asset from the active note and burns it. The note must contain
#! exactly one asset, which must be a fungible asset issued by this faucet.
#!
#! Inputs:  [pad(16)]
#! Outputs: [pad(16)]
#!
#! Where:
#! - ASSET is the fungible asset that was burned.
#!
#! Panics if:
#! - the procedure is not called from a note context (active_note::get_assets will fail).
#! - the note does not contain exactly one asset.
#! - the transaction is executed against an account which is not a fungible asset faucet.
#! - the transaction is executed against a faucet which is not the origin of the specified asset.
#! - the amount about to be burned is greater than the outstanding supply of the asset.
#!
#! Invocation: call
pub proc burn
    # Get the assets from the note. This will fail if not called from a note context.
    push.0 exec.active_note::get_assets
    # => [num_assets, dest_ptr, pad(16)]

    # Verify we have exactly one asset
    assert.err=ERR_BASIC_FUNGIBLE_BURN_WRONG_NUMBER_OF_ASSETS
    # => [dest_ptr, pad(16)]

    mem_loadw_be
    # => [ASSET, pad(16)]

    # burning the asset
    exec.faucet::burn
    # => [ASSET, pad(16)]

    dropw
    # => [pad(16)]
end
