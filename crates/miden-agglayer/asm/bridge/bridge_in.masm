use miden::agglayer::crypto_utils

# Inputs: []
# Output: [GER_ROOT[8]]
pub proc get_rollup_exit_root
    # Push dummy GER (8 elements)
    push.0.0.0.0.0.0.0.0  # dummy GER
end

#! Checks the validity of the GET proof
#!
#! Inputs:
#!   Operand stack: [PROOF_DATA_KEY, LEAF_DATA_KEY, pad(8)]
#!   Advice map: {
#!     PROOF_DATA_KEY => [
#!       smtProofLocalExitRoot[256],      // SMT proof for local exit root (256 felts, bytes32[_DEPOSIT_CONTRACT_TREE_DEPTH])
#!       smtProofRollupExitRoot[256],     // SMT proof for rollup exit root (256 felts, bytes32[_DEPOSIT_CONTRACT_TREE_DEPTH])
#!       globalIndex[8],                  // Global index (8 felts, uint256 as 8 u32 felts)
#!       mainnetExitRoot[8],              // Mainnet exit root hash (8 felts, bytes32 as 8 u32 felts)
#!       rollupExitRoot[8],               // Rollup exit root hash (8 felts, bytes32 as 8 u32 felts)
#!     ],
#!     LEAF_DATA_KEY => [
#!       originNetwork[1],                // Origin network identifier (1 felt, uint32)
#!       originTokenAddress[5],           // Origin token address (5 felts, address as 5 u32 felts)
#!       destinationNetwork[1],           // Destination network identifier (1 felt, uint32)
#!       destinationAddress[5],           // Destination address (5 felts, address as 5 u32 felts)
#!       amount[8],                       // Amount of tokens (8 felts, uint256 as 8 u32 felts)
#!       metadata[8],                     // ABI encoded metadata (8 felts, fixed size)
#!       EMPTY_WORD                       // padding
#!     ],
#!   }
#!
#! Invocation: call
pub proc check_claim_proof
    exec.get_rollup_exit_root
    # => [GER_ROOT[8], PROOF_DATA_KEY, LEAF_DATA_KEY]

    # Check CLAIM note proof data against current GER 
    exec.crypto_utils::verify_claim_proof
    # => [is_valid_claim_proof]

    swap drop
end
