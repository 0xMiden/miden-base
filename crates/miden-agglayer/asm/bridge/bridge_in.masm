use miden::agglayer::crypto_utils
use miden::protocol::active_account
use miden::protocol::native_account

# CONSTANTS
# =================================================================================================
const GER_UPPER_STORAGE_SLOT=word("miden::agglayer::bridge::ger_upper")
const GER_LOWER_STORAGE_SLOT=word("miden::agglayer::bridge::ger_lower")

# Inputs: [GER_UPPER[4], GER_LOWER[4]]
# Outputs: []
pub proc update_ger
    # Store GER_UPPER at key [0,0,0,0]
    push.GER_UPPER_STORAGE_SLOT[0..2]
    # => [slot_id_prefix, slot_id_suffix, GER_UPPER[4], GER_LOWER[4]]

    exec.native_account::set_item
    # => [OLD_VALUE, GER_LOWER[4]]

    dropw
    # => [GER_LOWER[4]]

    # Store GER_LOWER at key [1,0,0,0]
    push.GER_LOWER_STORAGE_SLOT[0..2]
    # => [slot_id_prefix, slot_id_suffix, GER_LOWER[4]]

    exec.native_account::set_item
    # => [OLD_VALUE]

    dropw
    # => []
end

# Inputs: []
# Output: [GER_ROOT[8]]
pub proc get_rollup_exit_root
    # Push dummy GER (8 elements)
    push.0.0.0.0.0.0.0.0  # dummy GER
end

#! Checks the validity of the GET proof
#!
#! Inputs:
#!   Operand stack: [PROOF_DATA_KEY, LEAF_DATA_KEY, pad(8)]
#!   Advice map: {
#!     PROOF_DATA_KEY => [
#!       smtProofLocalExitRoot[256],      // SMT proof for local exit root (256 felts, bytes32[_DEPOSIT_CONTRACT_TREE_DEPTH])
#!       smtProofRollupExitRoot[256],     // SMT proof for rollup exit root (256 felts, bytes32[_DEPOSIT_CONTRACT_TREE_DEPTH])
#!       globalIndex[8],                  // Global index (8 felts, uint256 as 8 u32 felts)
#!       mainnetExitRoot[8],              // Mainnet exit root hash (8 felts, bytes32 as 8 u32 felts)
#!       rollupExitRoot[8],               // Rollup exit root hash (8 felts, bytes32 as 8 u32 felts)
#!     ],
#!     LEAF_DATA_KEY => [
#!       originNetwork[1],                // Origin network identifier (1 felt, uint32)
#!       originTokenAddress[5],           // Origin token address (5 felts, address as 5 u32 felts)
#!       destinationNetwork[1],           // Destination network identifier (1 felt, uint32)
#!       destinationAddress[5],           // Destination address (5 felts, address as 5 u32 felts)
#!       amount[8],                       // Amount of tokens (8 felts, uint256 as 8 u32 felts)
#!       metadata[8],                     // ABI encoded metadata (8 felts, fixed size)
#!       EMPTY_WORD                       // padding
#!     ],
#!   }
#!
#! Invocation: call
pub proc check_claim_proof
    exec.get_rollup_exit_root
    # => [GER_ROOT[8], PROOF_DATA_KEY, LEAF_DATA_KEY]

    # Check CLAIM note proof data against current GER 
    exec.crypto_utils::verify_claim_proof
    # => [is_valid_claim_proof]

    swap drop
end
