use miden::agglayer::crypto_utils
use miden::core::crypto::hashes::keccak256
use miden::core::mem
use miden::protocol::active_account
use miden::protocol::native_account

# CONSTANTS
# =================================================================================================
const GER_UPPER_STORAGE_SLOT=word("miden::agglayer::bridge::ger_upper")
const GER_LOWER_STORAGE_SLOT=word("miden::agglayer::bridge::ger_lower")

const PROOF_DATA_PTR = 0
const PROOF_DATA_WORD_LEN = 134
const SMT_PROOF_LOCAL_EXIT_ROOT_PTR = 0 # local SMT proof is first
const GLOBAL_INDEX_PTR = PROOF_DATA_PTR + 2 * 256 # 512
const EXIT_ROOTS_PTR = GLOBAL_INDEX_PTR + 8 # 520
const MAINNET_EXIT_ROOT_PTR = GLOBAL_INDEX_PTR # it's the first exit root

# ERRORS
# =================================================================================================
const ERR_BRIDGE_NOT_MAINNET = "bridge not mainnet"
const ERR_LEADING_BITS_NON_ZERO = "leading bits of global index must be zero"
const ERR_ROLLUP_INDEX_NON_ZERO = "rollup index must be zero for a mainnet deposit"

# PUBLIC INTERFACE
# =================================================================================================

# Inputs: [GER_LOWER[4], GER_UPPER[4]]
# Outputs: []
pub proc update_ger
    push.GER_LOWER_STORAGE_SLOT[0..2]
    # => [slot_id_prefix, slot_id_suffix, GER_LOWER[4], GER_UPPER[4]]

    exec.native_account::set_item
    # => [OLD_VALUE, GER_UPPER[4]]

    dropw
    # => [GER_UPPER[4]]

    push.GER_UPPER_STORAGE_SLOT[0..2]
    # => [slot_id_prefix, slot_id_suffix, GER_UPPER[4]]

    exec.native_account::set_item
    # => [OLD_VALUE]

    dropw
    # => []
end

#! Verifies the pre-computed leaf value against the AggLayer bridge.
#!
#! Inputs:
#!   Operand stack: [LEAF_VALUE[8], PROOF_DATA_KEY, pad(4)]
#!   Advice map: {
#!     PROOF_DATA_KEY => [
#!       smtProofLocalExitRoot[256],      // SMT proof for local exit root (256 felts, bytes32[_DEPOSIT_CONTRACT_TREE_DEPTH])
#!       smtProofRollupExitRoot[256],     // SMT proof for rollup exit root (256 felts, bytes32[_DEPOSIT_CONTRACT_TREE_DEPTH])
#!       globalIndex[8],                  // Global index (8 felts, uint256 as 8 u32 felts)
#!       mainnetExitRoot[8],              // Mainnet exit root hash (8 felts, bytes32 as 8 u32 felts)
#!       rollupExitRoot[8],               // Rollup exit root hash (8 felts, bytes32 as 8 u32 felts)
#!     ],
#!   }
#!
#! Outputs: [pad(16)]
#!
#! Invocation: call
pub proc verify_leaf_bridge
    # LEAF_VALUE[8] is pre-computed by the caller via keccak256 hash
    # => [LEAF_VALUE[8], PROOF_DATA_KEY, pad(4)]

    # delegate proof verification
    exec.verify_leaf
end

# Inputs: [GER_ROOT[8]]
# Output: []
pub proc assert_valid_ger
    # TODO verify that GER is in storage
    dropw dropw
end

#! Assert the global index is valid for a mainnet deposit.
#!
#! Inputs: [GLOBAL_INDEX[8]]
#! Outputs: [leaf_index]
#!
#! Invocation: exec
pub proc process_global_index_mainnet
# for v0.1, let's only implement the mainnet branch
    # the top 191 bits of the global index are zero
    repeat.5 assertz.err=ERR_LEADING_BITS_NON_ZERO end

    # the next element is a u32 mainnet flag bit
    # enforce that this limb is one
    # => [mainnet_flag, GLOBAL_INDEX[6..8], LEAF_VALUE[8]]
    assert.err=ERR_BRIDGE_NOT_MAINNET

    # the next element is a u32 rollup index, must be zero for a mainnet deposit
    assertz.err=ERR_ROLLUP_INDEX_NON_ZERO

    # finally, the leaf index = lowest 32 bits = last limb
    # => [leaf_index]
end

# HELPER PROCEDURES
# =================================================================================================

#! Verify leaf and checks that it has not been claimed.
#!
#! Inputs:
#!   Operand stack: [LEAF_VALUE[8], PROOF_DATA_KEY]
#!
#! Outputs: []
#!
#! Invocation: exec
proc verify_leaf
    movupw.2
    # load proof data from the advice map into memory
    adv.push_mapval
    # => [PROOF_DATA_KEY, LEAF_VALUE[8]]

    push.SMT_PROOF_LOCAL_EXIT_ROOT_PTR push.PROOF_DATA_WORD_LEN
    exec.mem::pipe_preimage_to_memory drop

    # 1. compute GER from mainnet + rollup exit roots
    push.EXIT_ROOTS_PTR
    # => [exit_roots_ptr, LEAF_VALUE[8]]
    exec.crypto_utils::compute_ger
    # => [GER[8], LEAF_VALUE[8]]

    # 2. assert the GER is valid
    exec.assert_valid_ger
    # => [LEAF_VALUE[8]]

    # 3. load global index from memory
    padw mem_loadw_le.GLOBAL_INDEX_PTR
    padw push.GLOBAL_INDEX_PTR add.4 mem_loadw_le swapw
    # => [GLOBAL_INDEX[8], LEAF_VALUE[8]]

    # to see if we're dealing with a deposit from mainnet or from a rollup, process the global index
    # TODO currently only implemented for mainnet deposits (mainnet flag must be 1)
    exec.process_global_index_mainnet
    # => [leaf_index]

    # load the pointers to the merkle proof and root, to pass to `verify_merkle_proof`
    push.SMT_PROOF_LOCAL_EXIT_ROOT_PTR
    push.MAINNET_EXIT_ROOT_PTR

    # => [mainnet_exit_root_ptr, smt_proof_local_exit_root_ptr, leaf_index, LEAF_VALUE[8]]
    movdn.10
    # => [smt_proof_local_exit_root_ptr, leaf_index, LEAF_VALUE[8], mainnet_exit_root_ptr]
    # delegate verification to crypto_utils::verify_merkle_proof (stubbed for now)
    exec.crypto_utils::verify_merkle_proof
end
