use miden::core::math::u64
use miden::core::word

# CONSTANTS
# =================================================================================================

const MAX_SCALING_FACTOR=18

# ERRORS
# =================================================================================================

const ERR_SCALE_AMOUNT_EXCEEDED_LIMIT="maximum scaling factor is 18"
const ERR_X_TOO_LARGE="x must fit into 128 bits (x4..x7 must be 0)"
const ERR_UNDERFLOW="x < y*10^s (underflow detected)"
const ERR_REMAINDER_TOO_LARGE="remainder z must be < 10^s"

#! Calculate 10^scale where scale is a u8 exponent.
#!
#! Inputs:  [scale]
#! Outputs: [10^scale]
#!
#! Where:
#! - scale is expected to be a small integer (0-18 typical for crypto decimals)
#!
#! Panics if:
#! - scale > 18 (overflow protection)
proc pow10
    u32assert.err=ERR_SCALE_AMOUNT_EXCEEDED_LIMIT
    # => [scale]

    dup u32lte.MAX_SCALING_FACTOR assert.err=ERR_SCALE_AMOUNT_EXCEEDED_LIMIT
    # => [scale]

    push.1 swap
    # => [scale, result]

    dup neq.0
    # => [is_not_zero, scale, result]

    # Loop to calculate 10^scale
    while.true
        # => [scale, result]

        # result *= 10
        swap mul.10 swap
        # => [scale, result*10]

        # scale -= 1
        sub.1
        # => [scale-1, result*10]

        dup neq.0
        # => [is_not_zero, scale-1, result*10]
    end
    # => [0, result]

    drop
    # => [result]
end

#! Convert an asset amount to a scaled U256 representation for bridging to Agglayer.
#!
#! This procedure is used to convert Miden asset amounts to EVM asset amounts.
#! It multiplies the input amount by 10^target_scale to adjust for decimal differences
#! between the current representation and the target chain's native decimals.
#!
#! The procedure first calculates 10^target_scale using the pow10 helper, then converts
#! both the amount and scale factor to U64 format, performs U64 multiplication, and
#! returns the result as 8 u32 limbs in little-endian order (U256 format).
#!
#! Inputs:  [amount, target_scale]
#! Outputs: [[RESULT_U256[0], RESULT_U256[1]]]
#!
#! Where:
#! - amount: The asset amount to be converted (range: 0 to 2^63 - 2^31)
#! - target_scale: Exponent for scaling factor (10^target_scale)
#! - [RESULT_U256[0], RESULT_U256[1]]: U256 value as 8 u32 limbs in little-endian order
#!   (least significant limb at the top of the stack, each limb stored in little-endian format)
#!
#! Examples:
#! - USDC: amount=1000000000, target_scale=0 → 1000000000 (no scaling)
#! - ETH: amount=1e10, target_scale=8 → 1e18
#!
#! Invocation: exec
pub proc scale_native_amount_to_u256
    swap
    # => [target_scale, amount]

    exec.pow10
    # => [scale, amount]

    u32split
    # => [scale_hi, scale_lo, amount]

    movup.2 u32split
    # => [amount_hi, amount_lo, scale_hi, scale_lo]

    # Perform U64 multiplication: amount * scale
    # This is safe because both the scaling factor and amount are guaranteed to be smaller
    # than 2^64, so we will never overflow a 256-bit value.
    exec.u64::overflowing_mul
    # => [res_hi, res_mid_hi, res_mid_lo, res_lo]

    exec.word::reverse
    # => [res_lo, res_mid_lo, res_mid_hi, res_hi]

    # convert to U256 & little endian
    padw swapw
    # => [RESULT_U256[0], RESULT_U256[1]]
end

```masm
#! Verify conversion from an AggLayer U256 amount to a Miden native amount (Felt)
#!
#! Specification:
#!     Verify that a provided y is the quotient of dividing x by 10^scale_exp:
#!         y = floor(x / 10^scale_exp)
#!
#! This procedure does NOT perform division. It proves the quotient is correct by checking:
#!   1) y is within the allowed fungible token amount range
#!   2) y_scaled = y * 10^scale_exp          (computed via scale_native_amount_to_u256)
#!   3) z        = x - y_scaled              (must not underflow, i.e. y_scaled <= x)
#!   4) z fits in 64 bits                    (upper 192 bits are zero)
#!   5) (z1, z0) < 10^scale_exp              (remainder bound)
#!
#! These conditions prove:
#!     x = y_scaled + z, with 0 <= z < 10^scale_exp
#! which uniquely implies:
#!     y = floor(x / 10^scale_exp)
#!
#! Example (ETH -> Miden base 1e8):
#!   - EVM amount:   100 ETH = 100 * 10^18
#!   - Miden amount: 100 ETH = 100 * 10^8
#!   - Therefore the scale-down factor is:
#!         scale = 10^(18 - 8) = 10^10
#!         scale_exp = 10
#!   - Inputs/expected values:
#!         x        = 100 * 10^18
#!         y        = floor(x / 10^10) = 100 * 10^8
#!         y_scaled = y * 10^10 = 100 * 10^18
#!         z        = x - y_scaled = 0
#!
#! NOTE: For efficiency, this verifier enforces x < 2^128 by requiring x4..x7 == 0.
#!
#! Inputs:  [x0, x1, x2, x3, x4, x5, x6, x7, scale_exp, y]
#!          Where x is encoded as 8 u32 limbs in little-endian order.
#!          (x0 is least significant limb and is at the top of the stack)
#! Outputs: [y]
#!
#! Where:
#!   - x: The original AggLayer amount as an unsigned 256-bit integer (U256).
#!        It is provided on the operand stack as 8 little-endian u32 limbs:
#!          x = x0 + x1·2^32 + x2·2^64 + x3·2^96 + x4·2^128 + x5·2^160 + x6·2^192 + x7·2^224
#!   - x0..x7: 32-bit limbs of x in little-endian order (x0 is least significant).
#!   - scale_exp: The base-10 exponent used for scaling down (an integer in [0, 18]).
#!   - y: The provided quotient (Miden native amount) as a Felt interpreted as an unsigned u64.
#!   - y_scaled: The 256-bit value y * 10^scale_exp represented as 8 u32 limbs (little-endian).
#!   - z: The remainder-like difference z = x - y_scaled. This verifier requires z < 10^scale_exp.
#!
#! Panics if:
#! - scale_exp > 18
#! - y exceeds the max fungible token amount
#! - x does not fit into 128 bits (x4..x7 are not all zero)
#! - x < y * 10^scale_exp (underflow)
#! - z does not fit in 64 bits
#! - (z1, z0) >= 10^scale_exp (remainder too large)
pub proc verify_u256_to_native_amount_conversion
    # =============================================================================================
    # Step 0: Enforce x < 2^128
    #   Constraint: x4 == x5 == x6 == x7 == 0
    # =============================================================================================
    dup.4 assertz.err=ERR_X_TOO_LARGE
    dup.5 assertz.err=ERR_X_TOO_LARGE
    dup.6 assertz.err=ERR_X_TOO_LARGE
    dup.7 assertz.err=ERR_X_TOO_LARGE
    # => [x0, x1, x2, x3, x4, x5, x6, x7, scale_exp, y]

    # Drop the upper 128 bits of x (x4..x7), keep scale_exp and y.
    swapw dropw
    # => [x0, x1, x2, x3, scale_exp, y]

    # =============================================================================================
    # Step 1: Enforce y <= MAX_FUNGIBLE_TOKEN_AMOUNT
    #   Constraint: y <= MAX_FUNGIBLE_TOKEN_AMOUNT
    # =============================================================================================
    dup.5 u32split
    # => [y_hi, y_lo, x0, x1, x2, x3, scale_exp, y]

    push.MAX_FUNGIBLE_AMOUNT_LO
    push.MAX_FUNGIBLE_AMOUNT_HI
    # => [MAX_hi, MAX_lo, y_hi, y_lo, x0, x1, x2, x3, scale_exp, y]

    exec.u64::lte
    # => [is_lte, x0, x1, x2, x3, scale_exp, y]

    assert.err=ERR_Y_TOO_LARGE
    # => [x0, x1, x2, x3, scale_exp, y]

    # =============================================================================================
    # Step 2: Compute y_scaled = y * 10^scale_exp
    #
    # Call:
    #   scale_native_amount_to_u256(amount=y, target_scale=scale_exp)
    # =============================================================================================
    movup.4
    movup.5
    # => [y, scale_exp, x0, x1, x2, x3]

    dup.1 dup.1
    # => [y, scale_exp, y, scale_exp, x0, x1, x2, x3]

    exec.scale_native_amount_to_u256
    # => [y_scaled0..y_scaled7, y, scale_exp, x0, x1, x2, x3]

    # Because x < 2^128, require y_scaled < 2^128 as well:
    #   Constraint: y_scaled4 == y_scaled5 == y_scaled6 == y_scaled7 == 0
    dup.4 assertz.err=ERR_UNDERFLOW
    dup.5 assertz.err=ERR_UNDERFLOW
    dup.6 assertz.err=ERR_UNDERFLOW
    dup.7 assertz.err=ERR_UNDERFLOW

    # Drop the upper 128 bits of y_scaled (y_scaled4..y_scaled7), keep only y_scaled0..y_scaled3.
    swapw dropw
    # => [y_scaled0, y_scaled1, y_scaled2, y_scaled3, y, scale_exp, x0, x1, x2, x3]

    # =============================================================================================
    # Step 3: Compute z = x - y_scaled and prove no underflow
    #   z := x - y_scaled
    #   Constraint: y_scaled <= x
    # =============================================================================================

    # low64 subtraction:
    #   (x1,x0) - (y_scaled1,y_scaled0) = (z1,z0)
    #   borrow_from_low64 indicates whether the subtraction borrowed.
    movup.6     # x0
    movup.7     # x1
    movup.2     # y_scaled0
    movup.3     # y_scaled1
    exec.u64::overflowing_sub
    # => [borrow_from_low64, z1, z0, y_scaled2, y_scaled3, y, scale_exp, x2, x3]

    # high64 subtraction (raw, before applying borrow_from_low64):
    #   (x3,x2) - (y_scaled3,y_scaled2) = (t_hi,t_lo)
    #   underflow_high64_raw indicates whether this subtraction underflowed.
    movup.7     # x2
    movup.8     # x3
    movup.5     # y_scaled2
    movup.6     # y_scaled3
    exec.u64::overflowing_sub
    # => [underflow_high64_raw, t_hi, t_lo, borrow_from_low64, z1, z0, y, scale_exp]

    # apply the propagated borrow from the low64 subtraction:
    #   (t_hi,t_lo) - borrow_from_low64 = (z_hi,z_lo)
    #   underflow_high64_after_borrow indicates whether this subtraction underflowed.
    swap.3
    push.0
    exec.u64::overflowing_sub
    # => [underflow_high64_after_borrow, z_hi, z_lo, underflow_high64_raw, z1, z0, y, scale_exp]

    # overall underflow occurs if either high64 step underflowed:
    #   underflow_detected = underflow_high64_raw OR underflow_high64_after_borrow
    movup.3 or
    assertz.err=ERR_UNDERFLOW
    # => [z_hi, z_lo, z1, z0, y, scale_exp]

    # =============================================================================================
    # Step 4: Enforce z fits in 64 bits
    #   Constraint: the upper 64 bits of z are zero
    #   i.e. z_hi == 0 and z_lo == 0
    # =============================================================================================
    assertz.err=ERR_REMAINDER_TOO_LARGE
    assertz.err=ERR_REMAINDER_TOO_LARGE
    # => [z1, z0, y, scale_exp]

    # =============================================================================================
    # Step 5: Enforce (z1, z0) < 10^scale_exp
    # =============================================================================================
    movup.3
    exec.pow10
    # => [scale, z1, z0, y]

    u32split
    # => [scale_hi, scale_lo, z1, z0, y]

    exec.u64::lt
    # => [is_lt, y]

    assert.err=ERR_REMAINDER_TOO_LARGE
    # => [y]
end


# TODO: Rm & use verify_u256_to_native_amount_conversion
pub proc verify_u256_to_native_amount_conversion_stubbed
    repeat.7 drop end
end
