use miden::core::math::u64
use miden::core::word

# CONSTANTS
# =================================================================================================

const MAX_SCALING_FACTOR=18

# ERRORS
# =================================================================================================
const ERR_SCALE_AMOUNT_EXCEEDED_LIMIT="maximum scaling factor is 18"

#! Calculate 10^scale where scale is a u8 exponent.
#!
#! Inputs:  [scale]
#! Outputs: [10^scale]
#!
#! Where:
#! - scale is expected to be a small integer (0-18 typical for crypto decimals)
#!
#! Panics if:
#! - scale > 18 (overflow protection)
proc pow10
    u32assert.err=ERR_SCALE_AMOUNT_EXCEEDED_LIMIT
    # => [scale]

    dup u32lte.MAX_SCALING_FACTOR assert.err=ERR_SCALE_AMOUNT_EXCEEDED_LIMIT
    # => [scale]

    push.1 swap
    # => [scale, result]

    dup neq.0
    # => [is_not_zero, scale, result]

    # Loop to calculate 10^scale
    while.true
        # => [scale, result]

        # result *= 10
        swap mul.10 swap
        # => [scale, result*10]

        # scale -= 1
        sub.1
        # => [scale-1, result*10]

        dup neq.0
        # => [is_not_zero, scale-1, result*10]
    end
    # => [0, result]

    drop
    # => [result]
end

#! Convert an asset amount to a scaled U256 representation for bridging to Agglayer.
#!
#! This procedure is used to convert Miden asset amounts to EVM asset amounts.
#! It multiplies the input amount by 10^target_scale to adjust for decimal differences
#! between the current representation and the target chain's native decimals.
#!
#! The procedure first calculates 10^target_scale using the pow10 helper, then converts
#! both the amount and scale factor to U64 format, performs U64 multiplication, and
#! returns the result as 8 u32 limbs in little-endian order (U256 format).
#!
#! Inputs:  [amount, target_scale]
#! Outputs: [[RESULT_U256[0], RESULT_U256[1]]]
#!
#! Where:
#! - amount: The asset amount to be converted (range: 0 to 2^63 - 2^31)
#! - target_scale: Exponent for scaling factor (10^target_scale)
#! - [RESULT_U256[0], RESULT_U256[1]]: U256 value as 8 u32 limbs in little-endian order
#!   (least significant limb at the top of the stack, each limb stored in little-endian format)
#!
#! Examples:
#! - USDC: amount=1000000000, target_scale=0 → 1000000000 (no scaling)
#! - ETH: amount=1e10, target_scale=8 → 1e18
#!
#! Invocation: exec
pub proc scale_native_amount_to_u256
    swap
    # => [target_scale, amount]

    exec.pow10
    # => [scale, amount]

    u32split
    # => [scale_hi, scale_lo, amount]

    movup.2 u32split
    # => [amount_hi, amount_lo, scale_hi, scale_lo]

    # Perform U64 multiplication: amount * scale
    # This is safe because both the scaling factor and amount are guaranteed to be smaller
    # than 2^64, so we will never overflow a 256-bit value.
    exec.u64::overflowing_mul
    # => [res_hi, res_mid_hi, res_mid_lo, res_lo]

    exec.word::reverse
    # => [res_lo, res_mid_lo, res_mid_hi, res_hi]

    # convert to U256 & little endian
    padw swapw
    # => [RESULT_U256[0], RESULT_U256[1]]
end
