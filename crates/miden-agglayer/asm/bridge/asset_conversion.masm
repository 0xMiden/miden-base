use miden::core::math::u64
use miden::core::word

# CONSTANTS
# =================================================================================================

const MAX_SCALING_FACTOR=18

# ERRORS
# =================================================================================================

const ERR_SCALE_AMOUNT_EXCEEDED_LIMIT="maximum scaling factor is 18"
const ERR_X_TOO_LARGE="x must fit into 128 bits (x4..x7 must be 0)"
const ERR_UNDERFLOW="x < y*10^s (underflow detected)"
const ERR_REMAINDER_TOO_LARGE="remainder z must be < 10^s"

#! Calculate 10^scale where scale is a u8 exponent.
#!
#! Inputs:  [scale]
#! Outputs: [10^scale]
#!
#! Where:
#! - scale is expected to be a small integer (0-18 typical for crypto decimals)
#!
#! Panics if:
#! - scale > 18 (overflow protection)
proc pow10
    u32assert.err=ERR_SCALE_AMOUNT_EXCEEDED_LIMIT
    # => [scale]

    dup u32lte.MAX_SCALING_FACTOR assert.err=ERR_SCALE_AMOUNT_EXCEEDED_LIMIT
    # => [scale]

    push.1 swap
    # => [scale, result]

    dup neq.0
    # => [is_not_zero, scale, result]

    # Loop to calculate 10^scale
    while.true
        # => [scale, result]

        # result *= 10
        swap mul.10 swap
        # => [scale, result*10]

        # scale -= 1
        sub.1
        # => [scale-1, result*10]

        dup neq.0
        # => [is_not_zero, scale-1, result*10]
    end
    # => [0, result]

    drop
    # => [result]
end

#! Convert an asset amount to a scaled U256 representation for bridging to Agglayer.
#!
#! This procedure is used to convert Miden asset amounts to EVM asset amounts.
#! It multiplies the input amount by 10^target_scale to adjust for decimal differences
#! between the current representation and the target chain's native decimals.
#!
#! The procedure first calculates 10^target_scale using the pow10 helper, then converts
#! both the amount and scale factor to U64 format, performs U64 multiplication, and
#! returns the result as 8 u32 limbs in little-endian order (U256 format).
#!
#! Inputs:  [amount, target_scale]
#! Outputs: [[RESULT_U256[0], RESULT_U256[1]]]
#!
#! Where:
#! - amount: The asset amount to be converted (range: 0 to 2^63 - 2^31)
#! - target_scale: Exponent for scaling factor (10^target_scale)
#! - [RESULT_U256[0], RESULT_U256[1]]: U256 value as 8 u32 limbs in little-endian order
#!   (least significant limb at the top of the stack, each limb stored in little-endian format)
#!
#! Examples:
#! - USDC: amount=1000000000, target_scale=0 → 1000000000 (no scaling)
#! - ETH: amount=1e10, target_scale=8 → 1e18
#!
#! Invocation: exec
pub proc scale_native_amount_to_u256
    swap
    # => [target_scale, amount]

    exec.pow10
    # => [scale, amount]

    u32split
    # => [scale_hi, scale_lo, amount]

    movup.2 u32split
    # => [amount_hi, amount_lo, scale_hi, scale_lo]

    # Perform U64 multiplication: amount * scale
    # This is safe because both the scaling factor and amount are guaranteed to be smaller
    # than 2^64, so we will never overflow a 256-bit value.
    exec.u64::overflowing_mul
    # => [res_hi, res_mid_hi, res_mid_lo, res_lo]

    exec.word::reverse
    # => [res_lo, res_mid_lo, res_mid_hi, res_hi]

    # convert to U256 & little endian
    padw swapw
    # => [RESULT_U256[0], RESULT_U256[1]]
end

#! Convert an AggLayer U256 amount to a Miden native amount (Felt) by scaling down.
#!
#! This procedure verifies a *provided* quotient for the division:
#!     y = floor(x / 10^scale_exp)
#!
#! It does not perform division directly. Instead, it proves correctness by checking:
#! - scale = 10^scale_exp
#! - prod = y * scale
#! - rem  = x - prod            (must not underflow, i.e. prod <= x)
#! - rem  < scale               (remainder bound)
#!
#! Together these conditions prove:
#!     x = y*scale + rem, with 0 <= rem < scale
#! which uniquely implies y = floor(x / scale).
#!
#! NOTE: For efficiency, this verifier currently enforces x < 2^128 by requiring the
#! upper 4 limbs to be zero (x4..x7 == 0).
#!
#! Inputs:  [x0, x1, x2, x3, x4, x5, x6, x7, scale_exp, y]
#!          Where x is a U256 value encoded as 8 u32 limbs in little-endian order.
#!          (x0 is least significant limb and is at the top of the stack)
#! Outputs: [y]
#!
#! Panics if:
#! - scale_exp > 18
#! - x does not fit into 128 bits (x4..x7 are not all zero)
#! - x < y * 10^scale_exp (underflow)
#! - (x - y * 10^scale_exp) >= 10^scale_exp (remainder too large)
pub proc scale_u256_to_native_amount

    push.2202 debug.stack drop

    # --- enforce x < 2^128 (x4..x7 == 0) ---
    dup.4 assertz.err=ERR_X_TOO_LARGE
    dup.5 assertz.err=ERR_X_TOO_LARGE
    dup.6 assertz.err=ERR_X_TOO_LARGE
    dup.7 assertz.err=ERR_X_TOO_LARGE
    # => [x0, x1, x2, x3, x4, x5, x6, x7, scale_exp, y]

    # drop x4..x7 (keep scale_exp and y below)
    swapw dropw
    # => [x0, x1, x2, x3, scale_exp, y]

    # make pairs: (x3,x2) and (x1,x0)
    exec.word::reverse
    # => [x3, x2, x1, x0, scale_exp, y]

    # scale = 10^scale_exp (keep a copy for rem < scale check)
    movup.4
    exec.pow10
    # => [scale, x3, x2, x1, x0, y]

    dup
    # => [scale_mul, scale_cmp, x3, x2, x1, x0, y]

    # y from operand stack (it's at depth 6 right now); duplicate so we can return it
    movup.6
    dup
    # => [y_mul, y_ret, scale_mul, scale_cmp, x3, x2, x1, x0]

    # --- prod = y * scale as 128-bit (4x u32 limbs) ---
    u32split
    # => [y_hi, y_lo, y_ret, scale_mul, scale_cmp, x3, x2, x1, x0]

    movup.3 u32split
    # => [scale_hi, scale_lo, y_hi, y_lo, y_ret, scale_cmp, x3, x2, x1, x0]

    exec.u64::overflowing_mul
    # => [p3, p2, p1, p0, y_ret, scale_cmp, x3, x2, x1, x0]

    # --- low64: (x1,x0) - (p1,p0) ---
    movup.9     # x0
    movup.9     # x1
    movup.5     # p0
    movup.5     # p1
    exec.u64::overflowing_sub
    # => [under0, z1, z0, p3, p2, y_ret, scale_cmp, x3, x2]

    # --- high64: (x3,x2) - (p3,p2) ---
    movup.8     # x2
    movup.8     # x3
    movup.6     # p2
    movup.6     # p3
    exec.u64::overflowing_sub
    # => [under1, t_hi, t_lo, under0, z1, z0, y_ret, scale_cmp]

    # subtract borrow under0 from high64
    swap.3
    push.0
    exec.u64::overflowing_sub
    # => [under2, z_hi, z_lo, under1, z1, z0, y_ret, scale_cmp]

    # underflow = under1 OR under2
    movup.3 or
    assertz.err=ERR_UNDERFLOW
    # => [z_hi, z_lo, z1, z0, y_ret, scale_cmp]

    # --- enforce rem < scale_cmp (scale_cmp fits in u64) ---
    # if rem < scale_cmp <= 2^64, then high64(rem) must be zero
    dup assertz.err=ERR_REMAINDER_TOO_LARGE
    dup.1 assertz.err=ERR_REMAINDER_TOO_LARGE
    drop drop
    # => [z1, z0, y_ret, scale_cmp]

    # compare low64(rem) < scale_cmp
    movup.3 u32split
    # => [scale_hi, scale_lo, z1, z0, y_ret]

    exec.u64::lt
    # => [is_lt, y_ret]

    assert.err=ERR_REMAINDER_TOO_LARGE
    # => [y_ret]
end

# TODO: Rm & use scale_u256_to_native_amount
pub proc scale_u256_to_native_amount_stubbed
    repeat.7 drop end
end
