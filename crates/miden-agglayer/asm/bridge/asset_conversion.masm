use miden::core::math::u64
use miden::core::word
use miden::protocol::asset

# CONSTANTS
# =================================================================================================

const MAX_SCALING_FACTOR=18

# ERRORS
# =================================================================================================

const ERR_SCALE_AMOUNT_EXCEEDED_LIMIT="maximum scaling factor is 18"
const ERR_X_TOO_LARGE="x must fit into 128 bits (x4..x7 must be 0)"
const ERR_UNDERFLOW="x < y*10^s (underflow detected)"
const ERR_REMAINDER_TOO_LARGE="remainder z must be < 10^s"

const ERR_Y_TOO_LARGE="y exceeds max fungible token amount"

#! Calculate 10^scale where scale is a u8 exponent.
#!
#! Inputs:  [scale]
#! Outputs: [10^scale]
#!
#! Where:
#! - scale is expected to be a small integer (0-18 typical for crypto decimals)
#!
#! Panics if:
#! - scale > 18 (overflow protection)
proc pow10
    u32assert.err=ERR_SCALE_AMOUNT_EXCEEDED_LIMIT
    # => [scale]

    dup u32lte.MAX_SCALING_FACTOR assert.err=ERR_SCALE_AMOUNT_EXCEEDED_LIMIT
    # => [scale]

    push.1 swap
    # => [scale, result]

    dup neq.0
    # => [is_not_zero, scale, result]

    # Loop to calculate 10^scale
    while.true
        # => [scale, result]

        # result *= 10
        swap mul.10 swap
        # => [scale, result*10]

        # scale -= 1
        sub.1
        # => [scale-1, result*10]

        dup neq.0
        # => [is_not_zero, scale-1, result*10]
    end
    # => [0, result]

    drop
    # => [result]
end

#! Convert an asset amount to a scaled U256 representation for bridging to Agglayer.
#!
#! This procedure is used to convert Miden asset amounts to EVM asset amounts.
#! It multiplies the input amount by 10^target_scale to adjust for decimal differences
#! between the current representation and the target chain's native decimals.
#!
#! The procedure first calculates 10^target_scale using the pow10 helper, then converts
#! both the amount and scale factor to U64 format, performs U64 multiplication, and
#! returns the result as 8 u32 limbs in little-endian order (U256 format).
#!
#! Inputs:  [amount, target_scale]
#! Outputs: [[RESULT_U256[0], RESULT_U256[1]]]
#!
#! Where:
#! - amount: The asset amount to be converted (range: 0 to 2^63 - 2^31)
#! - target_scale: Exponent for scaling factor (10^target_scale)
#! - [RESULT_U256[0], RESULT_U256[1]]: U256 value as 8 u32 limbs in little-endian order
#!   (least significant limb at the top of the stack, each limb stored in little-endian format)
#!
#! Examples:
#! - USDC: amount=1000000000, target_scale=0 → 1000000000 (no scaling)
#! - ETH: amount=1e10, target_scale=8 → 1e18
#!
#! Invocation: exec
pub proc scale_native_amount_to_u256
    swap
    # => [target_scale, amount]

    exec.pow10
    # => [scale, amount]

    u32split
    # => [scale_hi, scale_lo, amount]

    movup.2 u32split
    # => [amount_hi, amount_lo, scale_hi, scale_lo]

    # Perform U64 multiplication: amount * scale
    # This is safe because both the scaling factor and amount are guaranteed to be smaller
    # than 2^64, so we will never overflow a 256-bit value.
    exec.u64::overflowing_mul
    # => [res_hi, res_mid_hi, res_mid_lo, res_lo]

    exec.word::reverse
    # => [res_lo, res_mid_lo, res_mid_hi, res_hi]

    # convert to U256 & little endian
    padw swapw
    # => [RESULT_U256[0], RESULT_U256[1]]
end

#! Subtract two 128-bit integers (little-endian u32 limbs) and assert no underflow.
#!
#! Computes:
#!     z = x - y
#! with the constraint:
#!     y <= x
#!
#! Inputs:  [y0, y1, y2, y3, x0, x1, x2, x3]
#! Outputs: [z0, z1, z2, z3]
#!
#! Panics if:
#!   - y > x  (ERR_UNDERFLOW)
proc u128_sub_no_underflow
    # Put x-word on top for easier access.
    swapw
    # => [x0, x1, x2, x3, y0, y1, y2, y3]

    # ---------------------------------------------------------------------------------------------
    # Low 64 bits: (x1,x0) - (y1,y0)
    # Arrange args for u64::overflowing_sub as:
    #   [y1, y0, x1, x0]
    # ---------------------------------------------------------------------------------------------
    swap
    # => [x1, x0, x2, x3, y0, y1, y2, y3]

    movup.5
    movup.5
    swap
    # => [y1, y0, x1, x0, x2, x3, y2, y3]

    exec.u64::overflowing_sub
    # => [borrow_low, z1, z0, x2, x3, y2, y3]

    # ---------------------------------------------------------------------------------------------
    # High 64 bits (raw): (x3,x2) - (y3,y2)
    # Arrange args as:
    #   [y3, y2, x3, x2]
    # ---------------------------------------------------------------------------------------------
    movup.3
    movup.4
    # => [x3, x2, borrow_low, z1, z0, y2, y3]

    movup.6
    movup.6
    swap
    # => [y3, y2, x3, x2, borrow_low, z1, z0]

    exec.u64::overflowing_sub
    # => [underflow_high_raw, t_hi, t_lo, borrow_low, z1, z0]

    # ---------------------------------------------------------------------------------------------
    # Apply propagated borrow from low 64-bit subtraction:
    #   (t_hi,t_lo) - borrow_low
    # ---------------------------------------------------------------------------------------------
    swap.3
    push.0
    exec.u64::overflowing_sub
    # => [underflow_high_borrow, z3, z2, underflow_high_raw, z1, z0]

    # Underflow iff either high-half step underflowed.
    movup.3 or
    assertz.err=ERR_UNDERFLOW
    # => [z3, z2, z1, z0]

    # Return little-endian limbs.
    exec.word::reverse
    # => [z0, z1, z2, z3]
end

#! Verify conversion from an AggLayer U256 amount to a Miden native amount (Felt)
#!
#! Specification:
#!     Verify that a provided y is the quotient of dividing x by 10^scale_exp:
#!         y = floor(x / 10^scale_exp)
#!
#! This procedure does NOT perform division. It proves the quotient is correct by checking:
#!   1) y is within the allowed fungible token amount range
#!   2) y_scaled = y * 10^scale_exp          (computed via scale_native_amount_to_u256)
#!   3) z        = x - y_scaled              (must not underflow, i.e. y_scaled <= x)
#!   4) z fits in 64 bits                    (upper 192 bits are zero)
#!   5) (z1, z0) < 10^scale_exp              (remainder bound)
#!
#! These conditions prove:
#!     x = y_scaled + z, with 0 <= z < 10^scale_exp
#! which uniquely implies:
#!     y = floor(x / 10^scale_exp)
#!
#! Example (ETH -> Miden base 1e8):
#!   - EVM amount:   100 ETH = 100 * 10^18
#!   - Miden amount: 100 ETH = 100 * 10^8
#!   - Therefore the scale-down factor is:
#!         scale = 10^(18 - 8) = 10^10
#!         scale_exp = 10
#!   - Inputs/expected values:
#!         x        = 100 * 10^18
#!         y        = floor(x / 10^10) = 100 * 10^8
#!         y_scaled = y * 10^10 = 100 * 10^18
#!         z        = x - y_scaled = 0
#!
#! NOTE: For efficiency, this verifier enforces x < 2^128 by requiring x4..x7 == 0.
#!
#! Inputs:  [x0, x1, x2, x3, x4, x5, x6, x7, scale_exp, y]
#!          Where x is encoded as 8 u32 limbs in little-endian order.
#!          (x0 is least significant limb and is at the top of the stack)
#! Outputs: [y]
#!
#! Where:
#!   - x: The original AggLayer amount as an unsigned 256-bit integer (U256).
#!        It is provided on the operand stack as 8 little-endian u32 limbs:
#!          x = x0 + x1·2^32 + x2·2^64 + x3·2^96 + x4·2^128 + x5·2^160 + x6·2^192 + x7·2^224
#!   - x0..x7: 32-bit limbs of x in little-endian order (x0 is least significant).
#!   - scale_exp: The base-10 exponent used for scaling down (an integer in [0, 18]).
#!   - y: The provided quotient (Miden native amount) as a Felt interpreted as an unsigned u64.
#!   - y_scaled: The 256-bit value y * 10^scale_exp represented as 8 u32 limbs (little-endian).
#!   - z: The remainder-like difference z = x - y_scaled. This verifier requires z < 10^scale_exp.
#!
#! Panics if:
#! - scale_exp > 18
#! - y exceeds the max fungible token amount
#! - x does not fit into 128 bits (x4..x7 are not all zero)
#! - x < y * 10^scale_exp (underflow)
#! - z does not fit in 64 bits
#! - (z1, z0) >= 10^scale_exp (remainder too large)
pub proc verify_u256_to_native_amount_conversion
    # =============================================================================================
    # Step 0: Enforce x < 2^128
    #   Constraint: x4 == x5 == x6 == x7 == 0
    # =============================================================================================
    swapw
    exec.word::eqz
    assert.err=ERR_X_TOO_LARGE
    # => [x0, x1, x2, x3, scale_exp, y]

    # =============================================================================================
    # Step 1: Enforce y <= MAX_FUNGIBLE_TOKEN_AMOUNT
    #   Constraint: y <= MAX_FUNGIBLE_TOKEN_AMOUNT
    # =============================================================================================
    dup.5
    exec.asset::get_fungible_asset_max_amount
    lte
    # => [is_lte, x0, x1, x2, x3, scale_exp, y]

    assert.err=ERR_Y_TOO_LARGE
    # => [x0, x1, x2, x3, scale_exp, y]

    # =============================================================================================
    # Step 2: Compute y_scaled = y * 10^scale_exp
    #
    # Call:
    #   scale_native_amount_to_u256(amount=y, target_scale=scale_exp)
    # =============================================================================================
    movup.4
    movup.5
    # => [y, scale_exp, x0, x1, x2, x3]

    dup.1 dup.1
    # => [y, scale_exp, y, scale_exp, x0, x1, x2, x3]

    exec.scale_native_amount_to_u256
    # => [y_scaled0..y_scaled7, y, scale_exp, x0, x1, x2, x3]

    # Because x < 2^128, require y_scaled < 2^128 as well by ensuring the upper word is zero.
    swapw
    exec.word::eqz
    assert.err=ERR_UNDERFLOW
    # => [y_scaled0, y_scaled1, y_scaled2, y_scaled3, y, scale_exp, x0, x1, x2, x3]

    # =============================================================================================
    # Step 3: Compute z = x - y_scaled and prove no underflow
    #   z := x - y_scaled
    #   Constraint: y_scaled <= x
    # =============================================================================================
    movup.5 movup.5
    # => [y, scale_exp, y_scaled0, y_scaled1, y_scaled2, y_scaled3, x0, x1, x2, x3]
 
    movdn.9 movdn.9
    # => [y_scaled0, y_scaled1, y_scaled2, y_scaled3, x0, x1, x2, x3, y, scale_exp]

    exec.u128_sub_no_underflow
    # => [z0, z1, z2, z3, y, scale_exp]

    # =============================================================================================
    # Step 4: Enforce z fits in 64 bits
    #   z = z0 + z1·2^32 + z2·2^64 + z3·2^96
    #   Constraint: z2 == 0 and z3 == 0
    # =============================================================================================
    exec.word::reverse
    # => [z3, z2, z1, z0, y, scale_exp]

    assertz.err=ERR_REMAINDER_TOO_LARGE   # z3 == 0
    assertz.err=ERR_REMAINDER_TOO_LARGE   # z2 == 0
    # => [z1, z0, y, scale_exp]

    # =============================================================================================
    # Step 5: Enforce (z1, z0) < 10^scale_exp
    # =============================================================================================
    movup.3
    exec.pow10
    # => [scale, z1, z0, y]

    u32split
    # => [scale_hi, scale_lo, z1, z0, y]

    exec.u64::lt
    # => [is_lt, y]

    assert.err=ERR_REMAINDER_TOO_LARGE
    # => [y]
end

# TODO: Rm & use verify_u256_to_native_amount_conversion
pub proc verify_u256_to_native_amount_conversion_stubbed
    repeat.7 drop end
end
