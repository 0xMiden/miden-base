use miden::core::crypto::hashes::keccak256
use miden::core::word

#! Given the leaf data returns the leaf value.
#!
#! Inputs:  [leaf_type, origin_network, ORIGIN_ADDRESS, destination_network, DESTINATION_ADDRESS, amount, METADATA_HASH]
#! Outputs: [LEAF_VALUE]
#!
#! Where:
#! - leaf_type is the leaf type: [0] transfer Ether / ERC20 tokens, [1] message.
#! - origin_network is the origin network identifier.
#! - ORIGIN_ADDRESS is the origin token address (5 elements)
#! - destination_network is the destination network identifier.
#! - DESTINATION_ADDRESS is the destination address (5 elements).
#! - amount is the amount: [0] Amount of tokens/ether, [1] Amount of ether.
#! - METADATA_HASH is the hash of the metadata (8 elements).
#! - LEAF_VALUE is the computed leaf value (8 elements).
#!
#! This function computes the keccak256 hash of the abi.encodePacked data.
#!
#! Invocation: exec
pub proc get_leaf_value
    # TODO: implement getLeafValue()
    # https://github.com/agglayer/agglayer-contracts/blob/e468f9b0967334403069aa650d9f1164b1731ebb/contracts/v2/lib/DepositContractV2.sol#L22

    # stubbed out:
    push.1.1.1.1
    push.1.1.1.1
    
    # exec.keccak256::hash_bytes
    # => [LEAF_VALUE[8]]
end

#! Verify leaf and checks that it has not been claimed.
#!
#! This procedure verifies that a claim proof is valid against the Global Exit Tree (GET)
#! and that the leaf has not been previously claimed.
#!
#! Inputs:
#!   Operand stack: [GER_ROOT[8], CLAIM_PROOF_RPO_COMMITMENT, pad(12)]
#!   Advice map: {
#!     PROOF_DATA_KEY => [
#!       smtProofLocalExitRoot[256],      // SMT proof for local exit root (256 felts, bytes32[_DEPOSIT_CONTRACT_TREE_DEPTH])
#!       smtProofRollupExitRoot[256],     // SMT proof for rollup exit root (256 felts, bytes32[_DEPOSIT_CONTRACT_TREE_DEPTH])
#!       globalIndex[8],                  // Global index (8 felts, uint256 as 8 u32 felts)
#!       mainnetExitRoot[8],              // Mainnet exit root hash (8 felts, bytes32 as 8 u32 felts)
#!       rollupExitRoot[8],               // Rollup exit root hash (8 felts, bytes32 as 8 u32 felts)
#!     ],
#!     LEAF_DATA_KEY => [
#!       originNetwork[1],                // Origin network identifier (1 felt, uint32)
#!       originTokenAddress[5],           // Origin token address (5 felts, address as 5 u32 felts)
#!       destinationNetwork[1],           // Destination network identifier (1 felt, uint32)
#!       destinationAddress[5],           // Destination address (5 felts, address as 5 u32 felts)
#!       amount[8],                       // Amount of tokens (8 felts, uint256 as 8 u32 felts)
#!       metadata[8],                     // ABI encoded metadata (8 felts, fixed size)
#!       EMPTY_WORD                       // padding
#!     ],
#!   }
#! Outputs:
#!   Operand stack: [is_valid]
#!
#! Where:
#! - RPO_CLAIM_NOTE_INPUTS_COMMITMENT is the RPO hash commitment of all claim note inputs
#! - leafType is the leaf type: [0] transfer Ether / ERC20 tokens, [1] message
#! - originNetwork is the origin network identifier (u32 as Felt)
#! - originAddress is the origin address (5 felts representing address)
#! - destinationNetwork is the destination network identifier (u32 as Felt)
#! - destinationAddress is the destination address (5 felts representing address)
#! - amount is the amount of tokens (u256 as Felt)
#! - metadata is the metadata (4 felts representing 4 u32 0 values)
#! - index is the index of the leaf (u32 as Felt)
#! - claimRoot is the claim root (8 felts representing bytes32)
#! - smtProof is the SMT proof data (570 felts)
#! - is_valid is 1 if the leaf is valid and not claimed, 0 otherwise
#!
#! Invocation: exec
pub proc verify_claim_proof
    # TODO: Implement actual Global Exit Tree proof verification
    
    # For now, drop all inputs and return 1 (valid)
    dropw dropw dropw dropw
    push.1
end
