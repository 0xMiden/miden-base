use miden::core::crypto::hashes::keccak256
use miden::core::mem

const LEAF_DATA_BYTES = 113
const LEAF_DATA_NUM_WORDS = 8
const LEAF_DATA_START_PTR = 0

#! Given the leaf data key returns the leaf value.
#!
#! Inputs:
#!   Operand stack: [LEAF_DATA_KEY]
#!   Advice map: {
#!     LEAF_DATA_KEY => [
#!       originNetwork[1],                // Origin network identifier (1 felt, uint32)
#!       originTokenAddress[5],           // Origin token address (5 felts, address as 5 u32 felts)
#!       destinationNetwork[1],           // Destination network identifier (1 felt, uint32)
#!       destinationAddress[5],           // Destination address (5 felts, address as 5 u32 felts)
#!       amount[8],                       // Amount of tokens (8 felts, uint256 as 8 u32 felts)
#!       metadata[8],                     // ABI encoded metadata (8 felts, fixed size)
#!     ],
#!   }
#! Outputs: [LEAF_VALUE[8]]
#!
#! Invocation: exec
pub proc get_leaf_value
    adv.push_mapval
    # => [LEAF_DATA_KEY]

    push.LEAF_DATA_START_PTR push.LEAF_DATA_NUM_WORDS
    exec.mem::pipe_preimage_to_memory drop
    # => []

    push.LEAF_DATA_BYTES push.LEAF_DATA_START_PTR
    # => [start_ptr, byte_len]

    exec.keccak256::hash_bytes
    # => [LEAF_VALUE[8]]

    # truncate stack
    swapdw dropw dropw
    # => [LEAF_VALUE[8]]
end

#! Computes the Global Exit Tree (GET) root from the mainnet and rollup exit roots.
#!
#! The mainnet exit root is expected at `exit_roots_ptr` and
#! the rollup exit root is expected at `exit_roots_ptr + 8`.
#!
#! Inputs: [exit_roots_ptr]
#! Outputs: [GER_ROOT[8]]
#!
#! Invocation: exec
pub proc compute_ger
    push.64 swap
    # => [exit_roots_ptr, len_bytes]
    exec.keccak256::hash_bytes
    # => [GER_ROOT[8]]
end

#! Verifies a Merkle proof for a leaf value against a root.
#!
#! Inputs:  [smt_proof_ptr, leaf_index, LEAF_VALUE[8], root_ptr]
#! Outputs: []
#!
pub proc verify_merkle_proof
    # TODO pending https://github.com/0xMiden/miden-base/issues/2278
    drop
    drop
    dropw dropw
    drop
end
