use miden::core::crypto::hashes::keccak256

const LEAF_DATA_BYTES = 113

#! Given the leaf data key returns the leaf value.
#!
#! Inputs:
#!   Operand stack: [LEAF_DATA_KEY]
#!   Advice map: {
#!     LEAF_DATA_KEY => [
#!       originNetwork[1],                // Origin network identifier (1 felt, uint32)
#!       originTokenAddress[5],           // Origin token address (5 felts, address as 5 u32 felts)
#!       destinationNetwork[1],           // Destination network identifier (1 felt, uint32)
#!       destinationAddress[5],           // Destination address (5 felts, address as 5 u32 felts)
#!       amount[8],                       // Amount of tokens (8 felts, uint256 as 8 u32 felts)
#!       metadata[8],                     // ABI encoded metadata (8 felts, fixed size)
#!       EMPTY_WORD                       // padding
#!     ],
#!   }
#! Outputs: [LEAF_VALUE]
#!
#! Invocation: exec
pub proc get_leaf_value

    adv.push_mapval
    # => [len, LEAF_DATA_KEY]

    dropw
    # => []

    # @dev what should the starting mem ptr be?
    # writing AdviceStack into memory starting at mem address 0
    push.0
    repeat.7
        # => [loc_ptr]

        padw
        # => [EMPTY_WORD, loc_ptr]

        adv_loadw
        # => [VALS, loc_ptr]
        
        movup.4 dup movdn.5
        # => [loc_ptr, VALS, loc_ptr]

        mem_storew_be dropw
        # => [loc_ptr]

        add.4
        # => [loc_ptr+4]
    end
    # => [loc_ptr]

    adv_push.1 swap
    # => [loc_ptr, data]

    mem_store
    # => []

    push.LEAF_DATA_BYTES.0
    # => [mem_ptr, len_bytes]

    exec.keccak256::hash_bytes
    # => [LEAF_VALUE[8]]
end

#! Verify leaf and checks that it has not been claimed.
#!
#! This procedure verifies that a claim proof is valid against the Global Exit Tree (GET)
#! and that the leaf has not been previously claimed.
#!
#! Inputs:
#!   Operand stack: [GER_ROOT[8], PROOF_DATA_KEY, LEAF_DATA_KEY, pad(12)]
#!   Advice map: {
#!     PROOF_DATA_KEY => [
#!       smtProofLocalExitRoot[256],      // SMT proof for local exit root (256 felts, bytes32[_DEPOSIT_CONTRACT_TREE_DEPTH])
#!       smtProofRollupExitRoot[256],     // SMT proof for rollup exit root (256 felts, bytes32[_DEPOSIT_CONTRACT_TREE_DEPTH])
#!       globalIndex[8],                  // Global index (8 felts, uint256 as 8 u32 felts)
#!       mainnetExitRoot[8],              // Mainnet exit root hash (8 felts, bytes32 as 8 u32 felts)
#!       rollupExitRoot[8],               // Rollup exit root hash (8 felts, bytes32 as 8 u32 felts)
#!     ],
#!     LEAF_DATA_KEY => [
#!       originNetwork[1],                // Origin network identifier (1 felt, uint32)
#!       originTokenAddress[5],           // Origin token address (5 felts, address as 5 u32 felts)
#!       destinationNetwork[1],           // Destination network identifier (1 felt, uint32)
#!       destinationAddress[5],           // Destination address (5 felts, address as 5 u32 felts)
#!       amount[8],                       // Amount of tokens (8 felts, uint256 as 8 u32 felts)
#!       metadata[8],                     // ABI encoded metadata (8 felts, fixed size)
#!       EMPTY_WORD                       // padding
#!     ],
#!   }
#! Outputs:
#!   Operand stack: [is_valid]
#!
#! Where:
#! - RPO_CLAIM_NOTE_INPUTS_COMMITMENT is the RPO hash commitment of all claim note inputs
#! - leafType is the leaf type: [0] transfer Ether / ERC20 tokens, [1] message
#! - originNetwork is the origin network identifier (u32 as Felt)
#! - originAddress is the origin address (5 felts representing address)
#! - destinationNetwork is the destination network identifier (u32 as Felt)
#! - destinationAddress is the destination address (5 felts representing address)
#! - amount is the amount of tokens (u256 as Felt)
#! - metadata is the metadata (4 felts representing 4 u32 0 values)
#! - index is the index of the leaf (u32 as Felt)
#! - claimRoot is the claim root (8 felts representing bytes32)
#! - smtProof is the SMT proof data (570 felts)
#! - is_valid is 1 if the leaf is valid and not claimed, 0 otherwise
#!
#! Invocation: exec
pub proc verify_claim_proof
    # TODO: Implement actual Global Exit Tree proof verification
    
    # For now, drop all inputs and return 1 (valid)
    dropw dropw dropw dropw
    push.1
end

