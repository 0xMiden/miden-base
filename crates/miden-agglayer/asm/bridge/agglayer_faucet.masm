use miden::agglayer::bridge_in
use miden::protocol::active_account
use miden::protocol::active_note
use miden::standards::faucets
use miden::protocol::note
use miden::protocol::tx
use miden::core::mem


# CONSTANTS
# =================================================================================================

# The slot in this component's storage layout where the bridge account ID is stored.
const BRIDGE_ID_SLOT = word("miden::agglayer::faucet")

const P2ID_NOTE_NUM_INPUTS = 2
const OUTPUT_NOTE_TYPE_PUBLIC = 1
const EXECUTION_HINT_ALWAYS = 1
const OUTPUT_NOTE_AUX = 0

const OUTPUT_NOTE_INPUTS_MEM_ADDR = 0
const OUTPUT_NOTE_TAG_MEM_ADDR = 570
const OUTPUT_NOTE_SERIAL_NUM_MEM_ADDR = 564
const OUTPUT_NOTE_ASSET_AMOUNT_MEM_ADDR_0 = 548
const OUTPUT_NOTE_ASSET_AMOUNT_MEM_ADDR_1 = 552

const P2ID_SCRIPT_ROOT = [7588674509004260508, 4058706621878288170, 5607159951796201570, 5541281552524512743]

const P2ID_OUTPUT_NOTE_AMOUNT_MEM_PTR = 611
# ERRORS
# =================================================================================================

const ERR_INVALID_CLAIM_PROOF = "invalid claim proof"

#! Validates a CLAIM note by verifying its inputs against a GER against the AggLayer bridge.
#!
#! This procedure performs a foreign procedure invocation (FPI) to the configured
#! AggLayer bridge account to verify its claim data (asset, amount, recipient) inclusion against
#! one of the Global Exit Roots in the bridge storage.
#!
#! Inputs:  [CLAIM_NOTE_RPO_COMMITMENT]
#! Outputs: []
#!
#! Panics if:
#! - the bridge account ID is not properly configured in storage.
#! - the foreign procedure invocation fails.
#! - the claim proof validation fails.
#!
#! Invocation: exec
proc validate_claim
    # Check AdviceMap was not tampered with
    adv.push_mapval
    # => [CLAIM_NOTE_RPO_COMMITMENT]

    push.0 push.144
    # => [num_words, write_ptr, CLAIM_NOTE_RPO_COMMITMENT]

    # Validate CLAIM_NOTE_RPO_COMMITMENT is valid commitment to CLAIM data in AdviceMap
    # Will panic if CLAIM_NOTE_RPO_COMMITMENT is not hash of data in AdviceMap 
    exec.mem::pipe_double_words_preimage_to_memory drop
    # => []

    # Get bridge_in::check_claim_proof procedure MAST root
    procref.bridge_in::check_claim_proof
    # => [BRIDGE_PROC_MAST_ROOT]

    push.BRIDGE_ID_SLOT[0..2]
    # => [bridge_id_idx, BRIDGE_PROC_MAST_ROOT]

    # Get Bridge AccountId
    exec.active_account::get_item
    # => [bridge_account_id_prefix, bridge_account_id_suffix, 0, 0, BRIDGE_PROC_MAST_ROOT]

    movup.2 drop movup.2 drop
    # => [bridge_account_id_prefix, bridge_account_id_suffix, BRIDGE_PROC_MAST_ROOT]

    # Call check_claim_proof procedure on Bridge
    # Calling: bridge_in::check_claim_proof
    exec.tx::execute_foreign_procedure
    # => [validation_result]

    # Assert valid proof data
    assert.err=ERR_INVALID_CLAIM_PROOF drop
    # => []
end

# Inputs: []
# Outputs: [U256[0], U256[1]]
proc get_raw_claim_amount
    padw mem_loadw_be.OUTPUT_NOTE_ASSET_AMOUNT_MEM_ADDR_0
    padw mem_loadw_be.OUTPUT_NOTE_ASSET_AMOUNT_MEM_ADDR_1
end

# Inputs: [U256[0], U256[1]]
# Outputs: [amount]
proc scale_down_amount
    repeat.7 drop end
end

# Inputs: []
# Outputs: [prefix, suffix]
proc get_destination_account_id
    mem_load.543 mem_load.544
end

#! Validates a CLAIM note against the AggLayer bridge and mints the corresponding asset to the recipient.
#!
#! This procedure validates the rollup exit root Merkle Proof via FPI against the agglayer bridge,
#! and if validation passes, mints the asset and creates an output note for the recipient.
#!
#! Inputs:  [CLAIM_NOTE_RPO_COMMITMENT, pad(12)]
#! Outputs: [pad(16)]
#!
#! Where:
#! - MERKLE_PATH_RPO_COMMITMENT: RPO hash of the MERKLE_PATH_COMMITMENT[8] of the merkle proof data
#!
#! This procedure validates the rollup exit root Merkle Proof via FPI against the agglayer bridge,
#! and if validation passes, mints the asset and creates an output note for the recipient.
#!
#! Panics if:
#! - the rollup exit root Merkle Proof validation via FPI fails.
#! - any of the validations in faucets::distribute fail.
#!
#! Invocation: call
pub proc claim
    # Validate claim proof (stubbed out)
    exec.validate_claim
    # => [CLAIM_NOTE_RPO_COMMITMENT, pad(12)]

    # Build P2ID output note
    push.P2ID_SCRIPT_ROOT[0..4]
    # => [SCRIPT_ROOT, pad(16)]

    swapw mem_loadw_be.OUTPUT_NOTE_SERIAL_NUM_MEM_ADDR
    # => [SERIAL_NUM, SCRIPT_ROOT, pad(12)]

    push.P2ID_NOTE_NUM_INPUTS
    # => [num_output_note_inputs, SERIAL_NUM, SCRIPT_ROOT, pad(1)]

    exec.get_destination_account_id
    # => [account_id_prefix, account_id_suffix, num_output_note_inputs, SERIAL_NUM, SCRIPT_ROOT]

    mem_store.0 mem_store.1
    # => [num_output_note_inputs, SERIAL_NUM, SCRIPT_ROOT, pad(1)]

    push.OUTPUT_NOTE_INPUTS_MEM_ADDR
    # => [inputs_ptr = 0, num_output_note_inputs, SERIAL_NUM, SCRIPT_ROOT, pad(12)]

    exec.note::build_recipient
    # => [RECIPIENT, pad(12)]
    
    push.EXECUTION_HINT_ALWAYS push.OUTPUT_NOTE_TYPE_PUBLIC push.OUTPUT_NOTE_AUX
    # => [aux, note_type, execution_hint, RECIPIENT, pad(8)] 

    mem_load.OUTPUT_NOTE_TAG_MEM_ADDR
    # => [tag, aux, execution_hint, RECIPIENT, pad(8)]

    exec.get_raw_claim_amount
    # => [AMOUNT[1], AMOUNT[0], tag, aux, note_type, execution_hint, RECIPIENT, pad(8)]

    # TODO: implement scale down logic; stubbed out for now
    exec.scale_down_amount
    # => [amount, tag, aux, note_type, execution_hint, RECIPIENT, pad(8)]

    exec.faucets::distribute
    # => [pad(16)]
end

#! Burns the fungible asset from the active note.
#!
#! This procedure retrieves the asset from the active note and burns it. The note must contain
#! exactly one asset, which must be a fungible asset issued by this faucet.
#!
#! Inputs:  [pad(16)]
#! Outputs: [pad(16)]
#!
#! Panics if:
#! - the procedure is not called from a note context (active_note::get_assets will fail).
#! - the note does not contain exactly one asset.
#! - the transaction is executed against an account which is not a fungible asset faucet.
#! - the transaction is executed against a faucet which is not the origin of the specified asset.
#! - the amount about to be burned is greater than the outstanding supply of the asset.
#!
#! Invocation: call
pub use ::miden::standards::faucets::basic_fungible::burn