use miden::core::crypto::hashes::keccak256
use miden::core::word

# CONSTANTS
# =================================================================================================

const U32_MAX=4294967295
const TWO_POW_32=4294967296

const ERR_NOT_U32="address limb is not u32"
const ERR_ADDR0_NONZERO="first 4 bytes (addr0) must be zero"
const ERR_PREFIX_OUT_OF_FIELD="prefix would wrap field modulus"
const ERR_SUFFIX_OUT_OF_FIELD="suffix would wrap field modulus"


# ETHEREUM ADDRESS PROCEDURES
# =================================================================================================

#! Hashes an Ethereum address (address[5] type) using Keccak256.
#!
#! Inputs:  [addr0, addr1, addr2, addr3, addr4]
#! Outputs: [DIGEST_U32[8]]
#!
#! Invocation: exec
pub proc account_id_to_ethereum_hash
    mem_store.0
    mem_store.1
    mem_store.2
    mem_store.3
    mem_store.4

    push.20.0
    exec.keccak256::hash_bytes
    # Stack: [DIGEST_U32[8]]
end

#! Converts an Ethereum address (address[5] type) back into an AccountId [prefix, suffix] type.
#!
#! The Ethereum address is represented as 5 u32 felts (20 bytes total) in big-endian format.
#! The first 4 bytes must be zero for a valid AccountId conversion.
#! The remaining 16 bytes are converted into two u64 values (prefix and suffix).
#!
#! Inputs:  [addr0, addr1, addr2, addr3, addr4]
#! Outputs: [prefix, suffix]
#!
#! Where:
#! - addr0..addr4 are u32 felts (big-endian) representing the 20-byte Ethereum address
#! - Each addr[i] represents 4 bytes: addr0=bytes[0..3], addr1=bytes[4..7], etc.
#! - prefix is the first u64 from bytes[4..11] = (addr1 << 32) | addr2
#! - suffix is the second u64 from bytes[12..19] = (addr3 << 32) | addr4
#!
#! Note: This procedure ensures the packed u64 values don't overflow the field modulus
#! p = 2^64 - 2^32 + 1 by checking that if the high 32 bits are 0xFFFFFFFF,
#! then the low 32 bits must be 0.
#!
#! Invocation: exec
pub proc ethereum_address_to_account_id
    # --- addr0 must be 0 ---
    u32assert.err=ERR_NOT_U32
    dup eq.0 assert.err=ERR_ADDR0_NONZERO
    drop
    # => [addr1, addr2, addr3, addr4]

    # --- validate u32 limbs (optional but nice) ---
    u32assert.err=ERR_NOT_U32              # addr1
    dup.1 u32assert.err=ERR_NOT_U32 drop   # addr2
    dup.2 u32assert.err=ERR_NOT_U32 drop   # addr3
    dup.3 u32assert.err=ERR_NOT_U32 drop   # addr4
    # => [addr1, addr2, addr3, addr4]

    # --- prefix: (addr1 << 32) | addr2 ---
    dup push.U32_MAX eq
    if.true
        dup.1 eq.0 assert.err=ERR_PREFIX_OUT_OF_FIELD
    end

    push.TWO_POW_32 mul
    add
    # => [prefix, addr3, addr4]

    # --- suffix: (addr3 << 32) | addr4 ---
    swap
    # => [addr3, prefix, addr4]

    dup push.U32_MAX eq
    if.true
        dup.2 eq.0 assert.err=ERR_SUFFIX_OUT_OF_FIELD
    end

    push.TWO_POW_32 mul
    movup.2
    add
    # => [suffix, prefix]

    swap
    # => [prefix, suffix]
end
