use miden::core::crypto::hashes::keccak256
use miden::core::word

# CONSTANTS
# =================================================================================================

const U32_MAX=4294967295
const TWO_POW_32=4294967296

const ERR_NOT_U32="address limb is not u32"
const ERR_ADDR4_NONZERO="most-significant 4 bytes (addr4) must be zero"
const ERR_FELT_OUT_OF_FIELD="combined u64 doesn't fit in field"


# ETHEREUM ADDRESS PROCEDURES
# =================================================================================================

#! Hashes an Ethereum address (address[5] type) using Keccak256.
#!
#! Address limb order: little-endian (addr0 is least-significant, addr4 is most-significant).
#!
#! Inputs:  [addr0, addr1, addr2, addr3, addr4]
#! Outputs: [DIGEST_U32[8]]
#!
#! Invocation: exec
pub proc account_id_to_ethereum_hash
    mem_store.0
    mem_store.1
    mem_store.2
    mem_store.3
    mem_store.4

    push.20.0
    exec.keccak256::hash_bytes
    # Stack: [DIGEST_U32[8]]
end

#! Builds a single felt from two u32 limbs (little-endian limb order).
#! Conceptually, this is packing a 64-bit word (lo + (hi << 32)) into a field element.
#! This proc additionally verifies that the packed value did *not* reduce mod p by round-tripping
#! through u32split and comparing the limbs.
#!
#! Inputs:  [lo, hi]
#! Outputs: [felt]
proc build_felt
    # --- validate u32 limbs ---
    u32assert.err=ERR_NOT_U32              # lo
    dup.1 u32assert.err=ERR_NOT_U32 drop   # hi
    # => [lo, hi]

    # keep copies for the overflow check
    dup.1 dup.1
    # => [lo, hi, lo, hi]

    # felt = (hi * 2^32) + lo
    swap
    push.TWO_POW_32 mul
    add
    # => [felt, lo, hi]

    # ensure no reduction mod p happened:
    # split felt back into (hi, lo) and compare to inputs
    dup u32split
    # => [hi2, lo2, felt, lo, hi]

    movup.4 assert_eq.err=ERR_FELT_OUT_OF_FIELD
    # => [lo2, felt, lo]

    movup.2 assert_eq.err=ERR_FELT_OUT_OF_FIELD
    # => [felt]
end

#! Converts an Ethereum address (address[5] type) back into an AccountId [prefix, suffix] type.
#!
#! The Ethereum address is represented as 5 u32 limbs (20 bytes total) in *little-endian limb order*:
#!   addr0 = bytes[16..19]  (least-significant 4 bytes)
#!   addr1 = bytes[12..15]
#!   addr2 = bytes[ 8..11]
#!   addr3 = bytes[ 4.. 7]
#!   addr4 = bytes[ 0.. 3]  (most-significant 4 bytes)
#!
#! The most-significant 4 bytes must be zero for a valid AccountId conversion (addr4 == 0).
#! The remaining 16 bytes are treated as two 8-byte words (conceptual u64 values):
#!   prefix = (addr3 << 32) | addr2   # bytes[4..11]
#!   suffix = (addr1 << 32) | addr0   # bytes[12..19]
#!
#! These 8-byte words are represented as field elements by packing two u32 limbs into a felt.
#! The packing is done via build_felt, which validates limbs are u32 and checks the packed value
#! did not reduce mod p (i.e. the word fits in the field).
#!
#! Inputs:  [addr0, addr1, addr2, addr3, addr4]
#! Outputs: [prefix, suffix]
#!
#! Invocation: exec
pub proc ethereum_address_to_account_id
    # addr4 must be 0 (most-significant limb)
    movup.4
    u32assert.err=ERR_NOT_U32
    dup eq.0 assert.err=ERR_ADDR4_NONZERO
    drop
    # => [addr0, addr1, addr2, addr3]

    exec.build_felt
    # => [suffix, addr2, addr3]

    movdn.2
    # => [addr2, addr3, suffix]

    exec.build_felt
    # => [prefix, suffix]
end
