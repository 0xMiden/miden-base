use miden::agglayer::agglayer_faucet -> agg_faucet
use miden::protocol::account_id
use miden::protocol::active_account
use miden::protocol::active_note
use miden::protocol::note
use miden::core::crypto::hashes::keccak256
use miden::core::crypto::hashes::rpo256
# CONSTANTS
# =================================================================================================

const CLAIM_NOTE_NUM_INPUTS = 571
const CLAIM_PROOF_DATA_SIZE = 564
const CLAIM_PROOF_DATA_WORDS = 570

const AGG_FAUCET_PREFIX_MEM_ADDR = 568
const AGG_FAUCET_SUFFIX_MEM_ADDR = 569

# ERRORS
# =================================================================================================

const ERR_CLAIM_TARGET_ACCT_MISMATCH = "CLAIM's target account address and transaction address do not match"
const ERR_CLAIM_WRONG_NUMBER_OF_INPUTS = "CLAIM note must have exactly 566 inputs"

# Inputs: []
# Output: []
proc assert_aggfaucet_is_consumer
    # Load agglayer faucet ID (assumes active_note::get_inputs has been called)
    mem_load.AGG_FAUCET_SUFFIX_MEM_ADDR mem_load.AGG_FAUCET_PREFIX_MEM_ADDR
    # => [agg_faucet_prefix, agg_faucet_suffix]

    exec.active_account::get_id
    # => [account_id_prefix, account_id_suffix, agg_faucet_prefix, agg_faucet_suffix]

    # ensure only the specified agglayer faucet can consume this CLAIM note, not any other account
    exec.account_id::is_equal assert.err=ERR_CLAIM_TARGET_ACCT_MISMATCH
    # => []
end

#! Agglayer Faucet CLAIM script: claims assets by calling the agglayer faucet's claim function.
#! This note is intended to be consumed by an agglayer faucet account and will create a P2ID note on consumption.
#!
#! Requires that the account exposes:
#! - agglayer::agglayer_faucet::claim procedure.
#!
#! Inputs:  [ARGS, pad(12)]
#! Outputs: [pad(16)]
#!
#! Current note inputs match exactly the agglayer claimAsset function parameters:
#!
#! NoteInputs layout (571 felts total):
#! - smtProofLocalExitRoot      [0..255]  : SMT proof for local exit root (256 felts, bytes32[_DEPOSIT_CONTRACT_TREE_DEPTH])
#! - smtProofRollupExitRoot     [256..511]: SMT proof for rollup exit root (256 felts, bytes32[_DEPOSIT_CONTRACT_TREE_DEPTH])
#! - globalIndex                [512..519]: Global index (8 felts, uint256 as 8 u32 felts)
#! - mainnetExitRoot            [520..527]: Mainnet exit root hash (8 felts, bytes32 as 8 u32 felts)
#! - rollupExitRoot             [528..535]: Rollup exit root hash (8 felts, bytes32 as 8 u32 felts)
#! - originNetwork              [536]     : Origin network identifier (1 felt, uint32)
#! - originTokenAddress         [537..541]: Origin token address (5 felts, address as 5 u32 felts)
#! - destinationNetwork         [542]     : Destination network identifier (1 felt, uint32)
#! - destinationAddress         [543..547]: Destination address (5 felts, address as 5 u32 felts)
#! - amount                     [548..555]: Amount of tokens (8 felts, uint256 as 8 u32 felts)
#! - metadata                   [556..563]: ABI encoded metadata (8 felts, fixed size)
#! - output_p2id_serial_num     [564..567]: P2ID note serial number (4 felts, Word)
#! - agglayer_faucet_account_id [568..569]: Agglayer faucet account ID (2 felts, prefix and suffix)
#! - output_note_tag            [570]     : P2ID output note tag
#!
#! Panics if:
#! - account does not expose claim procedure.
#! - the number of inputs is not exactly 571.
#! - agglayer faucet account ID does not match the consuming account ID.
begin
    dropw
    # => [pad(16)]

    # Load CLAIM note inputs
    push.0 exec.active_note::get_inputs
    # => [total_inputs, inputs_ptr, pad(16)]

    # Verify we have exactly 566 inputs
    push.CLAIM_NOTE_NUM_INPUTS eq assert.err=ERR_CLAIM_WRONG_NUMBER_OF_INPUTS drop
    # => [pad(16)]

    # Check consuming account == aggfaucet
    exec.assert_aggfaucet_is_consumer
    # => [pad(16)]

    # Overwrite Agglayer faucet AccountId in memory with 0s
    # This is to compute the CLAIM_PROOF_RPO_COMMITMENT
    mem_storew_be.AGG_FAUCET_PREFIX_MEM_ADDR
    # => [pad(16)]

    # Compute the CLAIM_PROOF_RPO_COMMITMENT of the claim proof data
    # Hash the proof data data (564 felts + four 0 felts so that word length is even)
    # 568 / 4 = 142 Word values
    # The proof data starts at memory address 0
    push.CLAIM_PROOF_DATA_SIZE add.4 push.0
    # => [start_ptr, end_ptr, pad(16)]

    exec.rpo256::hash_elements
    # => [CLAIM_PROOF_RPO_COMMITMENT, pad(16)]

    # Prepare for insertion into AdviceMap
    push.CLAIM_PROOF_DATA_SIZE add.4 push.0
    # => [start_ptr, end_ptr, CLAIM_PROOF_RPO_COMMITMENT, pad(16)]

    movdn.5 movdn.5
    # => [CLAIM_PROOF_RPO_COMMITMENT, start_ptr, end_ptr, pad(16)]

    # Insert Asset Claim Proof Data into AdviceMap
    adv.insert_mem
    # OS => [CLAIM_PROOF_RPO_COMMITMENT, start_ptr, end_ptr, pad(16)]
    # AS => {CLAIM_PROOF_RPO_COMMITMENT: mem[start_ptr..end_ptr] }

    movup.5 drop movup.5 drop
    # => [CLAIM_PROOF_RPO_COMMITMENT, pad(16)]

    # Call the Aggfaucet Claim procedure
    call.agg_faucet::claim
    # => [pad(16), pad(6)]

    dropw drop drop
    # => [pad(16)]
end

