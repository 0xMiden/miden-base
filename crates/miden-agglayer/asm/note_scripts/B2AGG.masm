use miden::agglayer::bridge_out
use miden::protocol::account_id
use miden::protocol::active_account
use miden::protocol::active_note
use miden::protocol::note
use miden::standards::attachments::network_account_target
use miden::standards::wallets::basic->basic_wallet

# CONSTANTS
# =================================================================================================

const B2AGG_NOTE_NUM_STORAGE_ITEMS=6

# ERRORS
# =================================================================================================
const ERR_B2AGG_WRONG_NUMBER_OF_ASSETS="B2AGG script requires exactly 1 note asset"
const ERR_B2AGG_UNEXPECTED_NUMBER_OF_STORAGE_ITEMS="B2AGG script expects exactly 6 note storage items"
const ERR_B2AGG_TARGET_ACCOUNT_MISMATCH="B2AGG note attachment target account does not match consuming account"


#! Bridge-to-AggLayer (B2AGG) note script: bridges assets from Miden to an AggLayer-connected chain.
#!
#! This note can be consumed in two ways:
#! - If the consuming account is the sender (reclaim): the note's assets are added back to the consuming account.
#! - If the consuming account is the Agglayer Bridge: the note's assets are moved to a BURN note,
#!   and the note details are hashed into a leaf and appended to the Local Exit Tree.
#!
#! Inputs:  []
#! Outputs: []
#!
#! Note storage is assumed to be as follows:
#! - destination_network: u32 value representing the target chain ID
#! - destination_address: split into 5 u32 values representing a 20-byte Ethereum address:
#!   - destination_address_0: bytes 0-3
#!   - destination_address_1: bytes 4-7
#!   - destination_address_2: bytes 8-11
#!   - destination_address_3: bytes 12-15
#!   - destination_address_4: bytes 16-19
#! Note attachment is constructed from a NetworkAccountTarget standard:
#! - [0, exec_hint_tag, target_id_prefix, target_id_suffix]
#!
#! Panics if:
#! - The note does not contain exactly 6 storage items.
#! - The note does not contain exactly 1 asset.
#! - The note attachment does not target the consuming account.
#!
begin
    dropw
    # => [pad(16)]

    # Check if reclaim
    exec.active_account::get_id
    # => [account_id_prefix, account_id_suffix, pad(16)]

    exec.active_note::get_sender
    # => [sender_id_prefix, sender_id_suffix, account_id_prefix, account_id_suffix, pad(16)]

    exec.account_id::is_equal
    # => [reclaim, pad(16)]

    # B2AGG note is being reclaimed; adding note assets to account
    if.true
        exec.basic_wallet::add_assets_to_account
        # => [pad(16)]
    else
        # Ensure note attachment targets the consuming bridge account.
        exec.active_note::get_metadata
        # => [NOTE_ATTACHMENT, METADATA_HEADER, pad(8)]

        exec.note::extract_attachment_info_from_metadata
        # => [attachment_kind, attachment_scheme, NOTE_ATTACHMENT, pad(8)]

        swap
        # => [attachment_scheme, attachment_kind, NOTE_ATTACHMENT, pad(8)]

        exec.network_account_target::get_id
        # => [target_id_prefix, target_id_suffix, pad(14)]

        exec.active_account::get_id
        # => [account_id_prefix, account_id_suffix, target_id_prefix, target_id_suffix, pad(14)]

        exec.account_id::is_equal
        assert.err=ERR_B2AGG_TARGET_ACCOUNT_MISMATCH
        # => [pad(16)]

        # Store note storage -> mem[8..14]
        push.8 exec.active_note::get_storage
        # => [num_storage_items, dest_ptr, pad(16)]

        push.B2AGG_NOTE_NUM_STORAGE_ITEMS assert_eq.err=ERR_B2AGG_UNEXPECTED_NUMBER_OF_STORAGE_ITEMS drop
        # => [pad(16)]

        # Store note assets -> mem[0..4]
        push.0 exec.active_note::get_assets
        # => [num_assets, ptr, pad(16)]

        # Must be exactly 1 asset
        push.1 assert_eq.err=ERR_B2AGG_WRONG_NUMBER_OF_ASSETS drop
        # => [pad(16)]

        # load the 6 B2AGG felts from note storage as two words
        mem_loadw_be.12 swapw.2 mem_loadw_be.8 swapw
        # => [EMPTY_WORD, dest_network, dest_address(5), pad(6)]

        # Load ASSET onto the stack
        mem_loadw_be.0
        # => [ASSET, dest_network, dest_address(5), pad(6)]

        call.bridge_out::bridge_out
        # => [pad(16)]
    end
    # => [pad(16)]
end
