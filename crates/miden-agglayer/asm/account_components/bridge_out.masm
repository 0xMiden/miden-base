use miden::protocol::active_note
use miden::protocol::note
use miden::protocol::output_note
use miden::core::crypto::hashes::keccak256
use miden::core::word
use agglayer::local_exit_tree

# CONSTANTS
# =================================================================================================
const MMR_PTR=42
const LOCAL_EXIT_TREE_SLOT=word("miden::agglayer::let")

const BURN_NOTE_ROOT = [6407337173854817345, 5626358912819151014, 703918618794810515, 17401169215223723177]
const EXECUTION_HINT_ALWAYS=1
const PUBLIC_NOTE=1
const AUX=0
const NUM_BURN_NOTE_INPUTS=0
const BURN_ASSET_MEM_PTR=24

#! Computes the SERIAL_NUM of the outputted BURN note.
#!
#! The serial number is computed as hash(B2AGG_SERIAL_NUM, ASSET).
#!
#! Inputs:  [ASSET]
#! Outputs: [SERIAL_NUM]
#!
#! Where:
#! - ASSET is the asset for which to compute the burn note serial number.
#! - SERIAL_NUM is the computed serial number for the BURN note.
#!
#! Invocation: exec
proc compute_burn_note_serial_num
    exec.active_note::get_serial_number
    # => [B2AGG_SERIAL_NUM, ASSET]

    hmerge
    # => [SERIAL_NUM]
end

#! Creates a BURN note for the specified asset.
#!
#! This procedure creates an output note that represents a burn operation for the given asset.
#! The note is configured with the appropriate recipient, tag, and execution hint.
#!
#! Inputs:  [ASSET]
#! Outputs: []
#!
#! Where:
#! - ASSET is the asset to be burned.
#!
#! Invocation: exec
@locals(8)
proc create_burn_note
    loc_storew_be.0 dupw
    # => [ASSET, ASSET]

    movup.2 drop movup.2 drop
    # => [faucet_id_prefix, faucet_id_suffix, ASSET]

    exec.note::build_note_tag_for_network_account
    # => [network_faucet_tag, ASSET]

    loc_store.5
    # => [ASSET]

    exec.compute_burn_note_serial_num
    # => [SERIAL_NUM]

    push.BURN_NOTE_ROOT swapw
    # => [SERIAL_NUM, SCRIPT_ROOT]

    push.NUM_BURN_NOTE_INPUTS push.0
    # => [inputs_ptr, num_inputs, SERIAL_NUM, SCRIPT_ROOT]

    exec.note::build_recipient
    # => [RECIPIENT]

    push.EXECUTION_HINT_ALWAYS
    push.PUBLIC_NOTE
    push.AUX
    loc_load.5
    # => [tag, aux, note_type, execution_hint, RECIPIENT]

    call.output_note::create
    # => [note_idx]

    movdn.4 loc_loadw_be.0
    # => [ASSET, note_idx]

    exec.output_note::add_asset
    # => []
end

#! Bridges an asset out via the AggLayer
#!
#! This procedure handles the complete bridge-out operation, including:
#! - Converting asset data to u32 format
#! - Computing Keccak hash of the data
#! - Adding the hash to the MMR frontier
#! - Storing the updated MMR root in account storage
#! - Creating a BURN note with the bridged out asset
#!
#! Inputs:  [ASSET, dest_network, dest_address(5)]
#! Outputs: []
#!
#! Where:
#! - ASSET is the asset to be bridged out.
#! - dest_network is the u32 destination network/chain ID.
#! - dest_address(5) are 5 u32 values representing a 20-byte Ethereum address.
#!
#! Invocation: call
pub proc bridge_out
    mem_storew_be.BURN_ASSET_MEM_PTR
    # => [ASSET, dest_network, dest_address(5)]

    # @dev TODO: Look up asset faucet id in asset registry
    # -> return scaling factor

    # @dev TODO: Convert ASSET amount to EVM amount using scaling factor
    # -> return amount from here: https://github.com/0xMiden/miden-base/pull/2141

    # Converting SCALED_ASSET, dest_network, dest_address(5) to u32 representation
    # in preparation for keccak256 hashing

    # keccak256 inputs:
    # => [ASSET, dest_network, dest_address(5)]
    # TODO we should convert Miden->Ethereum asset values, incl. amount conversion etc.

    # TODO: make building bridge message a separate procedure
    # TODO: match Agglayer addLeafBridge logic
    # TODO: convert Miden asset amount to Ethereum amount
    # Store ASSET as u32 limbs in memory starting at address 0
    push.0 movdn.4 exec.word::store_word_u32s_le
    # => [dest_network, dest_address(5)]

    # Store [dest_network, dest_address[0..3]] as u32 limbs in memory starting at address 8
    push.8 movdn.4 exec.word::store_word_u32s_le
    # => [dest_address(2), 0, 0]

    # Store [dest_address[3..5], 0, 0] as u32 limbs in memory starting at address 16
    push.16 movdn.4 exec.word::store_word_u32s_le
    # => []

    # 1 u32 = 4 bytes
    # 10 u32 values = 40 bytes
    push.40 push.0
    # => [ptr, len_bytes]

    exec.keccak256::hash_bytes
    # => [DIGEST_U32[8]]

    # adding DIGEST_U32 double word leaf to mmr frontier
    exec.local_exit_tree::add_asset_message
    # => []

    # creating BURN output note for ASSET
    mem_loadw_be.BURN_ASSET_MEM_PTR
    # => [ASSET]

    exec.create_burn_note
    # => []
end
