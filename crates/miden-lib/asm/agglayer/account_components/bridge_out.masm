use.miden::active_account
use.miden::active_note
use.miden::native_account
use.miden::note
use.miden::output_note
use.std::math::u64
use.std::sys

use std::crypto::hashes::keccak256

const.MMR_PTR=42
const.STORAGE_MAP_INDEX=0

const.BURN_NOTE_ROOT=[6407337173854817345,5626358912819151014,703918618794810515,17401169215223723177]
const.EXECUTION_HINT_ALWAYS=1
const.PUBLIC_NOTE=1
const.AUX=0
const.NUM_BURN_NOTE_INPUTS=0
const.BURN_ASSET_MEM_PTR=24

#! Computes the SERIAL_NUM of the outputted BURN note.
#!
#! The serial number is computed as hash(B2AGG_SERIAL_NUM, ASSET).
#!
#! Inputs:  [ASSET]
#! Outputs: [SERIAL_NUM]
#!
#! Where:
#! - ASSET is the asset for which to compute the burn note serial number.
#! - SERIAL_NUM is the computed serial number for the BURN note.
#!
#! Invocation: exec
proc compute_burn_note_serial_num
    exec.active_note::get_serial_number
    # => [B2AGG_SERIAL_NUM, ASSET]

    hmerge
    # => [SERIAL_NUM]
end

#! Creates a BURN note for the specified asset.
#!
#! This procedure creates an output note that represents a burn operation for the given asset.
#! The note is configured with the appropriate recipient, tag, and execution hint.
#!
#! Inputs:  [ASSET]
#! Outputs: []
#!
#! Where:
#! - ASSET is the asset to be burned.
#!
#! Invocation: exec
proc create_burn_note.8
    loc_storew_be.0 dupw
    # => [ASSET]

    exec.note::build_note_tag_for_network_account
    # => [network_faucet_tag, ASSET]

    loc_store.5
    # => [ASSET]

    exec.compute_burn_note_serial_num
    # => [SERIAL_NUM]

    push.BURN_NOTE_ROOT swapw
    # => [SERIAL_NUM, SCRIPT_ROOT]

    push.NUM_BURN_NOTE_INPUTS push.0
    # => [inputs_ptr, num_inputs, SERIAL_NUM, SCRIPT_ROOT]

    exec.note::build_recipient
    # => [RECIPIENT]

    push.EXECUTION_HINT_ALWAYS
    push.PUBLIC_NOTE
    push.AUX
    loc_load.5
    # => [tag, aux, note_type, execution_hint, RECIPIENT]

    call.output_note::create
    # => [note_idx, 0,0,0]

    padw loc_loadw_be.0
    # => [ASSET, note_idx, 0,0,0]

    exec.output_note::add_asset
    # => [REQUESTED_ASSET, note_idx, 0,0,0]

    dropw dropw
    # => []
end

#! @dev TODO: once miden-vm `0.19.0` is released remove this procedure and import it instead
#! https://github.com/0xMiden/miden-vm/blob/190480c5b441af5b3aeab1aa4085e0d6424924b3/libcore/asm/word.masm#L27
#!
#! Writes the components of a word to memory as eight u32 limbs in little-endian order.
#!
#! Inputs:  [w3, w2, w1, w0, out_ptr, ...]
#! Outputs: [...]
#!
#! Where:
#! - `w*` are the felts of the input word. Each felt is split into a low and high 32-bit limb.
#! - `out_ptr` is an element address in memory.
#! - Memory layout after the call: `[w0_lo, w0_hi, w1_lo, w1_hi, w2_lo, w2_hi, w3_lo, w3_hi]`.
#!
#! Cycles: 8 * (split + store pair) ~= 176
pub proc store_word_u32s_le
    reversew
    # => [w0, w1, w2, w3, out_ptr, ...]

    u32split
    # => [w0_hi, w0_lo, w1, w2, w3, out_ptr, ...]

    movup.2 u32split
    # => [w1_hi, w1_lo, w0_hi, w0_lo, w2, w3, out_ptr, ...]

    # Store w0 and w1 limbs, then drop them from the stack
    dup.6 mem_storew_be dropw
    # => [w2, w3, out_ptr, ...]

    u32split
    # => [w2_hi, w2_lo, w3, out_ptr, ...]

    movup.2 u32split
    # => [w3_hi, w3_lo, w2_hi, w2_lo, out_ptr, ...]

    # Store w2 and w3 limbs at out_ptr+4
    movup.4 add.4 mem_storew_be dropw
    # => [...]
end

#! Adds a leaf to the MMR frontier using Keccak hashing (stubbed implementation).
#!
#! This is a stubbed implementation that currently drops all inputs without performing
#! the actual MMR frontier addition operation.
#!
#! Inputs:  [LEAF[1], LEAF[0], mmr_ptr]
#! Outputs: []
#!
#! Where:
#! - LEAF[1], LEAF[0] are the leaf data to add to the MMR frontier.
#! - mmr_ptr is the pointer to the MMR frontier data structure.
#!
#! Invocation: exec
proc mmr_frontier_keccak_add
    dropw dropw drop
    # => []
end

#! Gets the root of the MMR frontier using Keccak hashing (stubbed implementation).
#!
#! This is a stubbed implementation that returns placeholder values instead of
#! computing the actual MMR frontier root.
#!
#! Inputs:  [mmr_ptr]
#! Outputs: [ROOT[1], ROOT[0]]
#!
#! Where:
#! - ROOT[1], ROOT[0] are the root hash components of the MMR frontier whose memory location starts at mmr_ptr
#!
#! Invocation: exec
pub proc mmr_frontier_keccak_get_root
    push.3.3.3.3
    push.4.4.4.4
end

#! Bridges an asset out to the aggregation layer.
#!
#! This procedure handles the complete bridge-out operation, including:
#! - Converting asset data to u32 format
#! - Computing Keccak hash of the data
#! - Adding the hash to the MMR frontier
#! - Storing the updated MMR root in account storage
#! - Creating a BURN note with the bridged out asset
#!
#! Inputs:  [ASSET, INPUTS[1], INPUTS[0]]
#! Outputs: []
#!
#! Where:
#! - ASSET is the asset to be bridged out.
#! - INPUTS[1], INPUTS[0] are additional input data for the bridge operation.
#!
#! Invocation: call
pub proc bridge_out
    mem_storew_be.BURN_ASSET_MEM_PTR
    # => [ASSET, INPUTS[1], INPUTS[0]]

    # @dev TODO: Look up asset faucet id in asset registry
    # -> return scaling factor

    # @dev TODO: Convert ASSET amount to EVM amount using scaling factor
    # -> return amount from here: https://github.com/0xMiden/miden-base/pull/2141

    # Converting SCALED_ASSET, INPUTS[1], & INPUTS[0] to u32 representation
    # in preperation for keccak256 hashing

    # Store ASSET as u32 limbs in memory starting at address 0
    push.0 movdn.4 exec.store_word_u32s_le
    # => [INPUTS[1], INPUTS[0]]

    # Store INPUTS[1] as u32 limbs in memory starting at address 8
    push.8 movdn.4 exec.store_word_u32s_le
    # => [INPUTS[0]]

    # Store INPUTS[0] as u32 limbs in memory starting at address 16
    push.16 movdn.4 exec.store_word_u32s_le
    # => []

    push.MMR_PTR
    # => [mmr_ptr]

    push.96 push.0
    # => [ptr, len_bytes, mmr_ptr]

    exec.keccak256::hash_memory
    # => [DIGEST_U32[8], mmr_ptr]

    # adding DIGEST_U32 double word leaf to mmr frontier
    exec.mmr_frontier_keccak_add
    # => []

    push.MMR_PTR
    # => [MMR_PTR]

    # getting mmr frontier root
    exec.mmr_frontier_keccak_get_root
    # => [ROOT[1], ROOT[0]]

    # writing double word root to map keys [0,0,0,0] & [0,0,0,1]
    push.0.0.0.0 push.STORAGE_MAP_INDEX
    # => [index, KEY, ROOT[1], ROOT[0]]

    exec.native_account::set_map_item
    # => [OLD_MAP_ROOT, OLD_MAP_VALUE, ROOT[0]]

    dropw dropw
    # => [ROOT[0]]

    push.1.0.0.0 push.STORAGE_MAP_INDEX
    # => [index, KEY, ROOT[0]]

    exec.native_account::set_map_item
    # => [OLD_MAP_ROOT, OLD_MAP_VALUE]

    dropw dropw
    # => []

    # creating BURN output note for ASSET
    mem_loadw_be.BURN_ASSET_MEM_PTR
    # => [ASSET]

    exec.create_burn_note
    # => []
end
