use.miden::native_account
use.miden::active_account
use.miden::active_note
use.miden::account_id
use.agglayer::local_exit_tree

const.GLOBAL_EXIT_ROOT_MAP=word("miden::agglayer::GER")
const.BRIDGE_OPERATOR_SLOT=word("miden::agglayer::bridge_operator")

# 32 byte Global Exit Root stored across two Word values
const.GER_UPPER_KEY=[0,0,0,0]
const.GER_LOWER_KEY=[1,0,0,0]
const.GER_INDEX_KEY=[2,0,0,0]

# ERRORS
const.ERR_ONLY_BRIDGE_OPERATOR_CAN_UPDATE_GER="note sender is not the authorized bridge operator"

#! Checks if the note sender is the authorized bridge operator.
#!
#! Inputs:  []
#! Outputs: [is_authorized]
#!
#! Where:
#! - is_authorized is 1 if the sender is the bridge operator, 0 otherwise.
proc.is_authorized_operator
    push.BRIDGE_OPERATOR_SLOT[0..2] exec.active_account::get_item
    # => [operator_prefix, operator_suffix, 0, 0]

    exec.active_note::get_sender
    # => [sender_prefix, sender_suffix, operator_prefix, operator_suffix, 0, 0]

    exec.account_id::is_equal
    # => [are_equal, 0, 0]

    movdn.2 drop drop
    # => [is_authorized]
end

proc.is_ger_update_monotonic
    # Stack: [incoming_ger_index]
    dup
    # => [incoming_ger_index, incoming_ger_index]

    # Get current ger_index from storage
    push.GER_INDEX_KEY push.GLOBAL_EXIT_ROOT_MAP[0..2] exec.active_account::get_map_item
    # => [current_ger_index_word, incoming_ger_index, incoming_ger_index]

    # Extract the current ger_index (stored in the first element of the word)
    drop drop drop
    # => [current_ger_index, incoming_ger_index, incoming_ger_index]

    # Check that incoming_index = current_index + 1
    add.1
    # => [current_index + 1, incoming_ger_index, incoming_ger_index]

    dup.1 eq
    # => [is_monotonic, incoming_ger_index, incoming_ger_index]

    assert.err="ger index must increase monotonically by 1"
    # => [incoming_ger_index, incoming_ger_index]
    
    drop
    # => [incoming_ger_index]

    # Store the incoming ger_index at GER_INDEX_KEY
    push.0.0.0
    # => [0, 0, 0, incoming_ger_index]

    push.GER_INDEX_KEY push.GLOBAL_EXIT_ROOT_MAP[0..2] exec.native_account::set_map_item
    # => [old_map_root, old_map_value]
    
    dropw dropw
    # => []
end

#! Update Global Exit Root procedure
#! This procedure handles updating the Global Exit Root in the bridge
#! It validates that only the authorized bridge operator can update GER
#! and stores both the GER value and its index.
#!
#! Inputs: [GER_UPPER, GER_LOWER, ger_index]
#! Outputs: []
#!
#! Where:
#! - GER_UPPER is the upper 128-bit limb of the 256-bit Global Exit Root (4 field elements)
#! - GER_LOWER is the lower 128-bit limb of the 256-bit Global Exit Root (4 field elements)
#! - ger_index is the 32-bit L1InfoTree index (1 field element)
#!
#! Panics if:
#! - the note sender is not the authorized bridge operator
pub proc update_ger
    # Check authorization first
    exec.is_authorized_operator
    # => [is_authorized, GER_UPPER, GER_LOWER, ger_index]

    assert.err=ERR_ONLY_BRIDGE_OPERATOR_CAN_UPDATE_GER
    # => [GER_UPPER, GER_LOWER, ger_index]

    # Store GER_UPPER at key [0,0,0,0]
    # Stack: [GER_UPPER, GER_LOWER, ger_index]
    push.GER_UPPER_KEY push.GLOBAL_EXIT_ROOT_MAP[0..2]
    # => [index, KEY, GER_UPPER, GER_LOWER, ger_index]

    exec.native_account::set_map_item
    # => [OLD_MAP_ROOT, OLD_MAP_VALUE, GER_LOWER, ger_index]

    dropw dropw
    # => [GER_LOWER, ger_index]

    # Store GER_LOWER at key [0,0,0,1]
    push.GER_LOWER_KEY push.GLOBAL_EXIT_ROOT_MAP[0..2]
    # => [index, KEY, GER_LOWER, ger_index]

    exec.native_account::set_map_item
    # => [OLD_MAP_ROOT, OLD_MAP_VALUE, ger_index]

    dropw dropw
    # => [ger_index]

    exec.is_ger_update_monotonic

    dropw dropw dropw dropw
    # => []
end

#! Checks the validity of the GET proof
#!
#! Inputs:  []
#! Outputs: [is_valid_claim_proof]
#! 
#! Invocation: exec
pub proc check_claim_proof
    exec.local_exit_tree::verify_claim_proof
    # => [is_valid_claim_proof]

    # truncate stack
    swap drop
    # => [is_valid_claim_proof]
end
