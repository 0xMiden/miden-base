use.std::math::u64
use.std::math::u256
use.std::sys

const.MIDEN_BASE_SCALE=1000000

#! Convert a Miden amount (1e6 base) to Ethereum's u256 amount with target decimals
#!
#! Input: [amount, target_scale]
#! Output: [lo0, lo1, lo2, lo3, hi0, hi1, hi2, hi3]
#!
#! Where:
#! - amount is in Miden's standard 1e6 base
#! - target_scale is 10^target_decimals (e.g., 1e6 for USDC, 1e18 for ETH)
#! - each output limb fits in u32
export.convert_to_u256_scaled
    # => [amount, target_scale]

    swap
    # => [target_scale, amount]
    
    # Calculate scale = target_scale / MIDEN_BASE_SCALE
    push.MIDEN_BASE_SCALE div
    # => [scale, amount]
    
    # Swap to get [amount, scale] for existing logic
    swap
    # => [amount, scale]
    
    # Split both amount and scale into u32 pairs for u64 multiplication
    # Split scale first
    u32split
    # => [scale_hi, scale_lo, amount]
    
    # Split amount
    movup.2 u32split
    # => [amount_hi, amount_lo, scale_hi, scale_lo]
    
    # Perform u64 multiplication: amount * scale
    exec.u64::wrapping_mul
    # => [result_hi, result_lo]
    
    # Convert to u256 format (8 u32 limbs)
    # Create the full u256: [lo0, lo1, lo2, lo3, hi0, hi1, hi2, hi3]
    # where lo0 = result_lo, lo1 = result_hi, and the rest are 0
    push.0 push.0 push.0 push.0 push.0 push.0
    # => [0, 0, 0, 0, 0, 0, result_hi, result_lo]
    
    # Rearrange to match expected output format [lo0, lo1, lo2, lo3, hi0, hi1, hi2, hi3]
    movup.7 movup.7
    # => [result_lo, result_hi, 0, 0, 0, 0, 0, 0]

    exec.sys::truncate_stack
end