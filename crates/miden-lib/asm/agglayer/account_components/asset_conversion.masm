use.std::math::u64
use.std::math::u256
use.std::sys

#! Calculate 10^scale where scale is a u8 exponent
#!
#! Input: [scale]
#! Output: [10^scale]
#!
#! Where scale is expected to be a small integer (0-18 typical for crypto decimals)
proc pow10
    # => [scale]

    push.1 swap
    # => [scale, result]

    push.1
    # => [true, scale, result]

    # Loop to calculate 10^scale
    while.true
        # => [scale, result]

        # result *= 10
        swap mul.10 swap
        # => [scale, result*10]
        
        # scale -= 1
        sub.1
        # => [scale-1, result*10]

        dup neq.0
        # => [is_zero, scale-1, result*10]
    end
    # => [0, result]

    drop
    # => [result]
end

#! Convert a Miden amount (1e6 base) to target scale using scale exponent
#!
#! Input: [amount, target_scale]
#! Output: [lo0, lo1, lo2, lo3, hi0, hi1, hi2, hi3]
#!
#! Where:
#! - amount is in Miden's standard 1e6 base
#! - target_scale is the difference in target_decimals
#! - each output limb fits in u32
pub proc convert_to_u256_scaled
    # => [amount, target_scale]

    swap
    # => [target_scale, amount]
    
    exec.pow10
    # => [scale, amount]

    # Swap to get [amount, scale] for existing logic
    swap
    # => [amount, scale]
    
    # Split both amount and scale into u32 pairs for u64 multiplication
    # Split scale first
    u32split
    # => [scale_hi, scale_lo, amount]
    
    # Split amount
    movup.2 u32split
    # => [amount_hi, amount_lo, scale_hi, scale_lo]
    
    # Perform u64 multiplication: amount * scale
    exec.u64::wrapping_mul
    # => [result_hi, result_lo]
    
    # Convert to u256 format (8 u32 limbs)
    # Create the full u256: [lo0, lo1, lo2, lo3, hi0, hi1, hi2, hi3]
    # where lo0 = result_lo, lo1 = result_hi, and the rest are 0
    push.0 push.0 push.0 push.0 push.0 push.0
    # => [0, 0, 0, 0, 0, 0, result_hi, result_lo]
    
    exec.sys::truncate_stack
end

