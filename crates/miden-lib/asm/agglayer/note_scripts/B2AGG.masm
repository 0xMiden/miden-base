use.agglayer::bridge_out -> agglayer
use.miden::account_id
use.miden::active_account
use.miden::active_note

# CONSTANTS
# =================================================================================================

const.B2AGG_NOTE_INPUTS_NUMBER=6

#Â ERRORS
# =================================================================================================

const.ERR_B2AGG_WRONG_NUMBER_OF_ASSETS="B2AGG script requires exactly 1 note asset"

const.ERR_B2AGG_WRONG_NUMBER_OF_INPUTS="B2AGG script expects exactly 6 note inputs"

#! Inputs:  [destination_network(u32), destination_address_0(u32), destination_address_1(u32),
#!           destination_address_2(u32), destination_address_3(u32), destination_address_4(u32)]
#! Outputs: []
#!
#! The destination_address is split into 5 u32 values representing a 20-byte Ethereum address:
#! - destination_address_0: bytes 0-3
#! - destination_address_1: bytes 4-7
#! - destination_address_2: bytes 8-11
#! - destination_address_3: bytes 12-15
#! - destination_address_4: bytes 16-19
#!
begin
    dropw
    # => [pad(16)]

    # Check if reclaim
    exec.active_account::get_id
    # => [account_id_prefix, account_id_suffix, pad(16)]

    exec.active_note::get_sender
    # => [sender_id_prefix, sender_id_suffix, account_id_prefix, account_id_suffix, pad(16)]

    exec.account_id::is_equal
    # => [reclaim, pad(16)]

    if.true
        exec.active_note::add_assets_to_account
        # => [pad(16)]
    else
        # Store number of note inputs -> mem[8]
        push.8 exec.active_note::get_inputs
        # => [num_inputs, dest_ptr, pad(16)]

        push.B2AGG_NOTE_INPUTS_NUMBER assert_eq.err=ERR_B2AGG_WRONG_NUMBER_OF_INPUTS drop
        # => [pad(16)]

        # Store number of note assets -> mem[0]
        push.0 exec.active_note::get_assets
        # => [num_assets, ptr, pad(16)]
        
        # Must be exactly 1 asset
        push.1 assert_eq.err=ERR_B2AGG_WRONG_NUMBER_OF_ASSETS drop
        # => [pad(16)]

        mem_loadw_be.8 padw mem_loadw_be.12
        # => [INPUTS[1], INPUTS[0], pad(12)]
        
        # Load ASSET onto the stack
        padw mem_loadw_be.0
        # => [ASSET, INPUTS[1], INPUTS[0], pad(12)]

        call.agglayer::bridge_out
        # => [pad(24)]
    end
    # => [pad(24)]

    dropw dropw
    # => [pad(16)]
end
