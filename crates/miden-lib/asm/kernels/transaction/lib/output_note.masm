use.$kernel::memory
use.$kernel::note
use.$kernel::asset

# ERRORS
# =================================================================================================

const.ERR_OUTPUT_NOTE_INDEX_OUT_OF_BOUNDS="requested output note index should be less than the total number of created output notes"

const.ERR_NOTE_INVALID_INDEX="failed to find note at the given index; index must be within [0, num_of_notes]"

const.ERR_NOTE_FUNGIBLE_MAX_AMOUNT_EXCEEDED="adding a fungible asset to a note cannot exceed the max_amount of 9223372036854775807"

const.ERR_NON_FUNGIBLE_ASSET_ALREADY_EXISTS="non-fungible asset that already exists in the note cannot be added again"

# EVENTS
# =================================================================================================

# Event emitted before an ASSET is added to a note
const.NOTE_BEFORE_ADD_ASSET_EVENT=131085
# Event emitted after an ASSET is added to a note
const.NOTE_AFTER_ADD_ASSET_EVENT=131086

# OUTPUT NOTE PROCEDURES
# =================================================================================================

#! Returns the information about assets in the output note with the specified index.
#!
#! The provided output note index is expected to be less than the total number of output notes.
#!
#! Inputs:  [note_index]
#! Outputs: [ASSETS_COMMITMENT, num_assets]
#!
#! Where:
#! - note_index is the index of the output note whose assets info should be returned.
#! - num_assets is the number of assets in the specified note.
#! - ASSETS_COMMITMENT is a sequential hash of the assets in the specified note.
export.get_assets_info
    # get the note data pointer based on the index of the requested note
    exec.memory::get_output_note_ptr
    # => [note_data_ptr]

    # get the number of assets in the note
    dup exec.memory::get_output_note_num_assets swap
    # => [note_data_ptr, num_assets]

    # get the assets commitment
    dup exec.note::compute_output_note_assets_commitment
    # => [ASSETS_COMMITMENT, note_data_ptr, num_assets]

    # next we should store the assets in the advice map using the computed assets commitment to be
    # able to get the assets later (in the `miden::output_note::get_assets` procedure)

    # get the start and the end pointers of the asset data
    # 
    # notice that if the number of assets is odd, the asset data end pointer will be shifted one 
    # word further to make the assets number even (the same way it is done in the 
    # `note::compute_output_note_assets_commitment` procedure)
    movup.4 exec.memory::get_output_note_asset_data_ptr
    # => [assets_data_ptr, ASSETS_COMMITMENT, num_assets]

    dup dup.6 dup is_odd add
    # => [padded_num_assets, assets_data_ptr, assets_data_ptr, ASSETS_COMMITMENT, num_assets]
    
    mul.4 add
    # => [assets_end_ptr, assets_start_ptr, ASSETS_COMMITMENT, num_assets]

    movdn.5 movdn.4
    # => [ASSETS_COMMITMENT, assets_start_ptr, assets_end_ptr, num_assets]

    # store the assets data to the advice map using ASSETS_COMMITMENT as a key  
    adv.insert_mem
    # => [ASSETS_COMMITMENT, assets_start_ptr, assets_end_ptr, num_assets]

    # remove asset pointers from the stack
    movup.4 drop movup.4 drop
    # => [ASSETS_COMMITMENT, num_assets]
end

#! Adds the ASSET to the note specified by the index.
#!
#! Inputs:  [note_idx, ASSET]
#! Outputs: [note_idx]
#!
#! Where:
#! - note_idx is the index of the note to which the asset is added.
#! - ASSET can be a fungible or non-fungible asset.
#!
#! Panics if:
#! - the ASSET is malformed (e.g., invalid faucet ID).
#! - the max amount of fungible assets is exceeded.
#! - the non-fungible asset already exists in the note.
#! - the total number of ASSETs exceeds the maximum of 256.
export.add_asset_to_note
    # check if the note exists, it must be within [0, num_of_notes]
    dup exec.memory::get_num_output_notes lte assert.err=ERR_NOTE_INVALID_INDEX
    # => [note_idx, ASSET]

    # get a pointer to the memory address of the note at which the asset will be stored
    dup movdn.5 exec.memory::get_output_note_ptr
    # => [note_ptr, ASSET, note_idx]

    # get current num of assets
    dup exec.memory::get_output_note_num_assets movdn.5
    # => [note_ptr, ASSET, num_of_assets, note_idx]

    # validate the ASSET
    movdn.4 exec.asset::validate_asset
    # => [ASSET, note_ptr, num_of_assets, note_idx]

    # emit event to signal that a new asset is going to be added to the note.
    emit.NOTE_BEFORE_ADD_ASSET_EVENT
    # => [ASSET, note_ptr, num_of_assets, note_idx]

    # Check if ASSET to add is fungible
    exec.asset::is_fungible_asset
    # => [is_fungible_asset?, ASSET, note_ptr, num_of_assets, note_idx]

    if.true
        # ASSET to add is fungible
        exec.add_fungible_asset_to_note
        # => [note_ptr, note_idx]
    else
        # ASSET to add is non-fungible
        exec.add_non_fungible_asset_to_note
        # => [note_ptr, note_idx]
    end
    # => [note_ptr, note_idx]

    # update the assets commitment dirty flag to signal that the current assets commitment is not 
    # valid anymore
    push.1 swap exec.memory::set_output_note_dirty_flag
    # => [note_idx]

    # emit event to signal that a new asset was added to the note.
    emit.NOTE_AFTER_ADD_ASSET_EVENT
    # => [note_idx]
end

#! Assert that the provided note index is less than the total number of output notes.
#!
#! Inputs:  [note_index]
#! Outputs: [note_index]
export.assert_note_index_in_bounds
    # assert that the provided note index is less than the total number of notes
    dup exec.memory::get_num_output_notes 
    # => [output_notes_num, note_index, note_index]
    
    u32assert2.err=ERR_OUTPUT_NOTE_INDEX_OUT_OF_BOUNDS
    u32lt assert.err=ERR_OUTPUT_NOTE_INDEX_OUT_OF_BOUNDS
    # => [note_index]
end

# HELPER PROCEDURES
# =================================================================================================

#! Adds a fungible asset to a note. If the note already holds an asset issued by the same faucet id
#! the two quantities are summed up and the new quantity is stored at the old position in the note.
#! In the other case, the asset is stored at the next available position.
#! Returns the pointer to the note the asset was stored at.
#!
#! Inputs:  [ASSET, note_ptr, num_of_assets, note_idx]
#! Outputs: [note_ptr]
#!
#! Where:
#! - ASSET is the fungible asset to be added to the note.
#! - note_ptr is the pointer to the note the asset will be added to.
#! - num_of_assets is the current number of assets.
#! - note_idx is the index of the note the asset will be added to.
#!
#! Panics if
#! - the summed amounts exceed the maximum amount of fungible assets.
proc.add_fungible_asset_to_note
    dup.4 exec.memory::get_output_note_asset_data_ptr
    # => [asset_ptr, ASSET, note_ptr, num_of_assets, note_idx]

    # compute the pointer at which we should stop iterating
    dup dup.7 mul.4 add
    # => [end_asset_ptr, asset_ptr, ASSET, note_ptr, num_of_assets, note_idx]

    # reorganize and pad the stack, prepare for the loop
    movdn.5 movdn.5 padw dup.9
    # => [asset_ptr, 0, 0, 0, 0, ASSET, end_asset_ptr, asset_ptr, note_ptr, num_of_assets, note_idx]

    # compute the loop latch
    dup dup.10 neq
    # => [latch, asset_ptr, 0, 0, 0, 0, ASSET, end_asset_ptr, asset_ptr, note_ptr, num_of_assets,
    #     note_idx]

    while.true
        mem_loadw
        # => [STORED_ASSET, ASSET, end_asset_ptr, asset_ptr, note_ptr, num_of_assets, note_idx]

        dup.4 eq
        # => [are_equal, 0, 0, stored_amount, ASSET, end_asset_ptr, asset_ptr, note_ptr,
        #     num_of_assets, note_idx]

        if.true
            # add the asset quantity, we don't overflow here, bc both ASSETs are valid.
            movup.2 movup.6 add
            # => [updated_amount, 0, 0, faucet_id, 0, 0, end_asset_ptr, asset_ptr, note_ptr,
            #     num_of_assets, note_idx]

            # check that we don't overflow bc we use lte
            dup exec.asset::get_fungible_asset_max_amount lte
            assert.err=ERR_NOTE_FUNGIBLE_MAX_AMOUNT_EXCEEDED
            # => [updated_amount, 0, 0, faucet_id, 0, 0, end_asset_ptr, asset_ptr, note_ptr,
            #     num_of_assets, note_idx]

            # prepare stack to store the "updated" ASSET'' with the new quantity
            movdn.5
            # => [0, 0, ASSET'', end_asset_ptr, asset_ptr, note_ptr, num_of_assets, note_idx]

            # decrease num_of_assets by 1 to offset incrementing it later
            movup.9 sub.1 movdn.9
            # => [0, 0, ASSET'', end_asset_ptr, asset_ptr, note_ptr, num_of_assets - 1, note_idx]

            # end the loop we add 0's to the stack to have the correct number of elements
            push.0.0 dup.9 push.0
            # => [0, asset_ptr, 0, 0, 0, 0, ASSET'', end_asset_ptr, asset_ptr, note_ptr,
            #     num_of_assets - 1, note_idx]
        else
            # => [0, 0, stored_amount, ASSET, end_asset_ptr, asset_ptr, note_ptr, num_of_assets,
            #     note_idx]

            # drop ASSETs and increment the asset pointer
            movup.2 drop push.0.0 movup.9 add.4 dup movdn.10
            # => [asset_ptr + 4, 0, 0, 0, 0, ASSET, end_asset_ptr, asset_ptr + 4, note_ptr,
            #     num_of_assets, note_idx]

            # check if we reached the end of the loop
            dup dup.10 neq
        end
    end
    # => [asset_ptr, 0, 0, 0, 0, ASSET, end_asset_ptr, asset_ptr, note_ptr, num_of_assets, note_idx]
    # prepare stack for storing the ASSET
    movdn.4 dropw
    # => [asset_ptr, ASSET, end_asset_ptr, asset_ptr, note_ptr, num_of_assets, note_idx]

    # Store the fungible asset, either the combined ASSET or the new ASSET
    mem_storew dropw drop drop
    # => [note_ptr, num_of_assets, note_idx]

    # increase the number of assets in the note
    swap add.1 dup.1 exec.memory::set_output_note_num_assets
    # => [note_ptr, note_idx]
end

#! Adds a non-fungible asset to a note at the next available position.
#! Returns the pointer to the note the asset was stored at.
#!
#! Inputs:  [ASSET, note_ptr, num_of_assets, note_idx]
#! Outputs: [note_ptr, note_idx]
#!
#! Where:
#! - ASSET is the non-fungible asset to be added to the note.
#! - note_ptr is the pointer to the note the asset will be added to.
#! - num_of_assets is the current number of assets.
#! - note_idx is the index of the note the asset will be added to.
#!
#! Panics if:
#! - the non-fungible asset already exists in the note.
proc.add_non_fungible_asset_to_note
    dup.4 exec.memory::get_output_note_asset_data_ptr
    # => [asset_ptr, ASSET, note_ptr, num_of_assets, note_idx]

    # compute the pointer at which we should stop iterating
    dup dup.7 mul.4 add
    # => [end_asset_ptr, asset_ptr, ASSET, note_ptr, num_of_assets, note_idx]

    # reorganize and pad the stack, prepare for the loop
    movdn.5 movdn.5 padw dup.9
    # => [asset_ptr, 0, 0, 0, 0, ASSET, end_asset_ptr, asset_ptr, note_ptr, num_of_assets, note_idx]

    # compute the loop latch
    dup dup.10 neq
    # => [latch, asset_ptr, 0, 0, 0, 0, ASSET, end_asset_ptr, asset_ptr, note_ptr, num_of_assets,
    #     note_idx]

    while.true
        # load the asset and compare
        mem_loadw eqw assertz.err=ERR_NON_FUNGIBLE_ASSET_ALREADY_EXISTS
        # => [ASSET', ASSET, end_asset_ptr, asset_ptr, note_ptr, num_of_assets, note_idx]

        # drop ASSET' and increment the asset pointer
        dropw movup.5 add.4 dup movdn.6 padw movup.4
        # => [asset_ptr + 4, 0, 0, 0, 0, ASSET, end_asset_ptr, asset_ptr + 4, note_ptr,
        #     num_of_assets, note_idx]

        # check if we reached the end of the loop
        dup dup.10 neq
    end
    # => [asset_ptr, 0, 0, 0, 0, ASSET, end_asset_ptr, asset_ptr, note_ptr, num_of_assets, note_idx]

    # prepare stack for storing the ASSET
    movdn.4 dropw
    # => [asset_ptr, ASSET, end_asset_ptr, asset_ptr, note_ptr, num_of_assets, note_idx]

    # end of the loop reached, no error so we can store the non-fungible asset
    mem_storew dropw drop drop
    # => [note_ptr, num_of_assets, note_idx]

    # increase the number of assets in the note
    swap add.1 dup.1 exec.memory::set_output_note_num_assets
    # => [note_ptr, note_idx]
end
