use.std::collections::smt
use.kernel::memory

# TODO: Document security.
# TODO: Document terminology.

# Layout of each map entry:
# [map_ptr, prev_item, next_item, 0, KEY, VALUE]

# Event emitted when an entry is set.
const.LINK_MAP_SET_EVENT=131098

# Event emitted when an entry is fetched.
const.LINK_MAP_GET_EVENT=131099

#! Inserts the specified key-value pair into the map, or updates the existing key if the pair
#! already exists.
#!
#! Inputs:  [map_ptr, KEY, NEW_VALUE]
#! Outputs: [OLD_VALUE]
#!
#! Where:
#! - map_ptr is a pointer to the map.
#! - KEY is the key that will be set in the map.
#! - NEW_VALUE is the value that will be set under KEY. If NEW_VALUE is the EMPTY_WORD then the
#!   pair is removed from the map.
#! - OLD_VALUE is the value that was previously stored at KEY. It will be the EMPTY_WORD if the
#!   value was not previously set.
#!
#! Panics if:
#! - the map ptr does not point to a valid map.
export.set
    # TODO: Should we disallow KEY = EMPTY_WORD?

    dup exec.is_empty
    # => [is_empty, map_ptr, KEY, NEW_VALUE]

    if.true
      # the list is empty; insert a new entry.
      exec.memory::link_map_malloc
      # => [entry_ptr, map_ptr, KEY, NEW_VALUE]

      dup movdn.10
      # => [entry_ptr, map_ptr, KEY, NEW_VALUE, entry_ptr]
      dup.1 movdn.10
      # => [entry_ptr, map_ptr, KEY, NEW_VALUE, map_ptr, entry_ptr]

      exec.insert_pair
      # => [map_ptr, entry_ptr]

      exec.set_head
      # => []
    else
      exec.insert_into_non_empty_list
    end
end

#! Returns the VALUE located at KEY in the given map.
#!
#! Inputs:  [map_ptr, KEY]
#! Outputs: [VALUE]
#!
#! Where:
#! - map_ptr is a pointer to the map.
#! - KEY is the key that will be fetched from the map.
#! - VALUE is the value fetched from the map. If no value was previously set for KEY, the
#!   EMPTY_WORD is returned.
#!
#! Panics if:
#! - the map ptr does not point to a valid map.
export.get
    emit.LINK_MAP_GET_EVENT adv_push.2
    # => [entry_exists, entry_ptr, map_ptr, KEY]

    assert.err="entry does not exist"
    # => [entry_ptr, map_ptr, KEY]

    # assert entry ptr validity
    swap dup.1
    # => [entry_ptr, map_ptr, entry_ptr, KEY]

    exec.memory::assert_link_map_entry_ptr
    # => [entry_ptr, KEY]

    movdn.4
    # => [KEY, entry_ptr]

    dup.4 exec.get_key
    # => [ENTRY_KEY, KEY, entry_ptr]

    assert_eqw.err="key in map entry does not match requested key"
    # => [entry_ptr]

    exec.get_value
    # => [VALUE]
end

#! Computes a commitment of the map over all contained key-value pairs.
#!
#! Inputs:  [map_ptr]
#! Outputs: [MAP_COMMITMENT]
export.compute_commitment
    # while we use an SMT as the underlying implementation, the root is the commitment.
    padw movup.4 mem_loadw
    # => [SMT_ROOT]
end

#! Inserts the key value pair into the map ptr which is assumed to be non-empty.
#!
#! Inputs:  [map_ptr, KEY, NEW_VALUE]
#! Outputs: []
proc.insert_into_non_empty_list
  # Operation:
  # Update = 0,
  # InsertAtHead = 1,
  # InsertAfterEntry = 2,

  emit.LINK_MAP_SET_EVENT adv_push.2
  # => [operation, entry_ptr, map_ptr, KEY, NEW_VALUE]

  dup.2 dup.2
  # => [entry_ptr, map_ptr, operation, entry_ptr, map_ptr, KEY, NEW_VALUE]

  # assert entry ptr validity
  exec.memory::assert_link_map_entry_ptr
  # => [operation, entry_ptr, map_ptr, KEY, NEW_VALUE]

  dup eq.0
  # => [is_update_op, operation, entry_ptr, map_ptr, KEY, NEW_VALUE]

  if.true
    # drop operation and map_ptr from stack
    drop
    # => [entry_ptr, map_ptr, KEY, NEW_VALUE]

    swap drop
    # => [entry_ptr, KEY, NEW_VALUE]

    exec.update_entry
    # => []
  else
    # insert new entry
    eq.1
    # => [is_insert_at_head_op, entry_ptr, map_ptr, KEY, NEW_VALUE]

    if.true
      # drop the entry ptr since we can load the head from memory
      # and that way we don't have to validate it
      drop
      # => [map_ptr, KEY, NEW_VALUE]
      exec.insert_at_head
      # => []
    else
      # insert after existing entry
      exec.insert_after_entry
      # => []
    end
  end
end

#! Updates the value in the given entry.
#!
#! Inputs:  [map_ptr, KEY, NEW_VALUE]
#! Outputs: []
#!
#! Panics if:
#! - the key in the entry does not match the provided KEY.
proc.insert_at_head
  exec.memory::link_map_malloc
  # => [entry_ptr, map_ptr, KEY, NEW_VALUE]

  dup movdn.10
  # => [entry_ptr, map_ptr, KEY, NEW_VALUE, entry_ptr]
  dup.1 movdn.10
  # => [entry_ptr, map_ptr, KEY, NEW_VALUE, map_ptr, entry_ptr]

  exec.insert_pair
  # => [map_ptr, entry_ptr]

  # TODO: consider get_head and checking for 0
  dup exec.is_empty not
  # => [is_non_empty, map_ptr, entry_ptr]

  if.true
    dup.1
    # => [entry_ptr, map_ptr, entry_ptr]

    dup.1 exec.get_head
    # => [current_head_entry_ptr, entry_ptr, map_ptr, entry_ptr]

    # assert that entry_ptr.key < current_head_entry_ptr.key
    dup.1 exec.get_key
    # => [ENTRY_KEY, current_head_entry_ptr, entry_ptr, map_ptr, entry_ptr]

    dup.4
    # => [current_head_entry_ptr, ENTRY_KEY, current_head_entry_ptr, entry_ptr, map_ptr, entry_ptr]

    exec.assert_is_less
    # => [current_head_entry_ptr, entry_ptr, map_ptr, entry_ptr]

    dup movdn.2
    # => [current_head_entry_ptr, entry_ptr, current_head_entry_ptr, map_ptr, entry_ptr]

    # set current_head_entry_ptr.prev_item = entry_ptr
    exec.set_prev_item_ptr
    # => [current_head_entry_ptr, map_ptr, entry_ptr]

    # set entry_ptr.next_item = current_head_entry_ptr
    dup.2 exec.set_next_item_ptr
    # => [map_ptr, entry_ptr]
  end

  # update the current head of the map to the newly inserted entry
  exec.set_head
  # => []
end

#! Updates the value in the given entry.
#!
#! Inputs:  [entry_ptr, KEY, NEW_VALUE]
#! Outputs: []
#!
#! Panics if:
#! - the key in the entry does not match the provided KEY.
proc.update_entry
  dup movdn.5
  # => [entry_ptr, KEY, entry_ptr, VALUE]

  exec.assert_is_equal
  # => [entry_ptr, VALUE]

  exec.set_value
  # => []
end

#! Inserts the key value pair as the next entry after the prev_entry_ptr.
#!
#! Inputs:  [prev_entry_ptr, map_ptr, KEY, VALUE]
#! Outputs: []
proc.insert_after_entry
  movdn.5
  # => [map_ptr, KEY, prev_entry_ptr, VALUE]

  movdn.5
  # => [KEY, prev_entry_ptr, map_ptr, VALUE]

  dupw dup.8
  # => [prev_entry_ptr, KEY, KEY, prev_entry_ptr, map_ptr, VALUE]

  exec.assert_is_greater
  # => [KEY, prev_entry_ptr, map_ptr, VALUE]

  movup.4 movdn.9
  # => [KEY, map_ptr, VALUE, prev_entry_ptr]

  movup.4
  # => [map_ptr, KEY, VALUE, prev_entry_ptr]

  exec.memory::link_map_malloc
  # => [entry_ptr, map_ptr, KEY, VALUE, prev_entry_ptr]

  dup movdn.10
  # => [entry_ptr, map_ptr, KEY, VALUE, entry_ptr, prev_entry_ptr]

  exec.insert_pair
  # => [entry_ptr, prev_entry_ptr]

  dup.1 exec.get_next_item_ptr movdn.2
  # => [entry_ptr, prev_entry_ptr, next_entry_ptr]

  dup dup.2
  # => [prev_entry_ptr, entry_ptr, entry_ptr, prev_entry_ptr, next_entry_ptr]

  # set prev_entry_ptr.next_item = entry_ptr
  exec.set_next_item_ptr
  # => [entry_ptr, prev_entry_ptr, next_entry_ptr]

  dup movdn.3
  # => [entry_ptr, prev_entry_ptr, next_entry_ptr, entry_ptr]

  # set entry_ptr.prev_item = prev_entry_ptr
  exec.set_prev_item_ptr
  # => [entry_ptr, next_entry_ptr, entry_ptr]

  dup eq.0 not
  # => [has_next_entry, next_entry_ptr, entry_ptr]

  if.true
    dup.1 exec.get_key
    # => [KEY, next_entry_ptr, entry_ptr]
    dup.4
    # => [next_entry_ptr, KEY, next_entry_ptr, entry_ptr]

    # assert KEY < next_entry.key
    exec.assert_is_less
    # => [next_entry_ptr, entry_ptr]

    dup dup.2
    # => [entry_ptr, next_entry_ptr, next_entry_ptr, entry_ptr]

    # set entry_ptr.next_item = next_item
    exec.set_next_item_ptr
    # => [next_entry_ptr, entry_ptr]

    # set next_item.prev_item = entry_ptr 
    exec.set_prev_item_ptr
    # => []
  else
    # remove unneeded stack elements
    drop drop
    # => []
  end
  # => []
end

#! Asserts that the KEY is equal to the key in the entry.
#!
#! Inputs:  [entry_ptr, KEY]
#! Outputs: []
proc.assert_is_equal
  exec.get_key swapw
  # => [KEY, ENTRY_KEY]

  exec.is_equal assert.err="provided key is not equal to the entry key"
  # => []
end

#! Asserts that the KEY is lexicographically greater than the key in the entry pointer.
#!
#! Inputs:  [entry_ptr, KEY]
#! Outputs: []
proc.assert_is_greater
  exec.get_key swapw
  # => [KEY, ENTRY_KEY]

  exec.is_greater assert.err="provided key is not greater than the entry key"
  # => []
end

#! Asserts that the KEY is lexicographically less than the key in the entry pointer.
#!
#! Inputs:  [entry_ptr, KEY]
#! Outputs: []
proc.assert_is_less
  exec.get_key swapw
  # => [KEY, ENTRY_KEY]

  exec.is_less assert.err="provided key is not less than the entry key"
  # => []
end

#! Inserts the key, value into the entry pointer and sets the map ptr to the provided value.
#!
#! Inputs:  [entry_ptr, map_ptr, KEY, VALUE]
#! Outputs: []
proc.insert_pair
  swap dup.1
  # => [entry_ptr, map_ptr, entry_ptr, KEY, VALUE]
  exec.set_map_ptr
  # => [entry_ptr, KEY, VALUE]

  dup movdn.5
  # => [entry_ptr, KEY, entry_ptr, NEW_VALUE]
  exec.set_key

  # => [entry_ptr, NEW_VALUE]
  exec.set_value
end

#! Returns true if the list is empty, i.e. map ptr points to 0.
#!
#! Inputs:  [map_ptr]
#! Outputs: [is_empty]
proc.is_empty
  mem_load eq.0
end

#! Returns true if the entry at the given ptr has a non-null ptr to a next item.
#!
#! Inputs:  [entry_ptr]
#! Outputs: [has_next]
proc.has_next
  exec.get_next_item_ptr eq.0 not
end

#! Returns the value of the next_item pointer in the provided entry pointer.
#!
#! Inputs:  [entry_ptr]
#! Outputs: [next_item_ptr]
proc.get_next_item_ptr
  add.2 mem_load
  # => [next_item_ptr]
end

#! Returns the value of the prev_item pointer in the provided entry pointer.
#!
#! Inputs:  [entry_ptr]
#! Outputs: [prev_item_ptr]
proc.get_prev_item_ptr
  add.1 mem_load
  # => [prev_item_ptr]
end

#! Sets the next_item ptr of the entry to the provided value.
#!
#! Inputs:  [entry_ptr, next_item]
#! Outputs: []
proc.set_next_item_ptr
  add.2 mem_store
  # => []
end

#! Sets the prev_item ptr of the entry to the provided value.
#!
#! Inputs:  [entry_ptr, prev_item]
#! Outputs: []
proc.set_prev_item_ptr
  add.1 mem_store
  # => []
end

#! Returns the value of the entry pointer.
#!
#! Inputs:  [entry_ptr]
#! Outputs: [VALUE]
proc.get_value
  padw movup.4
  # => [entry_ptr, pad(4)]
  add.8 mem_loadw
  # => [VALUE]
end

#! Returns the key of the entry pointer.
#!
#! Inputs:  [entry_ptr]
#! Outputs: [KEY]
proc.get_key
  padw movup.4
  # => [entry_ptr, pad(4)]
  add.4 mem_loadw
  # => [KEY]
end

#! Sets the entry ptr as the head of the linked list.
#!
#! Inputs:  [map_ptr, entry_ptr]
#! Outputs: []
proc.set_head
  mem_store
end

#! Returns the entry ptr at the head of the linked list.
#!
#! Inputs:  [map_ptr]
#! Outputs: [entry_ptr]
proc.get_head
  mem_load
end

#! Sets the map ptr of the entry pointer.
#!
#! Inputs:  [entry_ptr, map_ptr]
#! Outputs: []
proc.set_map_ptr
  mem_store
end

#! Sets the key of the entry pointer.
#!
#! Inputs:  [entry_ptr, KEY]
#! Outputs: []
proc.set_key
  add.4 mem_storew dropw
end

#! Sets the value of the entry pointer.
#!
#! Inputs:  [entry_ptr, VALUE]
#! Outputs: []
proc.set_value
  add.8 mem_storew dropw
end

# COMPARISON OPERATIONS
# -------------------------------------------------------------------------------------------------

#! Returns true if KEY1 is equal to KEY2, false otherwise.
#!
#! Inputs:  [KEY1, KEY2]
#! Outputs: [is_equal]
export.is_equal
  exec.arrange_words_adjacent
  # => [2_3, 1_3, 2_2, 1_2, 2_1, 1_1, 2_0, 1_0]

  push.1
  # => [is_equal, 2_3, 1_3, 2_2, 1_2, 2_1, 1_1, 2_0, 1_0]

  repeat.4
    swap movup.2
    # => [2_x, 1_x, is_equal, <remaining_felts>]
    eq
    # => [felts_x_equal, is_equal, <remaining_felts>]
    and
    # => [is_equal, <remaining_felts>]
  end
  # => [is_equal]
end

#! Returns true if KEY1 is strictly greater than KEY2, false otherwise.
#!
#! TODO: Describe logic.
#!
#! Inputs:  [KEY1, KEY2]
#! Outputs: [is_greater]
export.is_greater
  exec.arrange_words_adjacent
  # => [2_3, 1_3, 2_2, 1_2, 2_1, 1_1, 2_0, 1_0]

  push.1.0
  # => [is_greater, continue, 2_3, 1_3, 2_2, 1_2, 2_1, 1_1, 2_0, 1_0]

  repeat.4
    movup.3 movup.3
    # => [2_x, 1_x, is_greater, continue, <remaining_felts>]

    # check 1_x == 2_x; if so, we continue
    dup dup.2 eq
    # => [is_felt_eq, 2_x, 1_x, is_greater, continue, <remaining_felts>]

    movdn.3
    # => [2_x, 1_x, is_greater, is_felt_eq, continue, <remaining_felts>]

    # check 1_x > 2_x
    gt
    # => [is_felt_gt, is_greater, is_felt_eq, continue, <remaining_felts>]

    dup.3 u32and
    # => [is_felt_gt_if_continue, is_greater, is_felt_eq, continue, <remaining_felts>]

    u32or movdn.2
    # => [is_felt_eq, continue, is_greater, <remaining_felts>]

    # keeps continue at 1 if the felts are equal
    # sets continue to 0 if the felts are not equal
    u32and
    # => [continue, is_greater, <remaining_felts>]
    swap
    # => [is_greater, continue, <remaining_felts>]
  end
  # => [is_greater, continue]

  swap drop
  # => [is_greater]
end

#! Returns true if KEY1 is strictly less than KEY2, false otherwise.
#!
#! From an implementation standpoint this is exactly the same as `is_greater` except it uses
#! `lt` rather than `gt`. See its docs for details.
#!
#! Inputs:  [KEY1, KEY2]
#! Outputs: [is_less]
export.is_less
  exec.arrange_words_adjacent
  # => [2_3, 1_3, 2_2, 1_2, 2_1, 1_1, 2_0, 1_0]

  push.1.0
  # => [is_less, continue, 2_3, 1_3, 2_2, 1_2, 2_1, 1_1, 2_0, 1_0]

  repeat.4
    movup.3 movup.3
    # => [2_x, 1_x, is_less, continue, <remaining_felts>]

    # check 1_x == 2_x; if so, we continue
    dup dup.2 eq
    # => [is_felt_eq, 2_x, 1_x, is_less, continue, <remaining_felts>]

    movdn.3
    # => [2_x, 1_x, is_less, is_felt_eq, continue, <remaining_felts>]

    # check 1_x < 2_x
    lt
    # => [is_felt_lt, is_less, is_felt_eq, continue, <remaining_felts>]

    dup.3 u32and
    # => [is_felt_lt_if_continue, is_less, is_felt_eq, continue, <remaining_felts>]

    u32or movdn.2
    # => [is_felt_eq, continue, is_less, <remaining_felts>]

    # keeps continue at 1 if the felts are equal
    # sets continue to 0 if the felts are not equal
    u32and
    # => [continue, is_less, <remaining_felts>]
    swap
    # => [is_less, continue, <remaining_felts>]
  end
  # => [is_less, continue]

  swap drop
  # => [is_less]
end

#! Arranges the given words such that the corresponding elements are next to each other.
#!
#! Inputs:  [KEY1, KEY2]
#! Outputs: [key2_3, key1_3, key2_2, key1_2, key2_1, key1_1, key2_0, key1_0]
proc.arrange_words_adjacent
  # => [1_3, 1_2, 1_1, 1_0, 2_3, 2_2, 2_1, 2_0]
  movup.3 movup.7
  # => [2_0, 1_0, 1_3, 1_2, 1_1, 2_3, 2_2, 2_1]
  movup.4 movup.7
  # => [2_1, 1_1, 2_0, 1_0, 1_3, 1_2, 2_3, 2_2]
  movup.5 movup.7
  # => [2_2, 1_2, 2_1, 1_1, 2_0, 1_0, 1_3, 2_3]
  movup.6 movup.7
  # => [2_3, 1_3, 2_2, 1_2, 2_1, 1_1, 2_0, 1_0]
end
