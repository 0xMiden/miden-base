use.std::collections::smt
use.kernel::memory

# TODO: Document security.
# TODO: Document terminology.
# TODO: Document full map layout.
# TODO: Rename prev_item and next_item to prev_entry and next_entry.

# Layout of each map entry:
# [map_ptr, prev_item, next_item, 0, KEY, VALUE]

# Event emitted when an entry is set.
const.LINK_MAP_SET_EVENT=131098

# Event emitted when an entry is fetched.
const.LINK_MAP_GET_EVENT=131099

#! Inserts the specified key-value pair into the map, or updates the existing key if the pair
#! already exists.
#!
#! Note that unlike smt::set, passing VALUE = EMPTY_WORD does not mean removal of the entry.
#!
#! Inputs:  [map_ptr, KEY, VALUE]
#! Outputs: []
#!
#! Where:
#! - map_ptr is a pointer to the map.
#! - KEY is the key that will be set in the map.
#! - VALUE is the value that will be set under KEY.
#!
#! Panics if:
#! - the map ptr does not point to a valid map.
export.set
    emit.LINK_MAP_SET_EVENT adv_push.2
    # => [operation, entry_ptr, map_ptr, KEY, VALUE]

    # Operation:
    # Update = 0,
    # InsertAtHead = 1,
    # InsertAfterEntry = 2,

    dup.2 dup.2
    # => [entry_ptr, map_ptr, operation, entry_ptr, map_ptr, KEY, VALUE]

    exec.assert_entry_ptr_is_valid
    # => [operation, entry_ptr, map_ptr, KEY, VALUE]

    dup eq.0
    # => [is_update_op, operation, entry_ptr, map_ptr, KEY, VALUE]

    if.true
        # drop operation and map_ptr from stack
        drop
        # => [entry_ptr, map_ptr, KEY, VALUE]

        swap drop
        # => [entry_ptr, KEY, VALUE]

        exec.update_entry
        # => []
    else
        # insert new entry
        eq.1
        # => [is_insert_at_head_op, entry_ptr, map_ptr, KEY, VALUE]

        if.true
            # drop the entry ptr since we can load the head from memory
            # and that way we don't have to validate it
            drop
            # => [map_ptr, KEY, VALUE]
            exec.insert_at_head
            # => []
        else
            # insert after existing entry
            exec.insert_after_entry
            # => []
        end
    end
end

#! Returns the VALUE located at KEY in the given map.
#!
#! Inputs:  [map_ptr, KEY]
#! Outputs: [contains_key, VALUE]
#!
#! Where:
#! - map_ptr is a pointer to the map.
#! - KEY is the key that will be fetched from the map.
#! - contains_key is a boolean indicating whether the map contained the KEY or not.
#! - VALUE is the value fetched from the map. VALUE is guaranteed to be an EMPTY_WORD when the
#!   map did not contain the key.
#!
#! Panics if:
#! - the map ptr does not point to a valid map.
#! - the map does not contain the provided KEY.
export.get
    # TODO: Document where entry_ptr points to in case the key (does not) exist.

    emit.LINK_MAP_GET_EVENT adv_push.2
    # => [operation, entry_ptr, map_ptr, KEY]

    dup.2 dup.2
    # => [entry_ptr, map_ptr, operation, entry_ptr, map_ptr, KEY]

    exec.assert_entry_ptr_is_valid
    # => [operation, entry_ptr, map_ptr, KEY]

    # Operation:
    # Found = 0
    # AbsentAtHead = 1
    # AbsentAfterEntry = 2

    dup eq.0
    # => [is_found, operation, entry_ptr, map_ptr, KEY]

    if.true
        drop swap drop
        # => [entry_ptr, KEY]
        exec.get_existent_value
        # => [VALUE]
        push.1
        # => [contains_key, VALUE]
    else
        eq.1
        # => [is_absent_at_head, entry_ptr, map_ptr, KEY]

        if.true
            drop
            # => [map_ptr, KEY]

            exec.validate_absent_at_head
            # => []
        else
            exec.validate_absent_after_entry
            # => []
        end

        padw push.0
        # => [contains_key, EMPTY_WORD]
    end
end

#! Computes a commitment of the map over all contained key-value pairs.
#!
#! Inputs:  [map_ptr]
#! Outputs: [MAP_COMMITMENT]
export.compute_commitment
    # while we use an SMT as the underlying implementation, the root is the commitment.
    padw movup.4 mem_loadw
    # => [SMT_ROOT]
end

#! Validates that the provided KEY is absent at the head of the link map.
#!
#! An invariant of the link map is that its entries are sorted and since there is no previous
#! entry for the head, this proves that the KEY is absent from the map.
#!
#! Inputs:  [map_ptr, KEY]
#! Outputs: []
#!
#! Panics if:
#! - the KEY is not less than the key in the head of the map, unless the map is empty.
proc.validate_absent_at_head
    drop dup exec.is_empty
    # => [is_empty, map_ptr, KEY]

    if.true
        # in an empty list, any KEY is absent at the head, so there's nothing further to validate
        drop dropw
        # => []
    else
        exec.get_head
        # => [entry_ptr, KEY]

        # assert that KEY is less than the current head's key
        exec.assert_key_is_less
        # => []
    end
end

#! Validates that the provided KEY is absent after the provided entry.
#!
#! If KEY is greater than the key in the entry and less than the key in entry's next entry, then
#! that proves the absence of the key.
#!
#! Inputs:  [entry_ptr, map_ptr, KEY]
#! Outputs: []
#!
#! Panics if:
#! - the map is empty.
#! - the KEY is not greater than the key in the entry.
#! - the KEY is not less than the key in entry.next_entry, unless entry is the last one in the map.
proc.validate_absent_after_entry
    swap exec.is_empty assertz.err="map cannot be empty when proving absence after an entry"
    # => [entry_ptr, KEY]

    movdn.4 dupw
    # => [KEY, KEY, entry_ptr]

    dup.8
    # => [entry_ptr, KEY, KEY, entry_ptr]

    # assert that KEY is greater than the entry's key
    exec.assert_key_is_greater
    # => [KEY, entry_ptr]

    movup.4 exec.get_next_item_ptr
    # => [next_item_ptr, KEY]

    dup eq.0
    # => [is_last_entry, next_item_ptr, KEY]

    if.true
        # nothing further to validate
        drop dropw
        # => []
    else
        # if there is a next item, then the KEY must be less than next item's key
        exec.assert_key_is_less
        # => []
    end
    # => []
end

#! Fetches the VALUE at the provided KEY from the provided entry.
#!
#! Inputs:  [entry_ptr, KEY]
#! Outputs: [VALUE]
#!
#! Panics if:
#! - the key in the entry does not match KEY.
proc.get_existent_value
    movdn.4
    # => [KEY, entry_ptr]

    dup.4 exec.get_key
    # => [ENTRY_KEY, KEY, entry_ptr]

    assert_eqw.err="key in map entry does not match requested key"
    # => [entry_ptr]

    exec.get_value
    # => [VALUE]
end

#! Updates the value in the given entry.
#!
#! Inputs:  [map_ptr, KEY, VALUE]
#! Outputs: []
#!
#! Panics if:
#! - the key in the entry does not match the provided KEY.
proc.insert_at_head
    exec.memory::link_map_malloc
    # => [entry_ptr, map_ptr, KEY, VALUE]

    dup movdn.10
    # => [entry_ptr, map_ptr, KEY, VALUE, entry_ptr]
    dup.1 movdn.10
    # => [entry_ptr, map_ptr, KEY, VALUE, map_ptr, entry_ptr]

    exec.insert_pair
    # => [map_ptr, entry_ptr]

    # TODO: consider get_head and checking for 0
    dup exec.is_empty not
    # => [is_non_empty, map_ptr, entry_ptr]

    if.true
        dup.1
        # => [entry_ptr, map_ptr, entry_ptr]

        dup.1 exec.get_head
        # => [current_head_entry_ptr, entry_ptr, map_ptr, entry_ptr]

        # assert that entry_ptr.key < current_head_entry_ptr.key
        dup.1 exec.get_key
        # => [ENTRY_KEY, current_head_entry_ptr, entry_ptr, map_ptr, entry_ptr]

        dup.4
        # => [current_head_entry_ptr, ENTRY_KEY, current_head_entry_ptr, entry_ptr, map_ptr, entry_ptr]

        exec.assert_key_is_less
        # => [current_head_entry_ptr, entry_ptr, map_ptr, entry_ptr]

        dup movdn.2
        # => [current_head_entry_ptr, entry_ptr, current_head_entry_ptr, map_ptr, entry_ptr]

        # set current_head_entry_ptr.prev_item = entry_ptr
        exec.set_prev_item_ptr
        # => [current_head_entry_ptr, map_ptr, entry_ptr]

        # set entry_ptr.next_item = current_head_entry_ptr
        dup.2 exec.set_next_item_ptr
        # => [map_ptr, entry_ptr]
    end

    # update the current head of the map to the newly inserted entry
    exec.set_head
    # => []
end

#! Updates the value in the given entry.
#!
#! Inputs:  [entry_ptr, KEY, VALUE]
#! Outputs: []
#!
#! Panics if:
#! - the key in the entry does not match the provided KEY.
proc.update_entry
    dup movdn.5
    # => [entry_ptr, KEY, entry_ptr, VALUE]

    exec.assert_key_is_equal
    # => [entry_ptr, VALUE]

    exec.set_value
    # => []
end

#! Inserts the key value pair as the next entry after the prev_entry_ptr.
#!
#! Inputs:  [prev_entry_ptr, map_ptr, KEY, VALUE]
#! Outputs: []
proc.insert_after_entry
    movdn.5
    # => [map_ptr, KEY, prev_entry_ptr, VALUE]

    movdn.5
    # => [KEY, prev_entry_ptr, map_ptr, VALUE]

    dupw dup.8
    # => [prev_entry_ptr, KEY, KEY, prev_entry_ptr, map_ptr, VALUE]

    exec.assert_key_is_greater
    # => [KEY, prev_entry_ptr, map_ptr, VALUE]

    movup.4 movdn.9
    # => [KEY, map_ptr, VALUE, prev_entry_ptr]

    movup.4
    # => [map_ptr, KEY, VALUE, prev_entry_ptr]

    exec.memory::link_map_malloc
    # => [entry_ptr, map_ptr, KEY, VALUE, prev_entry_ptr]

    dup movdn.10
    # => [entry_ptr, map_ptr, KEY, VALUE, entry_ptr, prev_entry_ptr]

    exec.insert_pair
    # => [entry_ptr, prev_entry_ptr]

    dup.1 exec.get_next_item_ptr movdn.2
    # => [entry_ptr, prev_entry_ptr, next_entry_ptr]

    dup dup.2
    # => [prev_entry_ptr, entry_ptr, entry_ptr, prev_entry_ptr, next_entry_ptr]

    # set prev_entry_ptr.next_item = entry_ptr
    exec.set_next_item_ptr
    # => [entry_ptr, prev_entry_ptr, next_entry_ptr]

    dup movdn.3
    # => [entry_ptr, prev_entry_ptr, next_entry_ptr, entry_ptr]

    # set entry_ptr.prev_item = prev_entry_ptr
    exec.set_prev_item_ptr
    # => [entry_ptr, next_entry_ptr, entry_ptr]

    dup eq.0 not
    # => [has_next_entry, next_entry_ptr, entry_ptr]

    if.true
        dup.1 exec.get_key
        # => [KEY, next_entry_ptr, entry_ptr]
        dup.4
        # => [next_entry_ptr, KEY, next_entry_ptr, entry_ptr]

        # assert KEY < next_entry.key
        exec.assert_key_is_less
        # => [next_entry_ptr, entry_ptr]

        dup dup.2
        # => [entry_ptr, next_entry_ptr, next_entry_ptr, entry_ptr]

        # set entry_ptr.next_item = next_item
        exec.set_next_item_ptr
        # => [next_entry_ptr, entry_ptr]

        # set next_item.prev_item = entry_ptr
        exec.set_prev_item_ptr
        # => []
    else
        # remove unneeded stack elements
        drop drop
        # => []
    end
    # => []
end

#! Asserts that the KEY is equal to the key in the entry.
#!
#! Inputs:  [entry_ptr, KEY]
#! Outputs: []
proc.assert_key_is_equal
    exec.get_key swapw
    # => [KEY, ENTRY_KEY]

    exec.is_equal assert.err="provided key is not equal to the entry key"
    # => []
end

#! Asserts that the KEY is greater than the key in the entry pointer.
#!
#! Inputs:  [entry_ptr, KEY]
#! Outputs: []
proc.assert_key_is_greater
    exec.get_key swapw
    # => [KEY, ENTRY_KEY]

    exec.is_greater assert.err="provided key is not greater than the entry key"
    # => []
end

#! Asserts that the KEY is less than the key in the entry pointer.
#!
#! Inputs:  [entry_ptr, KEY]
#! Outputs: []
proc.assert_key_is_less
    exec.get_key swapw
    # => [KEY, ENTRY_KEY]

    exec.is_less assert.err="provided key is not less than the entry key"
    # => []
end

#! Inserts the key, value into the entry pointer and sets the map ptr to the provided value.
#!
#! Inputs:  [entry_ptr, map_ptr, KEY, VALUE]
#! Outputs: []
proc.insert_pair
    swap dup.1
    # => [entry_ptr, map_ptr, entry_ptr, KEY, VALUE]
    exec.set_map_ptr
    # => [entry_ptr, KEY, VALUE]

    dup movdn.5
    # => [entry_ptr, KEY, entry_ptr, VALUE]
    exec.set_key

    # => [entry_ptr, VALUE]
    exec.set_value
end

#! Returns true if the list is empty, i.e. map ptr points to 0.
#!
#! Inputs:  [map_ptr]
#! Outputs: [is_empty]
proc.is_empty
    mem_load eq.0
end

#! Returns true if the entry at the given ptr has a non-null ptr to a next item.
#!
#! Inputs:  [entry_ptr]
#! Outputs: [has_next]
proc.has_next
    exec.get_next_item_ptr eq.0 not
end

#! Returns the value of the next_item pointer in the provided entry pointer.
#!
#! Inputs:  [entry_ptr]
#! Outputs: [next_item_ptr]
proc.get_next_item_ptr
    add.2 mem_load
    # => [next_item_ptr]
end

#! Returns the value of the prev_item pointer in the provided entry pointer.
#!
#! Inputs:  [entry_ptr]
#! Outputs: [prev_item_ptr]
proc.get_prev_item_ptr
    add.1 mem_load
    # => [prev_item_ptr]
end

#! Sets the next_item ptr of the entry to the provided value.
#!
#! Inputs:  [entry_ptr, next_item]
#! Outputs: []
proc.set_next_item_ptr
    add.2 mem_store
    # => []
end

#! Sets the prev_item ptr of the entry to the provided value.
#!
#! Inputs:  [entry_ptr, prev_item]
#! Outputs: []
proc.set_prev_item_ptr
    add.1 mem_store
    # => []
end

#! Returns the value of the entry pointer.
#!
#! Inputs:  [entry_ptr]
#! Outputs: [VALUE]
proc.get_value
    padw movup.4
    # => [entry_ptr, pad(4)]
    add.8 mem_loadw
    # => [VALUE]
end

#! Returns the key of the entry pointer.
#!
#! Inputs:  [entry_ptr]
#! Outputs: [KEY]
proc.get_key
    padw movup.4
    # => [entry_ptr, pad(4)]
    add.4 mem_loadw
    # => [KEY]
end

#! Sets the entry ptr as the head of the linked list.
#!
#! Inputs:  [map_ptr, entry_ptr]
#! Outputs: []
proc.set_head
    mem_store
end

#! Returns the entry ptr at the head of the linked list.
#!
#! Inputs:  [map_ptr]
#! Outputs: [entry_ptr]
proc.get_head
    mem_load
end

#! Sets the map ptr of the entry pointer.
#!
#! Inputs:  [entry_ptr, map_ptr]
#! Outputs: []
proc.set_map_ptr
    mem_store
end

#! Returns the map ptr of the entry pointer.
#!
#! Inputs:  [entry_ptr]
#! Outputs: [map_ptr]
proc.get_map_ptr
    mem_load
end

#! Sets the key of the entry pointer.
#!
#! Inputs:  [entry_ptr, KEY]
#! Outputs: []
proc.set_key
    add.4 mem_storew dropw
end

#! Sets the value of the entry pointer.
#!
#! Inputs:  [entry_ptr, VALUE]
#! Outputs: []
proc.set_value
    add.8 mem_storew dropw
end

#! Asserts that the given entry ptr is a valid entry in the map identified by map_ptr.
#!
#! Inputs:  [entry_ptr, map_ptr]
#! Outputs: []
#!
#! Panics if:
#! - any of the following conditions is false, except if the map is empty:
#!   - LINK_MAP_MEMORY_START_PTR <= entry_ptr < LINK_MAP_MEMORY_END_PTR.
#!   - entry ptr is "link map entry"-aligned, i.e. entry_ptr % LINK_MAP_ENTRY_SIZE == 0.
#!   - entry's map ptr is equal to the given map_ptr.
export.assert_entry_ptr_is_valid
    # Check entry pointer is in valid memory range.
    # -------------------------------------------------------------------------------------------------

    exec.memory::get_link_map_memory_start_ptr dup.1
    # => [entry_ptr, LINK_MAP_MEMORY_START_PTR, entry_ptr, map_ptr]

    # compute LINK_MAP_MEMORY_START_PTR <= entry_ptr
    lte
    # => [is_entry_ptr_gt_start, entry_ptr, map_ptr]

    dup.1 exec.memory::get_link_map_memory_end_ptr
    # => [LINK_MAP_MEMORY_END_PTR, entry_ptr, is_entry_ptr_gt_start, entry_ptr, map_ptr]

    # assert entry_ptr < LINK_MAP_MEMORY_END_PTR
    lt and
    # => [is_entry_ptr_in_valid_range, entry_ptr, map_ptr]

    # we have to skip the assertion if the map is empty
    dup.2 exec.is_empty
    # => [is_empty_map, is_entry_ptr_in_valid_range, entry_ptr, map_ptr]

    dup movdn.4
    # => [is_empty_map, is_entry_ptr_in_valid_range, entry_ptr, map_ptr, is_empty_map]

    # this assertion is always true if is_empty_map is true
    or assert.err="entry ptr is not in a valid memory range"
    # => [entry_ptr, map_ptr, is_empty_map]

    # Check that the entry pointer is aligned to link map entries.
    # -------------------------------------------------------------------------------------------------

    # note that the previous range check ensures that entry_ptr fits in a u32
    dup exec.memory::get_link_map_entry_size u32mod eq.0
    # => [is_entry_ptr_aligned, entry_ptr, map_ptr, is_empty_map]

    # this assertion is always true if is_empty_map is true
    dup.3 or assert.err="entry ptr is not link map entry aligned"
    # => [entry_ptr, map_ptr, is_empty_map]

    # Check entry pointer's map ptr is equal to map_ptr.
    # -------------------------------------------------------------------------------------------------

    # check if entry_ptr.map_ptr == map_ptr
    exec.get_map_ptr eq
    # => [entry_contains_map_ptr, is_empty_map]

    # this assertion is always true if is_empty_map is true
    or assert.err="map ptr stored in entry ptr does not match actual map ptr"
end

# COMPARISON OPERATIONS
# -------------------------------------------------------------------------------------------------

#! Returns true if KEY1 is equal to KEY2, false otherwise.
#!
#! Inputs:  [KEY1, KEY2]
#! Outputs: [is_equal]
export.is_equal
    exec.arrange_words_adjacent
    # => [2_3, 1_3, 2_2, 1_2, 2_1, 1_1, 2_0, 1_0]

    push.1
    # => [is_equal, 2_3, 1_3, 2_2, 1_2, 2_1, 1_1, 2_0, 1_0]

    repeat.4
        swap movup.2
        # => [2_x, 1_x, is_equal, <remaining_felts>]
        eq
        # => [felts_x_equal, is_equal, <remaining_felts>]
        and
        # => [is_equal, <remaining_felts>]
    end
    # => [is_equal]
end

#! Returns true if KEY1 is strictly greater than KEY2, false otherwise.
#!
#! For reference, this is equivalent to the following Rust function:
#!
#! fn is_word_greater(w0: Word, w1: Word) -> bool {
#!     let mut result = 0u8;
#!     let mut cont = 1u8;
#!
#!     for i in (0..4).rev() {
#!         let gt = w0[i].as_int() > w1[i].as_int();
#!         let eq = w0[i].as_int() == w1[i].as_int();
#!
#!         result |= gt as u8 & cont;
#!         cont &= eq as u8;
#!     }
#!
#!     result == 1
#! }
#!
#! Inputs:  [KEY1, KEY2]
#! Outputs: [is_greater]
export.is_greater
    exec.arrange_words_adjacent
    # => [2_3, 1_3, 2_2, 1_2, 2_1, 1_1, 2_0, 1_0]

    push.1.0
    # => [is_greater, continue, 2_3, 1_3, 2_2, 1_2, 2_1, 1_1, 2_0, 1_0]

    repeat.4
        movup.3 movup.3
        # => [2_x, 1_x, is_greater, continue, <remaining_felts>]

        # check 1_x == 2_x; if so, we continue
        dup dup.2 eq
        # => [is_felt_eq, 2_x, 1_x, is_greater, continue, <remaining_felts>]

        movdn.3
        # => [2_x, 1_x, is_greater, is_felt_eq, continue, <remaining_felts>]

        # check 1_x > 2_x
        gt
        # => [is_felt_gt, is_greater, is_felt_eq, continue, <remaining_felts>]

        dup.3 u32and
        # => [is_felt_gt_if_continue, is_greater, is_felt_eq, continue, <remaining_felts>]

        u32or movdn.2
        # => [is_felt_eq, continue, is_greater, <remaining_felts>]

        # keeps continue at 1 if the felts are equal
        # sets continue to 0 if the felts are not equal
        u32and
        # => [continue, is_greater, <remaining_felts>]
        swap
        # => [is_greater, continue, <remaining_felts>]
    end
    # => [is_greater, continue]

    swap drop
    # => [is_greater]
end

#! Returns true if KEY1 is strictly less than KEY2, false otherwise.
#!
#! From an implementation standpoint this is exactly the same as `is_greater` except it uses
#! `lt` rather than `gt`. See its docs for details.
#!
#! Inputs:  [KEY1, KEY2]
#! Outputs: [is_less]
export.is_less
    exec.arrange_words_adjacent
    # => [2_3, 1_3, 2_2, 1_2, 2_1, 1_1, 2_0, 1_0]

    push.1.0
    # => [is_less, continue, 2_3, 1_3, 2_2, 1_2, 2_1, 1_1, 2_0, 1_0]

    repeat.4
        movup.3 movup.3
        # => [2_x, 1_x, is_less, continue, <remaining_felts>]

        # check 1_x == 2_x; if so, we continue
        dup dup.2 eq
        # => [is_felt_eq, 2_x, 1_x, is_less, continue, <remaining_felts>]

        movdn.3
        # => [2_x, 1_x, is_less, is_felt_eq, continue, <remaining_felts>]

        # check 1_x < 2_x
        lt
        # => [is_felt_lt, is_less, is_felt_eq, continue, <remaining_felts>]

        dup.3 u32and
        # => [is_felt_lt_if_continue, is_less, is_felt_eq, continue, <remaining_felts>]

        u32or movdn.2
        # => [is_felt_eq, continue, is_less, <remaining_felts>]

        # keeps continue at 1 if the felts are equal
        # sets continue to 0 if the felts are not equal
        u32and
        # => [continue, is_less, <remaining_felts>]
        swap
        # => [is_less, continue, <remaining_felts>]
    end
    # => [is_less, continue]

    swap drop
    # => [is_less]
end

#! Arranges the given words such that the corresponding elements are next to each other.
#!
#! Inputs:  [KEY1, KEY2]
#! Outputs: [key2_3, key1_3, key2_2, key1_2, key2_1, key1_1, key2_0, key1_0]
proc.arrange_words_adjacent
    # => [1_3, 1_2, 1_1, 1_0, 2_3, 2_2, 2_1, 2_0]
    movup.3 movup.7
    # => [2_0, 1_0, 1_3, 1_2, 1_1, 2_3, 2_2, 2_1]
    movup.4 movup.7
    # => [2_1, 1_1, 2_0, 1_0, 1_3, 1_2, 2_3, 2_2]
    movup.5 movup.7
    # => [2_2, 1_2, 2_1, 1_1, 2_0, 1_0, 1_3, 2_3]
    movup.6 movup.7
    # => [2_3, 1_3, 2_2, 1_2, 2_1, 1_1, 2_0, 1_0]
end
