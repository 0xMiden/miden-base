use.std::collections::smt
use.kernel::memory

# TODO: Document security.
# TODO: Document terminology.

# Layout of each map entry:
# [map_ptr, prev_item, next_item, 0, KEY, VALUE]

# Event emitted when an entry is set.
const.LINK_MAP_SET_EVENT=131098

# Event emitted when an entry is fetched.
const.LINK_MAP_GET_EVENT=131099

#! Initializes a new map at the given ptr.
#!
#! The pointer should point to a location of size 12.
#!
#! Inputs:  [map_ptr]
#! Outputs: []
#!
#! Where:
#! - map_ptr is a pointer at which the map will be initialized.
export.new
    # store the map_ptr at map_ptr itself to establish the invariant that each map entry's first
    # element is the map_ptr.
    # dup mem_store
    push.0 assert.err="unused"
end

#! Inserts the specified key-value pair into the map, or updates the existing key if the pair
#! already exists.
#!
#! Inputs:  [map_ptr, KEY, NEW_VALUE]
#! Outputs: [OLD_VALUE]
#!
#! Where:
#! - map_ptr is a pointer to the map.
#! - KEY is the key that will be set in the map.
#! - NEW_VALUE is the value that will be set under KEY. If NEW_VALUE is the EMPTY_WORD then the
#!   pair is removed from the map.
#! - OLD_VALUE is the value that was previously stored at KEY. It will be the EMPTY_WORD if the
#!   value was not previously set.
#!
#! Panics if:
#! - the map ptr does not point to a valid map.
export.set
    # TODO: Should we disallow KEY = EMPTY_WORD?

    dup exec.is_empty
    # => [is_empty, map_ptr, KEY, NEW_VALUE]

    if.true
      # if the list is empty, insert a new entry.
      exec.memory::link_map_malloc
      # => [entry_ptr, map_ptr, KEY, NEW_VALUE]

      dup movdn.10
      # => [entry_ptr, map_ptr, KEY, NEW_VALUE, entry_ptr]
      dup.1 movdn.10
      # => [entry_ptr, map_ptr, KEY, NEW_VALUE, map_ptr, entry_ptr]

      exec.insert_pair
      # => [map_ptr, entry_ptr]

      exec.set_head
      # => []
    else
      emit.LINK_MAP_SET_EVENT adv_push.2
      # => [is_after_entry_ptr, entry_ptr, map_ptr, KEY, NEW_VALUE]
      dup.2 dup.2
      # => [entry_ptr, map_ptr, is_after_entry_ptr, entry_ptr, map_ptr, KEY, NEW_VALUE]

      # assert entry ptr validity
      exec.memory::assert_link_map_entry_ptr
      # => [is_after_entry_ptr, entry_ptr, map_ptr, KEY, NEW_VALUE]

      if.true
        # insert new entry
        push.1 drop
      else
        # update existing entry
        push.2 drop
      end
    end
end

#! Returns the VALUE located at KEY in the given map.
#!
#! Inputs:  [map_ptr, KEY]
#! Outputs: [VALUE]
#!
#! Where:
#! - map_ptr is a pointer to the map.
#! - KEY is the key that will be fetched from the map.
#! - VALUE is the value fetched from the map. If no value was previously set for KEY, the
#!   EMPTY_WORD is returned.
#!
#! Panics if:
#! - the map ptr does not point to a valid map.
export.get
    emit.LINK_MAP_GET_EVENT adv_push.2
    # => [entry_exists, entry_ptr, map_ptr, KEY]

    assert.err="entry does not exist"
    # => [entry_ptr, map_ptr, KEY]

    # assert entry ptr validity
    swap dup.1
    # => [entry_ptr, map_ptr, entry_ptr, KEY]

    exec.memory::assert_link_map_entry_ptr
    # => [entry_ptr, KEY]

    movdn.4
    # => [KEY, entry_ptr]

    dup.4 exec.get_key
    # => [ENTRY_KEY, KEY, entry_ptr]

    assert_eqw.err="key in map entry does not match requested key"
    # => [entry_ptr]

    exec.get_value
    # => [VALUE]
end

#! Computes a commitment of the map over all contained key-value pairs.
#!
#! Inputs:  [map_ptr]
#! Outputs: [MAP_COMMITMENT]
export.compute_commitment
    # while we use an SMT as the underlying implementation, the root is the commitment.
    padw movup.4 mem_loadw
    # => [SMT_ROOT]
end

#! Inserts the key, value into the entry pointer and sets the map ptr to the provided value.
#!
#! Inputs:  [entry_ptr, map_ptr, KEY, VALUE]
#! Outputs: []
proc.insert_pair
  swap dup.1
  # => [entry_ptr, map_ptr, entry_ptr, KEY, VALUE]
  exec.set_map_ptr
  # => [entry_ptr, KEY, VALUE]

  dup movdn.5
  # => [entry_ptr, KEY, entry_ptr, NEW_VALUE]
  exec.set_key

  # => [entry_ptr, NEW_VALUE]
  exec.set_value
end

#! Returns true if the list is empty, i.e. map ptr points to 0.
#!
#! Inputs:  [map_ptr]
#! Outputs: [is_empty]
proc.is_empty
  mem_load eq.0
end

#! Returns true if the entry at the given ptr has a non-null ptr to a next item.
#!
#! Inputs:  [entry_ptr]
#! Outputs: [has_next]
proc.has_next
  exec.get_next_item_ptr eq.0 not
end

#! Returns the value of the next_item pointer in the provided entry pointer.
#!
#! Inputs:  [entry_ptr]
#! Outputs: [next_item_ptr]
proc.get_next_item_ptr
  add.2 mem_load
  # => [next_item_ptr]
end

#! Returns the value of the prev_item pointer in the provided entry pointer.
#!
#! Inputs:  [entry_ptr]
#! Outputs: [prev_item_ptr]
proc.get_prev_item_ptr
  add.1 mem_load
  # => [prev_item_ptr]
end

#! Returns the value of the entry pointer.
#!
#! Inputs:  [entry_ptr]
#! Outputs: [VALUE]
proc.get_value
  padw movup.4
  # => [entry_ptr, pad(4)]
  add.8 mem_loadw
  # => [VALUE]
end

#! Returns the key of the entry pointer.
#!
#! Inputs:  [entry_ptr]
#! Outputs: [KEY]
proc.get_key
  padw movup.4
  # => [entry_ptr, pad(4)]
  add.4 mem_loadw
  # => [KEY]
end

#! Sets the entry ptr as the head of the linked list.
#!
#! Inputs:  [map_ptr, entry_ptr]
#! Outputs: []
proc.set_head
  mem_store
end

#! Sets the map ptr of the entry pointer.
#!
#! Inputs:  [entry_ptr, map_ptr]
#! Outputs: []
proc.set_map_ptr
  mem_store
end

#! Sets the key of the entry pointer.
#!
#! Inputs:  [entry_ptr, KEY]
#! Outputs: []
proc.set_key
  add.4 mem_storew dropw
end

#! Sets the value of the entry pointer.
#!
#! Inputs:  [entry_ptr, VALUE]
#! Outputs: []
proc.set_value
  add.8 mem_storew dropw
end