use.std::crypto::hashes::rpo

use.$kernel::constants
use.$kernel::memory

# ERRORS
# =================================================================================================

const.ERR_NOTE_ATTEMPT_TO_ACCESS_NOTE_SENDER_FROM_INCORRECT_CONTEXT="attempted to access note sender from incorrect context"

const.ERR_NOTE_ATTEMPT_TO_ACCESS_NOTE_ASSETS_FROM_INCORRECT_CONTEXT="attempted to access note assets from incorrect context"

const.ERR_NOTE_ATTEMPT_TO_ACCESS_NOTE_INPUTS_FROM_INCORRECT_CONTEXT="attempted to access note inputs from incorrect context"

# CURRENTLY EXECUTING NOTE PROCEDURES
# =================================================================================================

#! Returns the sender of the note currently being processed.
#!
#! Inputs:  []
#! Outputs: [sender_id_prefix, sender_id_suffix]
#!
#! Where:
#! - sender_{prefix,suffix} are the prefix and suffix felts of the sender of the note currently
#!   being processed.
#!
#! Panics if:
#! - the note is not being processed.
export.get_sender
    # get the current input note pointer
    exec.memory::get_current_input_note_ptr
    # => [ptr]

    # assert the pointer is not zero - this would suggest the procedure has been called from an
    # incorrect context
    dup neq.0 assert.err=ERR_NOTE_ATTEMPT_TO_ACCESS_NOTE_SENDER_FROM_INCORRECT_CONTEXT
    # => [ptr]

    # get the sender from the note pointer
    exec.memory::get_input_note_sender
    # => [sender_id_prefix, sender_id_suffix]
end

#! Returns the number of assets and the assets commitment of the note currently being processed.
#!
#! Inputs:  []
#! Outputs: [ASSETS_COMMITMENT, num_assets]
#!
#! Where:
#! - num_assets is the number of assets in the note currently being processed.
#! - ASSETS_COMMITMENT is a sequential hash of the assets in the note currently being processed.
#!
#! Panics if:
#! - the note is not being processed.
export.get_assets_info
    # get the current input note pointer
    exec.memory::get_current_input_note_ptr
    # => [ptr]

    # assert the pointer is not zero - this would suggest the procedure has been called from an
    # incorrect context
    dup neq.0 assert.err=ERR_NOTE_ATTEMPT_TO_ACCESS_NOTE_ASSETS_FROM_INCORRECT_CONTEXT
    # => [ptr]

    # get the number of assets in the note
    dup exec.memory::get_input_note_num_assets
    # => [num_assets, ptr]

    # get the assets commitment from the note pointer
    swap exec.memory::get_input_note_assets_commitment
    # => [ASSETS_COMMITMENT, num_assets]
end

#! Returns the commitment to the note's inputs.
#!
#! Inputs:  []
#! Outputs: [NOTE_INPUTS_COMMITMENT]
#!
#! Where:
#! - NOTE_INPUTS_COMMITMENT is the note inputs commitment of the note currently being processed.
#!
#! Panics if:
#! - the note is not being processed.
export.get_note_inputs_commitment
    exec.memory::get_current_input_note_ptr
    # => [ptr]

    # The kernel memory is initialized by prologue::process_input_notes_data, and reset by
    # note_processing_teardown before running the tx_script. If the value is `0` it is likely this
    # procedure is being called outside of the kernel context.
    dup neq.0 assert.err=ERR_NOTE_ATTEMPT_TO_ACCESS_NOTE_INPUTS_FROM_INCORRECT_CONTEXT
    # => [ptr]

    exec.memory::get_input_note_inputs_commitment
    # => [NOTE_INPUTS_COMMITMENT]
end

#! Returns the serial number of the note currently being processed.
#!
#! Inputs:  []
#! Outputs: [SERIAL_NUMBER]
#!
#! Where:
#! - SERIAL_NUMBER is the serial number of the note currently being processed.
#!
#! Panics if:
#! - no note is being processed.
export.get_serial_number
    exec.memory::get_current_input_note_ptr
    # => [note_ptr, ...]

    exec.memory::get_input_note_serial_num
    # => [SERIAL_NUMBER, ...]
end

#! Returns the script root of the note currently being processed.
#!
#! Inputs:  []
#! Outputs: [SCRIPT_ROOT]
#!
#! Where:
#! - SCRIPT_ROOT is the serial number of the note currently being processed.
#!
#! Panics if:
#! - no note is being processed.
export.get_script_root
    exec.memory::get_current_input_note_ptr
    # => [note_ptr]

    exec.memory::get_input_note_script_root
    # => [SCRIPT_ROOT]
end