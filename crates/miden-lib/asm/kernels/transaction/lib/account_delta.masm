use.kernel::memory
use.kernel::link_map
use.kernel::constants
use.kernel::account
use.std::crypto::hashes::rpo

# CONSTANTS
# =================================================================================================

# The domain of an asset in the delta commitment.
const.DOMAIN_ASSET=1
# The domain of a value storage slot in the delta commitment.
const.DOMAIN_VALUE=2
# The domain of a map storage slot in the delta commitment.
const.DOMAIN_MAP=3

# PROCEDURES
# =================================================================================================

# DELTA COMPUTATION
# -------------------------------------------------------------------------------------------------

#! Computes the commitment to the native account's delta.
#!
#! See the Rust function `AccountDelta::commitment` for a detailed description of how it is computed.
#!
#! Inputs:  []
#! Outputs: [DELTA_COMMITMENT]
#!
#! Where:
#! - DELTA_COMMITMENT is the commitment to the account delta.
export.compute_commitment
    # pad capacity element of the hasher
    padw
    # => [CAPACITY]

    exec.memory::get_account_nonce_delta push.0
    # => [0, nonce_delta, CAPACITY]

    exec.memory::get_native_account_id
    # => [native_acct_id_prefix, native_acct_id_suffix, 0, nonce_delta, CAPACITY]
    # => [ID_AND_NONCE, CAPACITY]

    padw
    # => [EMPTY_WORD, ID_AND_NONCE, CAPACITY]

    hperm
    # => [RATE, RATE, PERM]

    exec.update_fungible_asset_delta
    # => [RATE, RATE, PERM]

    exec.update_storage_delta
    # => [RATE, RATE, PERM]

    exec.rpo::squeeze_digest
    # => [DELTA_COMMITMENT]
end

#! Updates the given delta hasher with the storage slots.
#!
#! Inputs:  [RATE, RATE, PERM]
#! Outputs: [RATE, RATE, PERM]
proc.update_storage_delta
    exec.memory::get_num_storage_slots movdn.12
    # => [RATE, RATE, PERM, num_storage_slots]

    push.0 movdn.12
    # => [RATE, RATE, PERM, slot_idx = 0, num_storage_slots]

    # loop if num_storage_slots != 0
    dup.13 neq.0
    # => [should_loop, RATE, RATE, PERM, slot_idx, num_storage_slots]

    while.true
        dup.12
        # => [slot_idx, RATE, RATE, PERM, slot_idx, num_storage_slots]

        exec.update_slot_delta
        # => [RATE, RATE, PERM, slot_idx, num_storage_slots]

        # increment slot index
        movup.12 add.1
        # => [next_slot_idx, RATE, RATE, PERM, num_storage_slots]

        dup movdn.13
        # => [next_slot_idx, RATE, RATE, PERM, next_slot_idx, num_storage_slots]

        # compute next_slot_idx < num_storage_slots
        dup.14 lt
        # => [should_loop, RATE, RATE, PERM, next_slot_idx, num_storage_slots]
    end
    # => [RATE, RATE, PERM, next_slot_idx, num_storage_slots]

    # clean the stack
    movup.12 drop movup.12 drop
    # => [RATE, RATE, PERM]
end

#! Updates the given delta hasher with the storage slot at the provided index.
#!
#! Inputs:  [slot_idx, RATE, RATE, PERM]
#! Outputs: [RATE, RATE, PERM]
proc.update_slot_delta
    # we use memory::get_storage_slot_type instead of the procedure in account to
    # avoid the assertion overhead
    dup exec.memory::get_native_account_storage_slots_ptr
    # => [native_account_storage_slots_section_ptr, slot_idx, slot_idx, RATE, RATE, PERM]

    exec.memory::get_storage_slot_type
    # => [storage_slot_type, slot_idx, RATE, RATE, PERM]

    # check if type == slot
    exec.constants::get_storage_slot_type_value eq
    # => [is_value_slot_type, slot_idx, RATE, RATE, PERM]

    if.true
        exec.update_value_slot_delta
    else
      # TODO: Update delta hasher with map.
      # drop slot idx
      drop
    end
end

#! Updates the given delta hasher with the value storage slot at the provided index.
#!
#! Inputs:  [slot_idx, RATE, RATE, PERM]
#! Outputs: [RATE, RATE, PERM]
proc.update_value_slot_delta
    dup exec.account::get_item
    # => [CURRENT_VALUE, slot_idx, RATE, RATE, PERM]

    dup.4 exec.get_item_initial
    # => [INIT_VALUE, CURRENT_VALUE, slot_idx, RATE, RATE, PERM]

    eqw not
    # => [was_changed, INIT_VALUE, CURRENT_VALUE, slot_idx, RATE, RATE, PERM]

    # only include in delta if the slot's value has changed
    if.true
      # drop init value
      dropw
      # => [CURRENT_VALUE, slot_idx, RATE, RATE, PERM]

      # build value slot metadata
      push.DOMAIN_VALUE
      # => [domain, CURRENT_VALUE, slot_idx, RATE, RATE, PERM]

      movup.5 push.0.0
      # => [0, 0, slot_idx, domain, CURRENT_VALUE, RATE, RATE, PERM]

      # clear rate elements
      swapdw dropw dropw
      # => [0, 0, slot_idx, domain, CURRENT_VALUE, PERM]

      # arrange rate words in correct order
      swapw
      # => [CURRENT_VALUE, 0, 0, slot_idx, domain, PERM]

      hperm
      # => [RATE, RATE, PERM]
    else
      # drop init value, current value and slot idx
      dropw dropw drop
      # => [RATE, RATE, PERM]
    end
    # => [RATE, RATE, PERM]
end

#! Updates the given delta hasher with the fungible asset vault delta.
#!
#! Inputs:  [RATE, RATE, PERM]
#! Outputs: [RATE, RATE, PERM]
proc.update_fungible_asset_delta.2
    exec.memory::get_account_delta_fungible_asset_ptr
    # => [account_delta_fungible_asset_ptr, RATE, RATE, PERM]

    exec.link_map::iter
    # => [has_next, iter, RATE, RATE, PERM]

    # enter loop if the link map is not empty
    while.true
        exec.link_map::next_key_value
        # => [KEY, VALUE0, has_next, iter, ...]

        # store has_next
        movup.8 loc_store.0
        # => [KEY, VALUE0, iter, ...]

        # store iter
        movup.8 loc_store.1
        # => [KEY, VALUE0, ...]
        # this stack state is equivalent to:
        # => [[faucet_id_prefix, faucet_id_suffix, 0, 0], [delta_amount_hi, delta_amount_lo, 0, 0], ...]

        swapw
        # => [[delta_amount_hi, delta_amount_lo, 0, 0], [faucet_id_prefix, faucet_id_suffix, 0, 0], ...]

        exec.i64_unsigned_abs not
        # => [is_amount_unsigned, [delta_amount_abs_hi, delta_amount_abs_lo, 0, 0], ...]

        # rename is_amount_unsigned to was_added
        movdn.3
        # => [[delta_amount_abs_hi, delta_amount_abs_lo, 0, was_added,  0], ...]

        # reassemble the delta amount to a felt by multiplying the high part with 2^32 and adding the lo part
        # this is safe to do because the delta amount is in range [-2^63 + 1, 2^63 - 1], so its
        # absolute value will fit into a felt.
        mul.0x0100000000 add
        # => [[delta_amount_abs, 0, was_added, 0], [faucet_id_prefix, faucet_id_suffix, 0, 0], ...]

        dup neq.0
        # => [is_delta_amount_non_zero, [delta_amount_abs, 0, was_added, 0], [faucet_id_prefix, faucet_id_suffix, 0, 0], ...]

        # if delta amount is non-zero, update the hasher
        if.true
            movup.5 movdn.2
            # => [faucet_id_prefix, faucet_id_suffix, delta_amount_lo, 0, 0, delta_amount_hi, 0, 0, ...]

            movup.5 movdn.3
            # => [[faucet_id_prefix, faucet_id_suffix, delta_amount_lo, delta_amount_hi], 0, 0, 0, 0, ...]

            push.DOMAIN_ASSET swap.8 drop
            # => [[faucet_id_prefix, faucet_id_suffix, amount_lo, amount_hi], [0, 0, 0, domain], RATE, RATE, PERM

            # drop previous RATE elements
            swapdw dropw dropw
            # => [[faucet_id_prefix, faucet_id_suffix, amount_lo, amount_hi], [0, 0, 0, domain], PERM]

            hperm
            # => [RATE, RATE, PERM]
        else
          # discard values loaded from map: KEY, VALUE0
          dropw dropw
          # => [RATE, RATE, PERM]
        end
        # => [RATE, RATE, PERM]

        # load iter and has_next
        loc_load.1
        # => [iter, RATE, RATE, PERM]

        loc_load.0
        # => [has_next, iter, RATE, RATE, PERM]
    end

    # drop iter
    drop
    # => [RATE, RATE, PERM]
end

#! Returns the initial value of a storage slot from the account storage.
#!
#! This is the value of the slot at the beginning of the transaction.
#!
#! If this this procedure is moved to the account, additional assertions are necessary to make it
#! safe to use.
#!
#! Note: Assumes the index is within bounds.
#!
#! Inputs:  [index]
#! Outputs: [INIT_VALUE]
proc.get_item_initial
    # get account storage slots section offset
    exec.memory::get_native_account_initial_storage_slots_ptr
    # => [account_delta_initial_storage_slots_ptr, index]

    # get the item from storage
    swap mul.8 add padw movup.4 mem_loadw
    # => [INIT_VALUE]
end

# DELTA BOOKKEEPING
# -------------------------------------------------------------------------------------------------

#! Adds the given amount to the fungible asset delta for the asset identified by the asset key.
#!
#! Inputs:  [ASSET_KEY, amount]
#! Outputs: []
#!
#! Where:
#! - ASSET_KEY is the asset key of the fungible asset.
#! - amount is the amount by which the fungible asset's amount increases.
export.add_fungible_asset
    dupw exec.memory::get_account_delta_fungible_asset_ptr
    # => [fungible_delta_map_ptr, ASSET_KEY, ASSET_KEY, amount]

    # retrieve the current delta amount
    # contains_key can be ignored because the default value is a delta amount of 0
    # VALUE1 is unused so we drop it as well
    exec.link_map::get drop swapw dropw
    # => [delta_amount_hi, delta_amount_lo, 0, 0, ASSET_KEY, amount]

    movup.8 u32split
    # => [amount_hi, amount_lo, delta_amount_hi, delta_amount_lo, 0, 0, ASSET_KEY]

    # compute delta + amount
    exec.add_asset_amount
    # => [delta_amount_hi, delta_amount_lo, 0, 0, ASSET_KEY]

    # pad VALUE1 of the link map
    swapw padw movdnw.2
    # => [ASSET_KEY, delta_amount_hi, delta_amount_lo, 0, 0, EMPTY_WORD]

    exec.memory::get_account_delta_fungible_asset_ptr
    # => [fungible_delta_map_ptr, ASSET_KEY, delta_amount_hi, delta_amount_lo, 0, 0, EMPTY_WORD]

    exec.link_map::set drop
    # => []
end

#! Subtracts the given amount from the fungible asset delta for the asset identified by the asset key.
#!
#! Inputs:  [ASSET_KEY, amount]
#! Outputs: []
#!
#! Where:
#! - ASSET_KEY is the asset key of the fungible asset.
#! - amount is the amount by which the fungible asset's amount decreases.
export.remove_fungible_asset
    dupw exec.memory::get_account_delta_fungible_asset_ptr
    # => [fungible_delta_map_ptr, ASSET_KEY, ASSET_KEY, amount]

    # retrieve the current delta amount
    # contains_key can be ignored because the default value is a delta amount of 0
    # VALUE1 is unused so we drop it as well
    exec.link_map::get drop swapw dropw
    # => [delta_amount_hi, delta_amount_lo, 0, 0, ASSET_KEY, amount]

    movup.8 u32split
    # => [amount_hi, amount_lo, delta_amount_hi, delta_amount_lo, 0, 0, ASSET_KEY]

    # compute delta - amount
    exec.sub_asset_amount
    # => [delta_amount_hi, delta_amount_lo, 0, 0, ASSET_KEY]

    # pad VALUE1 of the link map
    swapw padw movdnw.2
    # => [ASSET_KEY, delta_amount_hi, delta_amount_lo, 0, 0, EMPTY_WORD]

    exec.memory::get_account_delta_fungible_asset_ptr
    # => [fungible_delta_map_ptr, ASSET_KEY, delta_amount_hi, delta_amount_lo, 0, 0, EMPTY_WORD]

    exec.link_map::set drop
    # => []
end

#! TODO: Document asset amount math.
#!
#! Inputs:  [amount_hi, amount_lo, delta_amount_hi, delta_amount_lo]
#! Outputs: [delta_amount_hi, delta_amount_lo]
proc.add_asset_amount
    exec.::std::math::u64::wrapping_add
end

#! TODO: Document asset amount math.
#!
#! Inputs:  [amount_hi, amount_lo, delta_amount_hi, delta_amount_lo]
#! Outputs: [delta_amount_hi, delta_amount_lo]
proc.sub_asset_amount
    exec.::std::math::u64::wrapping_sub
end