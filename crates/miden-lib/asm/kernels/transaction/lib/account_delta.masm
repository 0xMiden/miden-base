use.kernel::memory
use.kernel::link_map
use.kernel::constants
use.kernel::account
use.std::crypto::hashes::rpo
use.std::math::u64

# CONSTANTS
# =================================================================================================

# The domain of an asset in the delta commitment.
const.DOMAIN_ASSET=1
# The domain of a value storage slot in the delta commitment.
const.DOMAIN_VALUE=2
# The domain of a map storage slot in the delta commitment.
const.DOMAIN_MAP=3

# PROCEDURES
# =================================================================================================

# DELTA COMPUTATION
# -------------------------------------------------------------------------------------------------

#! Computes the commitment to the native account's delta.
#!
#! See the Rust function `AccountDelta::commitment` for a detailed description of how it is computed.
#!
#! Inputs:  []
#! Outputs: [DELTA_COMMITMENT]
#!
#! Where:
#! - DELTA_COMMITMENT is the commitment to the account delta.
export.compute_commitment
    # pad capacity element of the hasher
    padw
    # => [CAPACITY]

    exec.memory::get_account_nonce_delta push.0
    # => [0, nonce_delta, CAPACITY]

    exec.memory::get_native_account_id
    # => [native_acct_id_prefix, native_acct_id_suffix, 0, nonce_delta, CAPACITY]
    # => [ID_AND_NONCE, CAPACITY]

    padw
    # => [EMPTY_WORD, ID_AND_NONCE, CAPACITY]

    hperm
    # => [RATE, RATE, PERM]

    exec.update_fungible_asset_delta
    # => [RATE, RATE, PERM]

    exec.update_storage_delta
    # => [RATE, RATE, PERM]

    exec.rpo::squeeze_digest
    # => [DELTA_COMMITMENT]
end

#! Updates the given delta hasher with the storage slots.
#!
#! Inputs:  [RATE, RATE, PERM]
#! Outputs: [RATE, RATE, PERM]
proc.update_storage_delta
    exec.memory::get_num_storage_slots movdn.12
    # => [RATE, RATE, PERM, num_storage_slots]

    push.0 movdn.12
    # => [RATE, RATE, PERM, slot_idx = 0, num_storage_slots]

    # loop if num_storage_slots != 0
    dup.13 neq.0
    # => [should_loop, RATE, RATE, PERM, slot_idx, num_storage_slots]

    while.true
        dup.12
        # => [slot_idx, RATE, RATE, PERM, slot_idx, num_storage_slots]

        exec.update_slot_delta
        # => [RATE, RATE, PERM, slot_idx, num_storage_slots]

        # increment slot index
        movup.12 add.1
        # => [next_slot_idx, RATE, RATE, PERM, num_storage_slots]

        dup movdn.13
        # => [next_slot_idx, RATE, RATE, PERM, next_slot_idx, num_storage_slots]

        # compute next_slot_idx < num_storage_slots
        dup.14 lt
        # => [should_loop, RATE, RATE, PERM, next_slot_idx, num_storage_slots]
    end
    # => [RATE, RATE, PERM, next_slot_idx, num_storage_slots]

    # clean the stack
    movup.12 drop movup.12 drop
    # => [RATE, RATE, PERM]
end

#! Updates the given delta hasher with the storage slot at the provided index.
#!
#! Inputs:  [slot_idx, RATE, RATE, PERM]
#! Outputs: [RATE, RATE, PERM]
proc.update_slot_delta
    # we use memory::get_storage_slot_type instead of the procedure in account to
    # avoid the assertion overhead
    dup exec.memory::get_native_account_storage_slots_ptr
    # => [native_account_storage_slots_section_ptr, slot_idx, slot_idx, RATE, RATE, PERM]

    exec.memory::get_storage_slot_type
    # => [storage_slot_type, slot_idx, RATE, RATE, PERM]

    # check if type == slot
    exec.constants::get_storage_slot_type_value eq
    # => [is_value_slot_type, slot_idx, RATE, RATE, PERM]

    if.true
        exec.update_value_slot_delta
    else
        # TODO: Update delta hasher with map.
        # drop slot idx
        drop
    end
end

#! Updates the given delta hasher with the value storage slot at the provided index.
#!
#! Inputs:  [slot_idx, RATE, RATE, PERM]
#! Outputs: [RATE, RATE, PERM]
proc.update_value_slot_delta
    dup exec.account::get_item
    # => [CURRENT_VALUE, slot_idx, RATE, RATE, PERM]

    dup.4 exec.get_item_initial
    # => [INIT_VALUE, CURRENT_VALUE, slot_idx, RATE, RATE, PERM]

    eqw not
    # => [was_changed, INIT_VALUE, CURRENT_VALUE, slot_idx, RATE, RATE, PERM]

    # only include in delta if the slot's value has changed
    if.true
        # drop init value
        dropw
        # => [CURRENT_VALUE, slot_idx, RATE, RATE, PERM]

        # build value slot metadata
        push.DOMAIN_VALUE
        # => [domain, CURRENT_VALUE, slot_idx, RATE, RATE, PERM]

        movup.5 push.0.0
        # => [0, 0, slot_idx, domain, CURRENT_VALUE, RATE, RATE, PERM]

        # clear rate elements
        swapdw dropw dropw
        # => [0, 0, slot_idx, domain, CURRENT_VALUE, PERM]

        # arrange rate words in correct order
        swapw
        # => [CURRENT_VALUE, 0, 0, slot_idx, domain, PERM]

        hperm
        # => [RATE, RATE, PERM]
    else
        # drop init value, current value and slot idx
        dropw dropw drop
        # => [RATE, RATE, PERM]
    end
    # => [RATE, RATE, PERM]
end

#! Updates the given delta hasher with the fungible asset vault delta.
#!
#! Inputs:  [RATE, RATE, PERM]
#! Outputs: [RATE, RATE, PERM]
proc.update_fungible_asset_delta.2
    exec.memory::get_account_delta_fungible_asset_ptr
    # => [account_delta_fungible_asset_ptr, RATE, RATE, PERM]

    exec.link_map::iter
    # => [has_next, iter, RATE, RATE, PERM]

    # enter loop if the link map is not empty
    while.true
        exec.link_map::next_key_value
        # => [KEY, VALUE0, has_next, iter, ...]

        # store has_next
        movup.8 loc_store.0
        # => [KEY, VALUE0, iter, ...]

        # store iter
        movup.8 loc_store.1
        # => [KEY, VALUE0, ...]
        # this stack state is equivalent to:
        # => [[faucet_id_prefix, faucet_id_suffix, 0, 0], [delta_amount_hi, delta_amount_lo, 0, 0], ...]

        swapw
        # => [[delta_amount_hi, delta_amount_lo, 0, 0], [faucet_id_prefix, faucet_id_suffix, 0, 0], ...]

        exec.i64_unsigned_abs not
        # => [is_amount_unsigned, [delta_amount_abs_hi, delta_amount_abs_lo, 0, 0], ...]

        # rename is_amount_unsigned to was_added
        movdn.3
        # => [[delta_amount_abs_hi, delta_amount_abs_lo, 0, was_added,  0], ...]

        # reassemble the delta amount to a felt by multiplying the high part with 2^32 and adding the lo part
        # this is safe to do because the delta amount is in range [-2^63 + 1, 2^63 - 1], so its
        # absolute value will fit into a felt.
        mul.0x0100000000 add
        # => [[delta_amount_abs, 0, was_added, 0], [faucet_id_prefix, faucet_id_suffix, 0, 0], ...]

        dup neq.0
        # => [is_delta_amount_non_zero, [delta_amount_abs, 0, was_added, 0], [faucet_id_prefix, faucet_id_suffix, 0, 0], ...]

        # if delta amount is non-zero, update the hasher
        if.true
            swap.7
            # => [[0, 0, was_added, 0], [faucet_id_prefix, faucet_id_suffix, 0, delta_amount_abs], ...]

            drop push.DOMAIN_ASSET
            # => [[domain, 0, was_added, 0], [faucet_id_prefix, faucet_id_suffix, 0, delta_amount_abs], ...]

            swap.3
            # => [[0, 0, was_added, domain], [faucet_id_prefix, faucet_id_suffix, 0, delta_amount_abs], ...]

            swapw
            # => [[faucet_id_prefix, faucet_id_suffix, 0, delta_amount_abs], [0, 0, was_added, domain], RATE, RATE, PERM]

            # drop previous RATE elements
            swapdw dropw dropw
            # => [[faucet_id_prefix, faucet_id_suffix, 0, delta_amount_abs], [0, 0, was_added, domain], PERM]

            hperm
            # => [RATE, RATE, PERM]
        else
            # discard values loaded from map: KEY, VALUE0
            dropw dropw
            # => [RATE, RATE, PERM]
        end
        # => [RATE, RATE, PERM]

        # load iter and has_next
        loc_load.1
        # => [iter, RATE, RATE, PERM]

        loc_load.0
        # => [has_next, iter, RATE, RATE, PERM]
    end

    # drop iter
    drop
    # => [RATE, RATE, PERM]
end

#! Returns the initial value of a storage slot from the account storage.
#!
#! This is the value of the slot at the beginning of the transaction.
#!
#! If this this procedure is moved to the account, additional assertions are necessary to make it
#! safe to use.
#!
#! Note: Assumes the index is within bounds.
#!
#! Inputs:  [index]
#! Outputs: [INIT_VALUE]
proc.get_item_initial
    # get account storage slots section offset
    exec.memory::get_native_account_initial_storage_slots_ptr
    # => [account_delta_initial_storage_slots_ptr, index]

    # get the item from storage
    swap mul.8 add padw movup.4 mem_loadw
    # => [INIT_VALUE]
end

# DELTA BOOKKEEPING
# -------------------------------------------------------------------------------------------------

#! Adds the given amount to the fungible asset delta for the asset identified by the asset key.
#!
#! Inputs:  [ASSET_KEY, amount]
#! Outputs: []
#!
#! Where:
#! - ASSET_KEY is the asset key of the fungible asset.
#! - amount is the amount by which the fungible asset's amount increases.
export.add_fungible_asset
    dupw exec.memory::get_account_delta_fungible_asset_ptr
    # => [fungible_delta_map_ptr, ASSET_KEY, ASSET_KEY, amount]

    # retrieve the current delta amount
    # contains_key can be ignored because the default value is a delta amount of 0
    # VALUE1 is unused so we drop it as well
    exec.link_map::get drop swapw dropw
    # => [delta_amount_hi, delta_amount_lo, 0, 0, ASSET_KEY, amount]

    movup.8 u32split
    # => [amount_hi, amount_lo, delta_amount_hi, delta_amount_lo, 0, 0, ASSET_KEY]

    # compute delta + amount
    exec.add_asset_amount
    # => [delta_amount_hi, delta_amount_lo, 0, 0, ASSET_KEY]

    # pad VALUE1 of the link map
    swapw padw movdnw.2
    # => [ASSET_KEY, delta_amount_hi, delta_amount_lo, 0, 0, EMPTY_WORD]

    exec.memory::get_account_delta_fungible_asset_ptr
    # => [fungible_delta_map_ptr, ASSET_KEY, delta_amount_hi, delta_amount_lo, 0, 0, EMPTY_WORD]

    exec.link_map::set drop
    # => []
end

#! Subtracts the given amount from the fungible asset delta for the asset identified by the asset key.
#!
#! Inputs:  [ASSET_KEY, amount]
#! Outputs: []
#!
#! Where:
#! - ASSET_KEY is the asset key of the fungible asset.
#! - amount is the amount by which the fungible asset's amount decreases.
export.remove_fungible_asset
    dupw exec.memory::get_account_delta_fungible_asset_ptr
    # => [fungible_delta_map_ptr, ASSET_KEY, ASSET_KEY, amount]

    # retrieve the current delta amount
    # contains_key can be ignored because the default value is a delta amount of 0
    # VALUE1 is unused so we drop it as well
    exec.link_map::get drop swapw dropw
    # => [delta_amount_hi, delta_amount_lo, 0, 0, ASSET_KEY, amount]

    movup.8 u32split
    # => [amount_hi, amount_lo, delta_amount_hi, delta_amount_lo, 0, 0, ASSET_KEY]

    # compute delta - amount
    exec.sub_asset_amount
    # => [delta_amount_hi, delta_amount_lo, 0, 0, ASSET_KEY]

    # pad VALUE1 of the link map
    swapw padw movdnw.2
    # => [ASSET_KEY, delta_amount_hi, delta_amount_lo, 0, 0, EMPTY_WORD]

    exec.memory::get_account_delta_fungible_asset_ptr
    # => [fungible_delta_map_ptr, ASSET_KEY, delta_amount_hi, delta_amount_lo, 0, 0, EMPTY_WORD]

    exec.link_map::set drop
    # => []
end

# i64 MATH
# -------------------------------------------------------------------------------------------------

# Asset Amount Deltas can be signed or unsigned and they can be in range [-2^63 + 1, 2^63 - 1]. To make
# math operations on deltas easy and avoid branches, they are represented using the std::math::u64
# representation of two u32 limbs. This u64 can be interpreted as an i64 to get the asset delta.
# In order to get the correct behavior, we use wrapping operations on u64s which ignore the overflow.
# This means that a calculation such as 100 - 200 + 300 correctly results in an overall delta of 200.

#! Adds amount to the delta.
#!
#! Inputs:  [amount_hi, amount_lo, delta_amount_hi, delta_amount_lo]
#! Outputs: [delta_amount_hi, delta_amount_lo]
#!
#! Where:
#! - amount_{hi, lo} are the u32 limbs of the amount to be added.
#! - delta_amount_{hi, lo} are the u32 limbs of the delta amount to which amount is added.
proc.add_asset_amount
    exec.u64::wrapping_add
end

#! Subtracts amount from the delta.
#!
#! Inputs:  [amount_hi, amount_lo, delta_amount_hi, delta_amount_lo]
#! Outputs: [delta_amount_hi, delta_amount_lo]
#!
#! Where:
#! - amount_{hi, lo} are the u32 limbs of the amount to be subtracted.
#! - delta_amount_{hi, lo} are the u32 limbs of the delta amount from which amount is subtracted.
proc.sub_asset_amount
    exec.u64::wrapping_sub
end

#! Computes the absolute value of the given i64 represented by two u32 limbs and returns a
#! boolean flag indicating whether the value is signed.
#!
#! Inputs: [x_hi, x_lo]
#! Outputs: [is_x_signed, x_abs_hi, x_abs_lo]
#!
#! Where:
#! - x_{hi, lo} are the u32 limbs of an i64.
#! - is_x_signed indicates whether x is signed.
#! - x_abs_{hi, lo} are the absolute u32 limbs of a u64.
proc.i64_unsigned_abs
    exec.i64_is_signed
    # => [is_x_signed, x_hi, x_lo]

    movdn.2 push.0.0
    # => [0, 0, x_hi, x_lo, is_x_signed]

    dup.3 dup.3
    # => [x_hi, x_lo, 0, 0, x_hi, x_lo, is_x_signed]

    exec.i64_neg push.0.0
    # => [0, 0, x_neg_hi, x_neg_lo, 0, 0, x_hi, x_lo, is_x_signed]

    dup.8
    # => [is_x_signed, 0, 0, x_neg_hi, x_neg_lo, 0, 0, x_hi, x_lo, is_x_signed]

    # If is_x_signed the word with the negated values remains.
    # If !is_x_signed the word with the original values remains.
    cdropw drop drop
    # => [x_abs_hi, x_abs_lo, is_x_signed]

    movup.2
    # => [is_x_signed, x_abs_hi, x_abs_lo]
end

#! Returns 1 if the given number is signed (its most significant bit is set)
#! without consuming its inputs, 0 otherwise.
#!
#! Inputs: [x_hi, x_lo]
#! Outputs: [is_x_signed, x_hi, x_lo]
#!
#! Where:
#! - x_{hi, lo} are the u32 limbs of an i64.
#! - is_x_signed indicates whether x is signed.
proc.i64_is_signed
    # 0x80000000 is a u32 bitmask with highest bit set to 1 and all others to 0.
    dup u32and.0x80000000 u32shr.31
    # => [is_signed, x_hi, x_lo]
end

#! Negates an i64 represented by two u32 limbs by computing its bitwise NOT and adding 1
#! according to two complements.
#!
#! Inputs: [x_hi, x_lo]
#! Outputs: [x_hi, x_lo]
#!
#! Where:
#! - x_{hi, lo} are the u32 limbs of an i64.
proc.i64_neg
    u32not swap u32not swap
    # => [x_inverted_hi, x_inverted_lo]

    # Add 1 to get negative x.
    push.1.0
    # => [0, 1, x_inverted_hi, x_inverted_lo]

    # This should never overflow except when negating zero.
    # (Consider this 8-bit example: 0b0000_0000 would become 0b1111_1111
    # and adding 1 would overflow the byte resulting in 0b0000_0000 again).
    # This is why we ignore the overflow flag.
    exec.u64::wrapping_add
    # => [-x_hi, -x_lo]
end
