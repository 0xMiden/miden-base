use.miden::account
use.miden::account_id
use.miden::active_note
use.miden::contracts::faucets::basic_fungible

# CONSTANTS
# ================================================================================================

# The slot in this component's storage layout where the owner config is stored.
const.OWNER_CONFIG_SLOT=1

# ERRORS
const.ERR_NOT_OWNER="note sender is not owner"

const.ERR_INVALID_NUM_ASSETS="note contained more than one asset during burn invocation"

# => []
proc.is_owner
    push.OWNER_CONFIG_SLOT
    # => [owner_config_slot]

    exec.account::get_item
    # => [owner_prefix, owner_suffix, 0, 0]

    exec.active_note::get_sender
    # => [sender_prefix, sender_suffix, owner_prefix, owner_suffix, 0, 0]

    exec.account_id::is_equal
    # => [are_equal, 0, 0]

    swap drop swap drop
    # => [is_owner]
end

#! Inputs: [amount, tag, aux, note_type, execution_hint, RECIPIENT]
#! Outputs: [note_idx]
export.distribute
    exec.is_owner
    # => [is_owner, amount, tag, aux, note_type, execution_hint, RECIPIENT]

    assert.err=ERR_NOT_OWNER
    # => [amount, tag, aux, note_type, execution_hint, RECIPIENT]

    exec.basic_fungible::distribute
    # => [note_idx]
end

#! Inputs: []
#! Outputs: [ASSET]
export.burn
    push.0 exec.active_note::get_assets
    # => [num_assets, dest_ptr]

    # This assert enforces both that execution is in a note context and that the note contains exactly one asset.
    # If not in a note context, get_assets will return 0, causing the assert to fail.
    # If the note contains more than one asset, the assert will also fail.
    assert.err=ERR_INVALID_NUM_ASSETS
    # => [dest_ptr]

    mem_loadw
    # => [ASSET]

    exec.basic_fungible::burn
    # => [ASSET]
end