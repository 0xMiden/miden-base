use.miden::account_id
use.std::crypto::hashes::rpo
use.std::mem

#Â ERRORS
# =================================================================================================

const.ERR_PROLOGUE_NOTE_INPUTS_LEN_EXCEEDED_LIMIT="number of note inputs exceeded the maximum limit of 128"

# CONSTANTS
# =================================================================================================

const.RECIPIENT_DATA_ADVICE_STACK_LENGTH=13

# NOTE UTILITY PROCEDURES
# =================================================================================================

#! Computes the commitment to the note inputs starting at the specified memory address.
#!
#! This procedure checks that the provided number of note inputs is within limits and then computes
#! the commitment.
#!
#! Notice that the note inputs are padded with zeros in case their number is not a multiple of 8.
#!
#! If the number of note inputs is 0, procedure returns the empty word: [0, 0, 0, 0].
#!
#! Inputs:  [inputs_ptr, num_inputs]
#! Outputs: [INPUTS_COMMITMENT]
#!
#! Cycles:
#! - If number of elements divides by 8: 56 cycles + 3 * words
#! - Else: 189 cycles + 3 * words
#!
#! Panics if:
#! - inputs_ptr is not word-aligned (i.e., is not a multiple of 4).
#! - num_inputs is greater than 128.
#!
#! Invocation: exec
export.compute_inputs_commitment
    # check that number of inputs is less than 128
    dup.1 push.128 u32assert2.err=ERR_PROLOGUE_NOTE_INPUTS_LEN_EXCEEDED_LIMIT
    u32lte assert.err=ERR_PROLOGUE_NOTE_INPUTS_LEN_EXCEEDED_LIMIT
    # => [inputs_ptr, num_inputs]

    # push 1 as the pad_inputs flag: we should pad the stack while computing the note inputs
    # commitment
    push.1 movdn.2
    # => [inputs_ptr, num_inputs, pad_inputs_flag]

    exec.rpo::prepare_hasher_state
    exec.rpo::hash_memory_with_state
    # => [INPUTS_COMMITMENT]
end

#! Returns the max allowed number of input values per note.
#!
#! Stack: []
#! Output: [max_inputs_per_note]
#!
#! - max_inputs_per_note is the max inputs per note.
export.::miden::util::note::get_max_inputs_per_note

#! Writes the assets data stored in the advice map to the memory specified by the provided
#! destination pointer.
#!
#! Inputs:
#!   Operand stack: [ASSETS_COMMITMENT, num_assets, dest_ptr]
#!   Advice map: {
#!     ASSETS_COMMITMENT: [[ASSETS_DATA]]
#!   }
#! Outputs:
#!   Operand stack: [num_assets, dest_ptr]
export.write_assets_to_memory
    # load the asset data from the advice map to the advice stack
    adv.push_mapval
    # OS => [ASSETS_COMMITMENT, num_assets, dest_ptr]
    # AS => [[ASSETS_DATA]]

    # calculate number of assets rounded up to an even number
    dup.4 dup is_odd add
    # OS => [even_num_assets, ASSETS_COMMITMENT, num_assets, dest_ptr]
    # AS => [[ASSETS_DATA]]

    # prepare the stack for the `pipe_preimage_to_memory` procedure
    dup.6 swap
    # OS => [even_num_assets, dest_ptr, ASSETS_COMMITMENT, num_assets, dest_ptr]
    # AS => [[ASSETS_DATA]]

    # write the data from the advice stack into memory
    exec.mem::pipe_preimage_to_memory drop
    # OS => [num_assets, dest_ptr]
    # AS => []
end

#! Builds the recipient hash from note inputs, script root, and serial number.
#!
#! This procedure computes the commitment of the note inputs and then uses it to calculate the note
#! recipient by hashing this commitment, the provided script root, and the serial number.
#!
#! The procedure also inserts the following data into the advice map:
#! - Advice map: {
#!     INPUTS_COMMITMENT: [[NOTE_INPUTS]]
#!     RECIPIENT: [num_inputs, INPUTS_COMMITMENT, SCRIPT_ROOT, SERIAL_NUM]
#! }
#!
#! Inputs:  [inputs_ptr, num_inputs, SERIAL_NUM, SCRIPT_ROOT]
#! Outputs: [RECIPIENT]
#!
#! Where:
#! - inputs_ptr is the memory address where the note inputs are stored.
#! - num_inputs is the number of input values.
#! - SCRIPT_ROOT is the script root of the note.
#! - SERIAL_NUM is the serial number of the note.
#! - RECIPIENT is the commitment to the input note's script, inputs, and the serial number.
#!
#! Locals:
#! - 2: inputs_ptr
#! - 3: num_inputs (for NoteDetails format)
#! - 4..8: INPUTS_COMMITMENT
#! - 8..12: SCRIPT_ROOT
#! - 12..16: SERIAL_NUM
#!
#! Panics if:
#! - inputs_ptr is not word-aligned (i.e., is not a multiple of 4).
#! - num_inputs is greater than 128.
#!
#! Invocation: exec
export.build_recipient.16
    dup.1 dup.1 loc_store.2 loc_store.3
    # => [inputs_ptr, num_inputs, SERIAL_NUM, SCRIPT_ROOT]

    exec.compute_inputs_commitment
    # => [INPUTS_COMMITMENT, SERIAL_NUM, SCRIPT_ROOT]

    movdnw.2
    # => [SERIAL_NUM, SCRIPT_ROOT, INPUTS_COMMITMENT]

    dupw.2 dupw.2 dupw.2
    # => [SERIAL_NUM, SCRIPT_ROOT, INPUTS_COMMITMENT, SERIAL_NUM, SCRIPT_ROOT, INPUTS_COMMITMENT]

    exec.build_recipient_hash
    # => [RECIPIENT, SERIAL_NUM, SCRIPT_ROOT, INPUTS_COMMITMENT]

    # inserting NoteInputs into AdviceMap
    dupw.3
    # => [INPUTS_COMMITMENT, RECIPIENT, SERIAL_NUM, SCRIPT_ROOT, INPUTS_COMMITMENT]

    loc_load.2 loc_load.3 loc_load.2
    # => [inputs_ptr, num_inputs, inputs_ptr, INPUTS_COMMITMENT, RECIPIENT, SERIAL_NUM, SCRIPT_ROOT, INPUTS_COMMITMENT]

    add swap
    # => [inputs_ptr, end_ptr, INPUTS_COMMITMENT, RECIPIENT, SERIAL_NUM, SCRIPT_ROOT, INPUTS_COMMITMENT]

    movdn.5 movdn.5
    # => [INPUTS_COMMITMENT, inputs_ptr, end_ptr, RECIPIENT, SERIAL_NUM, SCRIPT_ROOT, INPUTS_COMMITMENT]

    adv.insert_mem
    # => [INPUTS_COMMITMENT, inputs_ptr, end_ptr, RECIPIENT, SERIAL_NUM, SCRIPT_ROOT, INPUTS_COMMITMENT]

    dropw drop drop
    # => [RECIPIENT, SERIAL_NUM, SCRIPT_ROOT, INPUTS_COMMITMENT]

    movdnw.3
    # => [SERIAL_NUM, SCRIPT_ROOT, INPUTS_COMMITMENT, RECIPIENT]

    # inserting NoteDetails into AdviceMap
    loc_storew.12 dropw loc_storew.8 dropw loc_storew.4 dropw
    # => [RECIPIENT]

    locaddr.3 dup add.RECIPIENT_DATA_ADVICE_STACK_LENGTH swap
    # => [mem_ptr, end_ptr, RECIPIENT]

    movdn.5 movdn.5
    # => [RECIPIENT, mem_ptr, end_ptr]

    adv.insert_mem
    # => [RECIPIENT, mem_ptr, end_ptr]

    movup.5 drop movup.4 drop
    # => [RECIPIENT]
end

#! Returns the RECIPIENT for a specified SERIAL_NUM, SCRIPT_ROOT, and inputs commitment.
#!
#! Inputs:  [SERIAL_NUM, SCRIPT_ROOT, INPUT_COMMITMENT]
#! Outputs: [RECIPIENT]
#!
#! Where:
#! - SERIAL_NUM is the serial number of the recipient.
#! - SCRIPT_ROOT is the commitment of the note script.
#! - INPUT_COMMITMENT is the commitment of the note inputs.
#! - RECIPIENT is the recipient of the note.
#!
#! Invocation: exec
export.build_recipient_hash
    padw hmerge
    # => [SERIAL_NUM_HASH, SCRIPT_ROOT, INPUT_COMMITMENT]

    swapw hmerge
    # => [MERGE_SCRIPT, INPUT_COMMITMENT]

    swapw hmerge
    # [RECIPIENT]
end

#! Extracts the sender ID from the provided metadata word.
#!
#! Inputs:  [METADATA]
#! Outputs: [sender_id_prefix, sender_id_suffix]
#!
#! Where:
#! - METADATA is the metadata of some note.
#! - sender_{prefix,suffix} are the prefix and suffix felts of the sender ID of the note which
#!   metadata was provided.
export.extract_sender_from_metadata
    # => [aux, merged_tag_hint_payload, merged_sender_id_type_hint_tag, sender_id_prefix]

    # drop aux felt and the felt containing tag, execution hint and payload
    drop drop
    # => [merged_sender_id_type_hint_tag, sender_id_prefix]

    # extract suffix of sender from merged layout, which means clearing the least significant byte
    exec.account_id::shape_suffix
    # => [sender_id_suffix, sender_id_prefix]

    # rearrange suffix and prefix
    swap
    # => [sender_id_prefix, sender_id_suffix]
end
