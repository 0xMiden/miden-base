use.miden::account
use.miden::tx

# CONSTANTS
# =================================================================================================

# Event to place the falcon signature of a provided message and public key on the advice stack.
const.FALCON_SIG_TO_STACK=131087

# The slot in this component's storage layout where the public key is stored.
const.PUBLIC_KEY_SLOT=0

# The slot where the number of auth trigger procedures is stored.
const.NUM_AUTH_TRIGGER_PROCS_SLOT=1

# The slot where the map of auth trigger procedure roots is stored.
const.AUTH_TRIGGER_PROCS_MAP_SLOT=2

#! Authenticate a transaction using the Falcon signature scheme based on procedure calls and note usage.
#!
#! This authentication procedure checks:
#! 1. If any of the trigger procedures were called during the transaction
#! 2. If input notes were consumed and allow_unauthorized_input_notes is false
#! 3. If output notes were created and allow_unauthorized_output_notes is false
#!
#! If any of these conditions are true, standard RpoFalcon512 signature verification is performed.
#! Otherwise, only the nonce is incremented.
#!
#! Inputs:  [pad(16)]
#! Outputs: [pad(16)]
export.auth__tx_rpo_falcon512_procedure_acl.2
    # Get the number of trigger procedures
    push.NUM_AUTH_TRIGGER_PROCS_SLOT exec.account::get_item
    # => [num_auth_trigger_procs, allow_unauthorized_output_notes, allow_unauthorized_input_notes, 0, pad(16)]

    drop
    # => [allow_unauthorized_input_notes, allow_unauthorized_output_notes, num_auth_trigger_procs, pad(16)]

    loc_store.1 loc_store.0
    # => [num_auth_trigger_procs, pad(16)]

    # Check if any trigger procedure was called
    # Counter `i` starts at `num_auth_trigger_procs` and flag `was_any_called` starts at 0
    push.0
    # => [was_any_called, i, pad(16)]

    # Loop through trigger procedures
    dup.1 neq.0
    while.true
        # => [was_any_called, i, pad(16)]

        # Get the procedure root from storage
        dup.1 sub.1 push.0.0.0 push.AUTH_TRIGGER_PROCS_MAP_SLOT
        # => [AUTH_TRIGGER_PROCS_MAP_SLOT, [0, 0, 0, i-1], was_any_called, i, pad(16)]

        exec.account::get_map_item
        # => [AUTH_TRIGGER_PROC_ROOT, was_any_called, i, pad(16)]

        exec.account::was_procedure_called
        # => [was_called, was_any_called, i, pad(16)]

        # Update was_any_called
        or
        # => [was_any_called', i, pad(16)]

        swap sub.1 swap
        # => [was_any_called', i-1, pad(16)]

        # Check if we should continue looping
        dup.1 neq.0
        # => [should_continue, was_any_called', i-1, pad(16)]
    end
    # => [was_any_called, i-1, pad(16)]

    swap drop
    # => [was_any_called, pad(16)]

    # ------ Check if output notes were created ------

    exec.tx::get_output_notes_commitment
    # => [OUTPUT_NOTES_COMMITMENT, was_any_called, pad(16)]

    padw eqw not movdn.8 dropw dropw
    # => [were_output_notes_created, was_any_called, pad(16)]

    loc_load.0 not
    # => [!allow_unauthorized_output_notes, were_output_notes_created, was_any_called, pad(16)]

    and
    # => [require_output_note_auth, was_any_called, pad(16)]

    # ------ Check if input notes were consumed ------

    exec.tx::get_input_notes_commitment
    # => [INPUT_NOTES_COMMITMENT, require_output_note_auth, was_any_called, pad(16)]

    padw eqw not movdn.8 dropw dropw
    # => [were_input_notes_consumed, require_output_note_auth, was_any_called, pad(16)]

    loc_load.1 not
    # => [!allow_unauthorized_input_notes, require_output_note_auth, was_any_called, pad(16)]

    and
    # => [require_input_note_auth, require_output_note_auth, was_any_called, pad(16)]

    or
    # => [require_note_auth, was_any_called, pad(16)]

    # Combine note-based auth requirement with procedure-based auth requirement
    or
    # => [require_auth, pad(16)]

    # If authentication is required (either note-based or procedure-based), perform signature verification
    if.true
        exec.::miden::contracts::auth::basic::auth__tx_rpo_falcon512
    else
        push.1 exec.account::incr_nonce
    end
    # => [pad(16)]

    repeat.4
        dropw
    end
    # => []
end
