use.miden::account
use.miden::active_note
use.miden::contracts::wallets::basic->wallet
use.miden::output_note

# CONSTANTS
# =================================================================================================

const.SWAP_NOTE_INPUTS_NUMBER=12

# ERRORS
# =================================================================================================
const.ERR_SWAP_WRONG_NUMBER_OF_INPUTS="SWAP script expects exactly 12 note inputs"

const.ERR_SWAP_WRONG_NUMBER_OF_ASSETS="SWAP script requires exactly 1 note asset"

#! SWAP note script: Facilitates atomic asset swaps between accounts.
#!
#! This script enables two modes of operation:
#!
#! 1. **Regular SWAP**: The consuming account provides liquidity from its own vault.
#!    - The offered asset from the SWAP note is added to the consumer's account.
#!    - The requested asset is moved from the consumer's account to a payback note for the issuer.
#!
#! 2. **In-Flight SWAP**: The consuming account matches multiple SWAP notes without providing
#!    liquidity from its own vault. This enables a "coincidence of wants" settlement where:
#!    - A matcher account can consume multiple SWAP notes that fulfill each other's requests.
#!    - The matcher doesn't need to hold any assets; liquidity comes from the SWAP notes themselves.
#!    - Assets flow directly between the original issuers via payback notes.
#!    - Example: Account A offers asset X for Y, Account B offers Y for X. A matcher can consume
#!      both notes in a single transaction, creating payback notes that satisfy both parties.
#!
#! The script automatically detects which mode to use by checking if the consuming account has
#! sufficient balance of the requested asset. If the account balance is less than the requested
#! amount, it assumes an in-flight swap and adds the requested asset directly to the payback note
#! without moving it from the account vault.
#!
#! Requires that the account exposes:
#! - miden::contracts::wallets::basic::receive_asset procedure (for regular swaps).
#! - miden::contracts::wallets::basic::move_asset_to_note procedure (for regular swaps).
#!
#! Inputs:  [ARGS]
#! Outputs: []
#!
#! Note inputs are assumed to be as follows:
#! - REQUESTED_ASSET (Word): The asset the note issuer wants to receive
#! - PAYBACK_NOTE_RECIPIENT (Word): The recipient digest for the payback note
#! - payback_note_execution_hint (Felt): Execution hint for the payback note
#! - payback_note_type (Felt): Type of the payback note (public/private)
#! - payback_note_aux (Felt): Auxiliary data for the payback note
#! - payback_note_tag (Felt): Tag for the payback note
#!
#! Panics if:
#! - The number of note inputs is not exactly 12.
#! - The number of note assets is not exactly 1.
#! - For regular swaps: account does not expose required wallet procedures.
#! - For regular swaps: account vault does not contain sufficient requested asset.
#! - Adding a fungible asset would result in amount overflow (total > 2^63).
begin
    # dropping note args
    dropw
    # => []

    # --- create a payback note with the requested asset ----------------

    # store note inputs into memory starting at address 0
    push.0 exec.active_note::get_inputs
    # => [num_inputs, inputs_ptr]

    # make sure the number of inputs is 12
    eq.SWAP_NOTE_INPUTS_NUMBER assert.err=ERR_SWAP_WRONG_NUMBER_OF_INPUTS
    # => [inputs_ptr]

    # load REQUESTED_ASSET
    mem_loadw
    # => [REQUESTED_ASSET]

    # load PAYBACK_NOTE_RECIPIENT
    padw mem_loadw.4
    # => [PAYBACK_NOTE_RECIPIENT, REQUESTED_ASSET]

    # load payback P2ID details
    padw mem_loadw.8
    # => [tag, aux, note_type, execution_hint, PAYBACK_NOTE_RECIPIENT, REQUESTED_ASSET]

    # create payback P2ID note
    exec.output_note::create
    # => [note_idx, REQUESTED_ASSET]

    movdn.4
    # => [REQUESTED_ASSET, note_idx]

    # --- check balance of REQUESTED_ASSET -------------------------
    # if account balance < REQUESTED_ASSET -> assume inflight SWAP
    # else settle SWAP note against account

    dup.1 dup.1
    # => [faucet_prefix, fauet_suffix, REQUESTED_ASSET, note_idx]

    exec.account::get_balance
    # => [requested_asset_balance, REQUESTED_ASSET, note_idx]

    dup.4
    # => [requested_amount, requested_asset_balance, REQUESTED_ASSET, note_idx]

    lt
    # => [try_inflight_swap, REQUESTED_ASSET, note_idx]

    if.true
        # IN-FLIGHT SWAP (liquidity from counterparty SWAP note)

        # add "asset" to note
        exec.output_note::add_asset
        # => [REQUESTED_ASSET, note_idx]

        dropw drop
        # => []
    else
        # REGULAR SWAP (liquidity from account)

        # padding stack with 11 zeros
        repeat.11
            push.0
            movdn.5
        end

        # move asset to the note
        call.wallet::move_asset_to_note
        # => [REQUESTED_ASSET, note_idx, pad(11)]

        # --- move assets from the SWAP note into the account -------------------------

        # store the number of note assets to memory starting at address 0
        push.0 exec.active_note::get_assets
        # => [num_assets, ptr, pad(12)]

        # make sure the number of assets is 1
        assert.err=ERR_SWAP_WRONG_NUMBER_OF_ASSETS
        # => [ptr, pad(12)]

        # load the ASSET
        mem_loadw
        # => [ASSET, pad(12)]

        # add the ASSET to the account
        call.wallet::receive_asset
        # => [pad(16)]

        # clearing the stack of padded 0s
        repeat.4
            dropw
        end
        # => []
    end
    # => []
end
