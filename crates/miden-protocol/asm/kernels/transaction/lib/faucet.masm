use $kernel::account
use $kernel::account_id
use $kernel::asset
use $kernel::asset_vault
use $kernel::memory
use $kernel::util::asset::FUNGIBLE_ASSET_MAX_AMOUNT

#Â ERRORS
# =================================================================================================

const ERR_FAUCET_BURN_NON_FUNGIBLE_ASSET_CAN_ONLY_BE_CALLED_ON_NON_FUNGIBLE_FAUCET="the burn_non_fungible_asset procedure can only be called on a non-fungible faucet"

# FUNGIBLE ASSETS
# ==================================================================================================

#! Mints a fungible asset associated with the fungible faucet the transaction is being executed
#! against.
#!
#! Inputs:  [ASSET]
#! Outputs: [ASSET]
#!
#! Where:
#! - amount is the amount of the fungible asset to mint.
#! - ASSET is the asset that was minted.
#!
#! Panics if:
#! - the transaction is not being executed against a fungible faucet.
#! - the fungible asset being minted is not associated with the faucet the transaction is being
#!   executed against.
#! - the asset is not well formed.
#! - the total issuance after minting is greater than the maximum amount allowed.
pub proc mint_fungible_asset
    # assert that the asset was issued by the faucet the transaction is being executed against and
    # that the asset is valid
    exec.account::get_id
    exec.asset::validate_fungible_asset_origin
    # => [ASSET]

    exec.memory::get_input_vault_root_ptr
    movdn.4
    # => [ASSET, input_vault_root_ptr]

    # add the asset to the input vault for asset preservation
    exec.asset_vault::add_fungible_asset
    # => [ASSET]
end

#! Burns a fungible asset associated with the fungible faucet the transaction is being executed
#! against.
#!
#! Inputs:  [ASSET]
#! Outputs: [ASSET]
#!
#! Where:
#! - ASSET is the asset that was burned.
#!
#! Panics if:
#! - the transaction is not being executed against a fungible faucet.
#! - the fungible asset being burned is not associated with the faucet the transaction is being
#!   executed against.
#! - the asset is not well formed.
proc burn_fungible_asset
    # assert that the asset is associated with the faucet the transaction is being executed against
    # and that the asset is valid
    exec.account::get_id
    exec.asset::validate_fungible_asset_origin
    # => [ASSET]

    exec.memory::get_input_vault_root_ptr
    movdn.4
    # => [ASSET, input_vault_root_ptr]

    # remove the asset from the input vault for asset preservation
    exec.asset_vault::remove_fungible_asset
    # => [ASSET]
end

#! Returns the total issuance of the fungible faucet the transaction is being executed against.
#!
#! Inputs:  []
#! Outputs: [total_issuance]
#!
#! Where:
#! - total_issuance is the total issuance of the fungible faucet the transaction is being executed
#!   against.
pub proc get_total_issuance
    # fetch the TOTAL_ISSUANCE from storage
    exec.account::get_faucet_sysdata_slot_id exec.account::get_item
    # => [TOTAL_ISSUANCE]

    # extract the total_issuance and purge the padding
    movdn.3 drop drop drop
    # => [total_issuance]
end

# NON-FUNGIBLE ASSETS
# ==================================================================================================

#! Mints a non-fungible asset associated with the non-fungible faucet the transaction is being
#! executed against.
#!
#! Inputs:  [ASSET]
#! Outputs: [ASSET]
#!
#! Where:
#! - ASSET is the asset that was minted.
#!
#! Panics if:
#! - the transaction is not being executed against a non-fungible faucet.
#! - the non-fungible asset being minted is not associated with the faucet the transaction is being
#!   executed against.
proc mint_non_fungible_asset
    # assert that the asset is associated with the faucet the transaction is being executed against
    # and that the asset is valid
    exec.account::get_id
    swap drop
    # => [faucet_id_prefix, ASSET]

    exec.asset::validate_non_fungible_asset_origin
    # => [ASSET]

    exec.memory::get_input_vault_root_ptr
    movdn.4
    # => [ASSET, input_vault_root_ptr]

    # add the non-fungible asset to the input vault for asset preservation
    exec.asset_vault::add_non_fungible_asset
    # => [ASSET]
end

#! Burns a non-fungible asset associated with the non-fungible faucet the transaction is being
#! executed against.
#!
#! Inputs:  [ASSET]
#! Outputs: [ASSET]
#!
#! Where:
#! - ASSET is the asset that was burned.
#!
#! Panics if:
#! - the transaction is not being executed against a non-fungible faucet.
#! - the non-fungible asset being burned is not associated with the faucet the transaction is being
#!   executed against.
proc burn_non_fungible_asset
    # assert that the asset was issued by the faucet the transaction is being executed against and
    # that the asset is valid
    exec.account::get_id
    swap drop
    # => [faucet_id_prefix, ASSET]

    exec.asset::validate_non_fungible_asset_origin
    # => [ASSET]

    # remove the non-fungible asset from the input vault for asset preservation
    exec.memory::get_input_vault_root_ptr
    movdn.4
    # => [ASSET, input_vault_root_ptr]

    exec.asset_vault::remove_non_fungible_asset
    # => [ASSET]
end

#! Returns a boolean indicating whether the provided non-fungible asset has been already issued by
#! this faucet.
#!
#! Inputs:  [ASSET]
#! Outputs: [is_issued]
#!
#! Where:
#! - ASSET is the non-fungible asset that is being checked.
#! - is_issued is a boolean indicating whether the non-fungible asset has been issued.
#!
#! Panics if:
#! - the ASSET is a fungible asset.
#! - the ASSET is not associated with the faucet the transaction is being executed against.
pub proc is_non_fungible_asset_issued
    # assert that the asset is associated with the faucet the transaction is being executed against
    # and that the asset is valid
    exec.account::get_id swap drop exec.asset::validate_non_fungible_asset_origin
    # => [ASSET]

    # get the asset vault key from the asset
    exec.asset_vault::build_non_fungible_asset_vault_key
    # => [ASSET_KEY]

    # get the storage index where faucet's assets map is stored
    exec.account::get_faucet_sysdata_slot_id
    # => [map_slot_index, ASSET_KEY]

    # get the non-fungible asset stored by the computed account key
    exec.account::get_map_item
    # => [STORED_ASSET]

    # Check whether the `STORED_ASSET` is an EMPTY_WORD, indicating that the non-fungible asset has
    # not been issued yet. We only need to check STORED_ASSET[3] as this is always set to the
    # faucet_id_prefix and can not be 0 (in reversed stack order it will be top stack element).
    # Equality of the STORED_ASSET[3] to zero will become a flag that this asset is not issued.
    neq.0 movdn.3 drop drop drop
    # => [is_issued]
end

# PUBLIC INTERFACE
# ==================================================================================================

#! Mint an asset from the faucet the transaction is being executed against.
#!
#! Inputs:  [ASSET]
#! Outputs: [ASSET]
#!
#! Where:
#! - ASSET is the asset that was minted.
#!
#! Panics if:
#! - the transaction is not being executed against a faucet.
#! - the asset being minted is not associated with the faucet the transaction is being executed
#!   against.
#! - the asset is not well formed.
#! - For fungible faucets if the total issuance after minting is greater than the maximum amount
#!   allowed.
#! - For non-fungible faucets if the non-fungible asset being minted already exists.
pub proc mint
    # check if the asset is a fungible asset
    exec.asset::is_fungible_asset
    # => [is_fungible_asset, ASSET]

    if.true
        # mint the fungible asset
        exec.mint_fungible_asset
        # => [ASSET]
    else
        # mint the non-fungible asset
        exec.mint_non_fungible_asset
        # => [ASSET]
    end
end

#! Burn an asset from the faucet the transaction is being executed against.
#!
#! Inputs:  [ASSET]
#! Outputs: [ASSET]
#!
#! Where:
#! - ASSET is the asset that was burned.
#!
#! Panics if:
#! - the transaction is not being executed against a faucet.
#! - the asset being burned is not associated with the faucet the transaction is being executed
#!   against.
#! - the asset is not well formed.
#! - For fungible faucets if the amount being burned is greater than the total input to the
#!   transaction.
#! - For non-fungible faucets if the non-fungible asset being burned does not exist or was not
#!   provided as input to the transaction via a note or the accounts vault.
pub proc burn
    # check if the asset is a fungible asset
    exec.asset::is_fungible_asset
    # => [is_fungible_asset, ASSET]

    if.true
        # burn the fungible asset
        exec.burn_fungible_asset
        # => [ASSET]
    else
        # burn the non-fungible asset
        exec.burn_non_fungible_asset
        # => [ASSET]
    end
end
