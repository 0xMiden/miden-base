use miden::core::mem

use miden::protocol::kernel_proc_offsets
use miden::protocol::note

#Â ERRORS
# =================================================================================================

const ERR_NOTE_DATA_DOES_NOT_MATCH_COMMITMENT="note data does not match the commitment"

const ERR_NOTE_INVALID_NUMBER_OF_INPUTS="the specified number of note inputs does not match the actual number"

# ACTIVE NOTE PROCEDURES
# =================================================================================================
#
# By the "active note" notion here we assume the note which is currently being processed by the
# transaction kernel.

#! Writes the assets of the active note into memory starting at the specified address.
#!
#! Inputs:  [dest_ptr]
#! Outputs: [num_assets, dest_ptr]
#!
#! Where:
#! - dest_ptr is the memory address to write the assets.
#! - num_assets is the number of assets in the active note.
#!
#! Panics if:
#! - no note is currently active.
#!
#! Invocation: exec
pub proc get_assets
    # pad the stack
    padw padw padw push.0.0
    # => [pad(14), dest_ptr]

    # push the flag indicating that we want to request assets info from the active note
    push.1
    # => [is_active_note = 1, pad(14), dest_ptr]

    exec.kernel_proc_offsets::input_note_get_assets_info_offset
    # => [offset, is_active_note = 1, pad(14), dest_ptr]

    syscall.exec_kernel_proc
    # => [ASSETS_COMMITMENT, num_assets, pad(11), dest_ptr]

    # clean the stack
    swapdw dropw dropw movup.7 movup.7 movup.7 drop drop drop
    # => [ASSETS_COMMITMENT, num_assets, dest_ptr]

    # write the assets from the advice map into memory
    exec.note::write_assets_to_memory
    # => [num_assets, dest_ptr]
end

#! Returns the recipient of the active note.
#!
#! Inputs:  []
#! Outputs: [RECIPIENT]
#!
#! Where:
#! - RECIPIENT is the commitment to the active note's script, inputs, the serial number.
#!
#! Panics if:
#! - no note is currently active.
#!
#! Invocation: exec
pub proc get_recipient
    # pad the stack
    padw padw padw push.0.0
    # => [pad(14)]

    # push the flag indicating that we want to request recipient from the active note
    push.1
    # => [is_active_note = 1, pad(14)]

    exec.kernel_proc_offsets::input_note_get_recipient_offset
    # => [offset, is_active_note = 1, pad(14)]

    syscall.exec_kernel_proc
    # => [RECIPIENT, pad(12)]

    # clean the stack
    swapdw dropw dropw swapw dropw
    # => [RECIPIENT]
end

#! Writes the active note's inputs to memory starting at the specified address.
#!
#! Inputs:
#!   Stack: [dest_ptr]
#!   Advice Map: { NOTE_INPUTS_COMMITMENT: [INPUTS] }
#! Outputs:
#!   Stack: [num_inputs, dest_ptr]
#!
#! Where:
#! - dest_ptr is the memory address to write the note inputs.
#! - NOTE_INPUTS_COMMITMENT is the sequential hash of the padded note's inputs.
#! - INPUTS is the data corresponding to the note's inputs.
#!
#! Panics if:
#! - no note is currently active.
#!
#! Invocation: exec
pub proc get_inputs
    # pad the stack
    padw padw padw push.0.0
    # => [pad(14), dest_ptr]

    # push the flag indicating that we want to request inputs info from the active note
    push.1
    # => [is_active_note = 1, pad(14), dest_ptr]

    exec.kernel_proc_offsets::input_note_get_inputs_info_offset
    # => [offset, is_active_note = 1, pad(14), dest_ptr]

    syscall.exec_kernel_proc
    # => [NOTE_INPUTS_COMMITMENT, num_inputs, pad(11), dest_ptr]

    # clean the stack
    swapdw dropw dropw
    movup.5 drop movup.5 drop movup.5 drop
    # => [NOTE_INPUTS_COMMITMENT, num_inputs, dest_ptr]

    # write the inputs to the memory using the provided destination pointer
    exec.write_inputs_to_memory
    # => [num_inputs, dest_ptr]
end

#! Returns the metadata of the active note.
#!
#! Inputs:  []
#! Outputs: [METADATA]
#!
#! Where:
#! - METADATA is the metadata of the active note.
#!
#! Panics if:
#! - no note is currently active.
#!
#! Invocation: exec
pub proc get_metadata
    # pad the stack
    padw padw padw push.0.0
    # => [pad(14)]

    # push the flag indicating that we want to request metadata from the active note
    push.1
    # => [is_active_note = 1, pad(14)]

    exec.kernel_proc_offsets::input_note_get_metadata_offset
    # => [offset, is_active_note = 1, pad(14)]

    syscall.exec_kernel_proc
    # => [METADATA, pad(12)]

    # clean the stack
    swapdw dropw dropw swapw dropw
    # => [METADATA]
end

#! Returns the sender of the active note.
#!
#! Inputs:  []
#! Outputs: [sender_id_prefix, sender_id_suffix]
#!
#! Where:
#! - sender_{prefix,suffix} are the prefix and suffix felts of the sender of the active note.
#!
#! Panics if:
#! - no note is currently active.
#!
#! Invocation: exec
pub proc get_sender
    # pad the stack
    padw padw padw push.0.0
    # => [pad(14)]

    # push the flag indicating that we want to request metadata from the active note
    push.1
    # => [is_active_note = 1, pad(14)]

    exec.kernel_proc_offsets::input_note_get_metadata_offset
    # => [offset, is_active_note = 1, pad(14)]

    syscall.exec_kernel_proc
    # => [METADATA, pad(12)]

    # extract the sender ID from the metadata word
    exec.note::extract_sender_from_metadata
    # => [sender_id_prefix, sender_id_suffix, pad(12)]

    # clean the stack
    swapw dropw swapw dropw movdn.5 movdn.5 dropw
    # => [sender_id_prefix, sender_id_suffix]
end

#! Returns the serial number of the active note.
#!
#! Inputs:  []
#! Outputs: [SERIAL_NUMBER]
#!
#! Where:
#! - SERIAL_NUMBER is the serial number of the active note.
#!
#! Panics if:
#! - no note is currently active.
#!
#! Invocation: exec
pub proc get_serial_number
    # pad the stack
    padw padw padw push.0.0
    # => [pad(14)]

    # push the flag indicating that we want to request serial number from the active note
    push.1
    # => [is_active_note = 1, pad(14)]

    exec.kernel_proc_offsets::input_note_get_serial_number_offset
    # => [offset, is_active_note = 1, pad(14)]

    syscall.exec_kernel_proc
    # => [SERIAL_NUMBER, pad(12)]

    # clean the stack
    swapdw dropw dropw swapw dropw
    # => [SERIAL_NUMBER]
end

#! Returns the script root of the active note.
#!
#! Inputs:  []
#! Outputs: [SCRIPT_ROOT]
#!
#! Where:
#! - SCRIPT_ROOT is the script root of the active note.
#!
#! Panics if:
#! - no note is currently active.
#!
#! Invocation: exec
pub proc get_script_root
    # pad the stack
    padw padw padw push.0.0
    # => [pad(14)]

    # push the flag indicating that we want to request script root from the active note
    push.1
    # => [is_active_note = 1, pad(14)]

    exec.kernel_proc_offsets::input_note_get_script_root_offset
    # => [offset, is_active_note = 1, pad(14)]

    syscall.exec_kernel_proc
    # => [SCRIPT_ROOT, pad(12)]

    # clean the stack
    swapdw dropw dropw swapw dropw
    # => [SCRIPT_ROOT]
end

#Â HELPER PROCEDURES
# =================================================================================================

#! Writes the note inputs stored in the advice map to the memory specified by the provided
#! destination pointer.
#!
#! Inputs:
#!   Operand stack: [NOTE_INPUTS_COMMITMENT, num_inputs, dest_ptr]
#!   Advice map: {
#!     NOTE_INPUTS_COMMITMENT: [[INPUT_VALUES]]
#!   }
#! Outputs:
#!   Operand stack: [num_inputs, dest_ptr]
proc write_inputs_to_memory
    # load the inputs from the advice map to the advice stack
    adv.push_mapvaln.8
    # OS => [NOTE_INPUTS_COMMITMENT, num_inputs, dest_ptr]
    # AS => [advice_num_inputs, [INPUT_VALUES]]

    # move the number of inputs obtained from advice map to the operand stack
    adv_push.1 dup.5
    # OS => [num_inputs, advice_num_inputs, NOTE_INPUTS_COMMITMENT, num_inputs, dest_ptr]
    # AS => [[INPUT_VALUES]]

    assert_eq.err=ERR_NOTE_INVALID_NUMBER_OF_INPUTS
    # OS => [NOTE_INPUTS_COMMITMENT, num_inputs, dest_ptr]
    # AS => [[INPUT_VALUES]]

    # calculate the number of words required to store the inputs
    dup.4 u32divmod.4 neq.0 add
    # OS => [num_words, NOTE_INPUTS_COMMITMENT, num_inputs, dest_ptr]
    # AS => [[INPUT_VALUES]]

    # round up the number of words to the next multiple of 2
    dup is_odd add
    # OS => [even_num_words, NOTE_INPUTS_COMMITMENT, num_inputs, dest_ptr]
    # AS => [[INPUT_VALUES]]

    # prepare the stack for the `pipe_preimage_to_memory` procedure
    dup.6 swap
    # OS => [even_num_words, dest_ptr, NOTE_INPUTS_COMMITMENT, num_inputs, dest_ptr]
    # AS => [[INPUT_VALUES]]

    # write the inputs from the advice stack into memory
    exec.mem::pipe_preimage_to_memory drop
    # OS => [num_inputs, dest_ptr]
    # AS => []
end
