use miden::protocol::account_id
use miden::core::crypto::hashes::rpo256
use miden::core::math::u64
use miden::core::mem

# Re-export the max inputs per note constant.
pub use ::miden::protocol::util::note::MAX_NOTE_STORAGE_ITEMS

#Â ERRORS
# =================================================================================================

const ERR_PROLOGUE_NOTE_STORAGE_LEN_EXCEEDED_LIMIT="number of note storage exceeded the maximum limit of 1024"

# NOTE UTILITY PROCEDURES
# =================================================================================================

#! Computes the commitment to the note storage starting at the specified memory address.
#!
#! This procedure checks that the provided number of note storage is within limits and then computes
#! the commitment.
#!
#! If the number of note storage is 0, procedure returns the empty word: [0, 0, 0, 0].
#!
#! Inputs:  [inputs_ptr, storage_len]
#! Outputs: [STORAGE_COMMITMENT]
#!
#! Cycles:
#! - If number of elements divides by 8: 56 cycles + 3 * words
#! - Else: 189 cycles + 3 * words
#!
#! Panics if:
#! - inputs_ptr is not word-aligned (i.e., is not a multiple of 4).
#! - storage_len is greater than 1024.
#!
#! Invocation: exec
pub proc compute_storage_commitment
    # check that number of storage items is less than or equal to MAX_NOTE_STORAGE_ITEMS
    dup.1 push.MAX_NOTE_STORAGE_ITEMS u32assert2.err=ERR_PROLOGUE_NOTE_STORAGE_LEN_EXCEEDED_LIMIT
    u32lte assert.err=ERR_PROLOGUE_NOTE_STORAGE_LEN_EXCEEDED_LIMIT
    # => [inputs_ptr, storage_len]

    # compute the inputs commitment (over the unpadded values)
    exec.rpo256::hash_elements
    # => [STORAGE_COMMITMENT]
end

#! Writes the assets data stored in the advice map to the memory specified by the provided
#! destination pointer.
#!
#! Inputs:
#!   Operand stack: [ASSETS_COMMITMENT, num_assets, dest_ptr]
#!   Advice map: {
#!     ASSETS_COMMITMENT: [[ASSETS_DATA]]
#!   }
#! Outputs:
#!   Operand stack: [num_assets, dest_ptr]
pub proc write_assets_to_memory
    # load the asset data from the advice map to the advice stack
    adv.push_mapval
    # OS => [ASSETS_COMMITMENT, num_assets, dest_ptr]
    # AS => [[ASSETS_DATA]]

    # calculate number of assets rounded up to an even number
    dup.4 dup is_odd add
    # OS => [even_num_assets, ASSETS_COMMITMENT, num_assets, dest_ptr]
    # AS => [[ASSETS_DATA]]

    # prepare the stack for the `pipe_preimage_to_memory` procedure
    dup.6 swap
    # OS => [even_num_assets, dest_ptr, ASSETS_COMMITMENT, num_assets, dest_ptr]
    # AS => [[ASSETS_DATA]]

    # write the data from the advice stack into memory
    exec.mem::pipe_preimage_to_memory drop
    # OS => [num_assets, dest_ptr]
    # AS => []
end

#! Builds the recipient hash from note storage, script root, and serial number.
#!
#! This procedure computes the commitment of the note storage and then uses it to calculate the note
#! recipient by hashing this commitment, the provided script root, and the serial number.
#!
#! Inputs:
#!   Operand stack: [inputs_ptr, storage_len, SERIAL_NUM, SCRIPT_ROOT]
#!   Advice map: {
#!      STORAGE_COMMITMENT: [INPUTS],
#!   }
#! Outputs:
#!   Operand stack: [RECIPIENT]
#!   Advice map: {
#!      STORAGE_COMMITMENT: [INPUTS],
#!      RECIPIENT: [SERIAL_SCRIPT_HASH, STORAGE_COMMITMENT],
#!      SERIAL_SCRIPT_HASH: [SERIAL_HASH, SCRIPT_ROOT],
#!      SERIAL_HASH: [SERIAL_NUM, EMPTY_WORD],
#!   }
#!
#! Where:
#! - inputs_ptr is the memory address where the note storage are stored.
#! - storage_len is the number of input values.
#! - SCRIPT_ROOT is the script root of the note.
#! - SERIAL_NUM is the serial number of the note.
#! - RECIPIENT is the commitment to the input note's script, inputs, and the serial number.
#!
#! Locals:
#! - 0: inputs_ptr
#! - 1: storage_len
#!
#! Panics if:
#! - inputs_ptr is not word-aligned (i.e., is not a multiple of 4).
#! - storage_len is greater than 1024.
#!
#! Invocation: exec
@locals(1)
pub proc build_recipient
    dup.1 dup.1
    # => [inputs_ptr, storage_len, inputs_ptr, storage_len, SERIAL_NUM, SCRIPT_ROOT]

    exec.compute_storage_commitment
    # => [STORAGE_COMMITMENT, inputs_ptr, storage_len, SERIAL_NUM, SCRIPT_ROOT]

    # store storage_len into local memory
    dup.5 loc_store.0
    # => [STORAGE_COMMITMENT, inputs_ptr, storage_len, SERIAL_NUM, SCRIPT_ROOT]

    locaddr.0 add.1
    locaddr.0
    # => [storage_len_start_ptr, storage_len_end_ptr, STORAGE_COMMITMENT, inputs_ptr, storage_len, SERIAL_NUM, SCRIPT_ROOT]

    dup.5 dup.5 dup.5 dup.5
    # => [STORAGE_COMMITMENT, storage_len_start_ptr, storage_len_end_ptr,
    #     STORAGE_COMMITMENT, inputs_ptr, storage_len, SERIAL_NUM, SCRIPT_ROOT]

    # compute the advice map key for storage_len by hashing the inputs commitment
    hash
    # => [hash(STORAGE_COMMITMENT), storage_len_start_ptr, storage_len_end_ptr,
    #     STORAGE_COMMITMENT, inputs_ptr, storage_len, SERIAL_NUM, SCRIPT_ROOT]

    adv.insert_mem
    dropw drop drop
    # => [STORAGE_COMMITMENT, inputs_ptr, storage_len, SERIAL_NUM, SCRIPT_ROOT]

    movup.5 movup.5 dup movdn.2
    # => [inputs_ptr, storage_len, inputs_ptr, STORAGE_COMMITMENT, SERIAL_NUM, SCRIPT_ROOT]

    add swap
    # => [inputs_ptr, end_ptr, STORAGE_COMMITMENT, SERIAL_NUM, SCRIPT_ROOT]

    movdn.5 movdn.5
    # => [STORAGE_COMMITMENT, inputs_ptr, end_ptr, SERIAL_NUM, SCRIPT_ROOT]

    adv.insert_mem
    # => [STORAGE_COMMITMENT, inputs_ptr, end_ptr, SERIAL_NUM, SCRIPT_ROOT]

    movup.4 drop movup.4 drop
    # => [STORAGE_COMMITMENT, SERIAL_NUM, SCRIPT_ROOT]

    movdnw.2
    # => [SERIAL_NUM, SCRIPT_ROOT, STORAGE_COMMITMENT]

    padw adv.insert_hdword hmerge
    # => [SERIAL_HASH, SCRIPT_ROOT, STORAGE_COMMITMENT]

    swapw adv.insert_hdword hmerge
    # => [SERIAL_SCRIPT_HASH, STORAGE_COMMITMENT]

    swapw adv.insert_hdword hmerge
    # => [RECIPIENT]
end

#! Returns the RECIPIENT for a specified SERIAL_NUM, SCRIPT_ROOT, and storage commitment.
#!
#! Inputs:  [SERIAL_NUM, SCRIPT_ROOT, STORAGE_COMMITMENT]
#! Outputs: [RECIPIENT]
#!
#! Where:
#! - SERIAL_NUM is the serial number of the recipient.
#! - SCRIPT_ROOT is the commitment of the note script.
#! - STORAGE_COMMITMENT is the commitment of the note storage.
#! - RECIPIENT is the recipient of the note.
#!
#! Invocation: exec
pub proc build_recipient_hash
    padw hmerge
    # => [SERIAL_NUM_HASH, SCRIPT_ROOT, STORAGE_COMMITMENT]

    swapw hmerge
    # => [MERGE_SCRIPT, STORAGE_COMMITMENT]

    swapw hmerge
    # [RECIPIENT]
end

#! Extracts the sender ID from the provided metadata header.
#!
#! Inputs:  [METADATA_HEADER]
#! Outputs: [sender_id_prefix, sender_id_suffix]
#!
#! Where:
#! - METADATA_HEADER is the metadata of a note.
#! - sender_{prefix,suffix} are the prefix and suffix felts of the sender ID of the note which
#!   metadata was provided.
pub proc extract_sender_from_metadata
    # => [attachment_kind_scheme, tag, sender_id_prefix, sender_id_suffix_and_note_type]

    # drop attachment kind, attachment scheme and tag
    drop drop swap
    # => [sender_id_suffix_and_note_type, sender_id_prefix]

    # extract suffix of sender from merged layout, which means clearing the least significant byte
    exec.account_id::shape_suffix
    # => [sender_id_suffix, sender_id_prefix]

    # rearrange suffix and prefix
    swap
    # => [sender_id_prefix, sender_id_suffix]
end

#! Computes the tag for a network note for a given network account such that it is
#! picked up by the network transaction builder.
#!
#! This procedure implements the same logic as in Rust in NoteTag::from_network_account_id().
#! Note: This procedure does not check if the account id is a network account id.
#!
#! Inputs:  [account_id_prefix, account_id_suffix]
#! Outputs: [network_account_tag]
#!
#! Where:
#! - account_id_prefix, account_id_suffix is the account id to compute the note tag for.
#! - network_account_tag is the computed network note tag.
#!
#! Invocation: exec
pub proc build_note_tag_for_network_account
    swap drop
    # => [account_id_prefix]

    u32split
    # => [a_hi, a_lo]

    push.34
    # => [b, a_hi, a_lo]

    exec.u64::shr
    # => [c_hi, c_lo]

    drop
    # => [network_account_tag]
end
